//
// AUTOMATICALLY GENERATED: DO NOT EDIT
// @generated by gen-ext-hhvm.cpp
// /tmp/hhvm-3.12.0/hphp/tools/bootstrap/gen-ext-hhvm
//   x64
//   /tmp/hhvm-3.12.0/hphp/runtime/ext_hhvm/../../system/idl/CMakeFiles/hphp_runtime_ext.dir/collections.idl.json.ext_hhvm.h
//   /tmp/hhvm-3.12.0/hphp/runtime/ext_hhvm/../../system/idl/CMakeFiles/hphp_runtime_ext.dir/collections.idl.json.ext_hhvm.cpp
//   /tmp/hhvm-3.12.0/hphp/runtime/ext_hhvm/../../system/idl/collections.idl.json
//

#include "hphp/runtime/ext_hhvm/ext_hhvm.h"
#include "hphp/runtime/base/builtin-functions.h"
#include "hphp/runtime/base/array-init.h"
#include "hphp/runtime/ext/ext.h"
#include "hphp/runtime/vm/class.h"
#include "hphp/runtime/vm/runtime.h"
#include "hphp/util/abi-cxx.h"
#include <exception>

namespace HPHP {


ObjectData* new_Vector_Instance(HPHP::Class* cls) {
  size_t nProps = cls->numDeclProperties();
  size_t builtinObjSize = sizeof(c_Vector) - sizeof(ObjectData);
  size_t size = ObjectData::sizeForNProps(nProps) + builtinObjSize;
  auto o = new (MM().objMalloc(size)) c_Vector(cls);
  assert(o->hasExactlyOneRef());
  return o;
}


void delete_Vector(ObjectData* obj, const Class* cls) {
  auto const ptr = static_cast<c_Vector*>(obj);
  ptr->~c_Vector();

  auto const nProps = cls->numDeclProperties();
  auto const propVec = reinterpret_cast<TypedValue*>(ptr + 1);
  for (auto i = Slot{0}; i < nProps; ++i) {
    tvRefcountedDecRef(&propVec[i]);
  }

  auto const builtinSz = sizeof(c_Vector) - sizeof(ObjectData);
  auto const size = ObjectData::sizeForNProps(nProps) + builtinSz;
  if (LIKELY(size <= kMaxSmallSize)) {
    return MM().freeSmallSize(ptr, size);
  }
  return MM().freeBigSize(ptr, size);
}

IMPLEMENT_CLASS_NO_SWEEP(Vector);
TypedValue* tg_6Vector___construct(ActRec* ar) {
  void (*th_6Vector___construct)(c_Vector*,TypedValue*) =
    (void (*)(c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t___construct);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count <= 1)) {
      rv->m_type = KindOfNull;
      th_6Vector___construct((this_), (count > 0) ? (args-0) : (TypedValue*)(&null_variant));
    } else {
      throw_toomany_arguments_nr("Vector::__construct", 1, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::__construct");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_isEmpty(ActRec* ar) {
  bool (*th_6Vector_isEmpty)(c_Vector*) =
    (bool (*)(c_Vector*))getMethodPtr(&HPHP::c_Vector::t_isempty);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_6Vector_isEmpty((this_))) ? 1LL : 0LL;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::isEmpty", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::isEmpty");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_count(ActRec* ar) {
  int64_t (*th_6Vector_count)(c_Vector*) =
    (int64_t (*)(c_Vector*))getMethodPtr(&HPHP::c_Vector::t_count);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfInt64;
      rv->m_data.num = (int64_t)th_6Vector_count((this_));
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::count", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::count");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_items(ActRec* ar) {
  Value* (*th_6Vector_items)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_items);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_items(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::items", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::items");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_keys(ActRec* ar) {
  Value* (*th_6Vector_keys)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_keys);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_keys(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::keys", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::keys");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_values(ActRec* ar) {
  Value* (*th_6Vector_values)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_values);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_values(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::values", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::values");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_lazy(ActRec* ar) {
  Value* (*th_6Vector_lazy)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_lazy);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_lazy(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::lazy", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::lazy");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_at(ActRec* ar) {
  TypedValue* (*th_6Vector_at)(TypedValue*,c_Vector*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_at);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_6Vector_at(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::at", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::at");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_get(ActRec* ar) {
  TypedValue* (*th_6Vector_get)(TypedValue*,c_Vector*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_get);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_6Vector_get(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::get", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::get");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_set(ActRec* ar) {
  Value* (*th_6Vector_set)(Value*,c_Vector*,TypedValue*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_set);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      rv->m_type = KindOfObject;
      th_6Vector_set(&(rv->m_data), (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::set", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::set");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_setAll(ActRec* ar) {
  Value* (*th_6Vector_setAll)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_setall);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_setAll(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::setAll", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::setAll");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_clear(ActRec* ar) {
  Value* (*th_6Vector_clear)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_clear);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_clear(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::clear", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::clear");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_contains(ActRec* ar) {
  bool (*th_6Vector_contains)(c_Vector*,TypedValue*) =
    (bool (*)(c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_contains);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_6Vector_contains((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("Vector::contains", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::contains");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_containsKey(ActRec* ar) {
  bool (*th_6Vector_containsKey)(c_Vector*,TypedValue*) =
    (bool (*)(c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_containskey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_6Vector_containsKey((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("Vector::containsKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::containsKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_removeKey(ActRec* ar) {
  Value* (*th_6Vector_removeKey)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_removekey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_removeKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::removeKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::removeKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_append(ActRec* ar) {
  Value* (*th_6Vector_append)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_append);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_append(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::append", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::append");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_add(ActRec* ar) {
  Value* (*th_6Vector_add)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_add);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_add(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::add", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::add");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_addAll(ActRec* ar) {
  Value* (*th_6Vector_addAll)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_addall);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_addAll(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::addAll", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::addAll");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_addAllKeysOf(ActRec* ar) {
  Value* (*th_6Vector_addAllKeysOf)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_addallkeysof);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_addAllKeysOf(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::addAllKeysOf", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::addAllKeysOf");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_pop(ActRec* ar) {
  TypedValue* (*th_6Vector_pop)(TypedValue*,c_Vector*) =
    (TypedValue* (*)(TypedValue*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_pop);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6Vector_pop(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::pop", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::pop");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_resize(ActRec* ar) {
  void (*th_6Vector_resize)(c_Vector*,TypedValue*,TypedValue*) =
    (void (*)(c_Vector*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_resize);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      rv->m_type = KindOfNull;
      th_6Vector_resize((this_), (args-0), (args-1));
    } else {
      throw_wrong_arguments_nr("Vector::resize", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::resize");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_reserve(ActRec* ar) {
  void (*th_6Vector_reserve)(c_Vector*,TypedValue*) =
    (void (*)(c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_reserve);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfNull;
      th_6Vector_reserve((this_), (args-0));
    } else {
      throw_wrong_arguments_nr("Vector::reserve", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::reserve");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_toArray(ActRec* ar) {
  Value* (*th_6Vector_toArray)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_toarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_6Vector_toArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::toArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::toArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_toVector(ActRec* ar) {
  Value* (*th_6Vector_toVector)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_tovector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_toVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::toVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::toVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_toImmVector(ActRec* ar) {
  Value* (*th_6Vector_toImmVector)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_toimmvector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_toImmVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::toImmVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::toImmVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_immutable(ActRec* ar) {
  Value* (*th_6Vector_immutable)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_immutable);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_immutable(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::immutable", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::immutable");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_toMap(ActRec* ar) {
  Value* (*th_6Vector_toMap)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_tomap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_toMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::toMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::toMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_toImmMap(ActRec* ar) {
  Value* (*th_6Vector_toImmMap)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_toimmmap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_toImmMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::toImmMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::toImmMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_toSet(ActRec* ar) {
  Value* (*th_6Vector_toSet)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_toset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_toSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::toSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::toSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_toImmSet(ActRec* ar) {
  Value* (*th_6Vector_toImmSet)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_toimmset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_toImmSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::toImmSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::toImmSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_toKeysArray(ActRec* ar) {
  Value* (*th_6Vector_toKeysArray)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_tokeysarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_6Vector_toKeysArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::toKeysArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::toKeysArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_toValuesArray(ActRec* ar) {
  Value* (*th_6Vector_toValuesArray)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_tovaluesarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_6Vector_toValuesArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::toValuesArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::toValuesArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_getIterator(ActRec* ar) {
  Value* (*th_6Vector_getIterator)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_getiterator);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6Vector_getIterator(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::getIterator", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::getIterator");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_map(ActRec* ar) {
  Value* (*th_6Vector_map)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_map);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_map(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::map", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::map");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_mapWithKey(ActRec* ar) {
  Value* (*th_6Vector_mapWithKey)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_mapwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_mapWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::mapWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::mapWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_filter(ActRec* ar) {
  Value* (*th_6Vector_filter)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_filter);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_filter(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::filter", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::filter");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_filterWithKey(ActRec* ar) {
  Value* (*th_6Vector_filterWithKey)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_filterwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_filterWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::filterWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::filterWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_zip(ActRec* ar) {
  Value* (*th_6Vector_zip)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_zip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_zip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::zip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::zip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_take(ActRec* ar) {
  Value* (*th_6Vector_take)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_take);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_take(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::take", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::take");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_takeWhile(ActRec* ar) {
  Value* (*th_6Vector_takeWhile)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_takewhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_takeWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::takeWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::takeWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_skip(ActRec* ar) {
  Value* (*th_6Vector_skip)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_skip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_skip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::skip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::skip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_skipWhile(ActRec* ar) {
  Value* (*th_6Vector_skipWhile)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_skipwhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_skipWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::skipWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::skipWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_slice(ActRec* ar) {
  Value* (*th_6Vector_slice)(Value*,c_Vector*,TypedValue*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_slice);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      rv->m_type = KindOfObject;
      th_6Vector_slice(&(rv->m_data), (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::slice", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::slice");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_concat(ActRec* ar) {
  Value* (*th_6Vector_concat)(Value*,c_Vector*,TypedValue*) =
    (Value* (*)(Value*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_concat);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6Vector_concat(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::concat", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::concat");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_firstValue(ActRec* ar) {
  TypedValue* (*th_6Vector_firstValue)(TypedValue*,c_Vector*) =
    (TypedValue* (*)(TypedValue*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_firstvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6Vector_firstValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::firstValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::firstValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_firstKey(ActRec* ar) {
  TypedValue* (*th_6Vector_firstKey)(TypedValue*,c_Vector*) =
    (TypedValue* (*)(TypedValue*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_firstkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6Vector_firstKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::firstKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::firstKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_lastValue(ActRec* ar) {
  TypedValue* (*th_6Vector_lastValue)(TypedValue*,c_Vector*) =
    (TypedValue* (*)(TypedValue*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_lastvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6Vector_lastValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::lastValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::lastValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_lastKey(ActRec* ar) {
  TypedValue* (*th_6Vector_lastKey)(TypedValue*,c_Vector*) =
    (TypedValue* (*)(TypedValue*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t_lastkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6Vector_lastKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::lastKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::lastKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_reverse(ActRec* ar) {
  void (*th_6Vector_reverse)(c_Vector*) =
    (void (*)(c_Vector*))getMethodPtr(&HPHP::c_Vector::t_reverse);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfNull;
      th_6Vector_reverse((this_));
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::reverse", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::reverse");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_splice(ActRec* ar) {
  void (*th_6Vector_splice)(c_Vector*,TypedValue*,TypedValue*,TypedValue*) =
    (void (*)(c_Vector*,TypedValue*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_splice);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count >= 1 && count <= 3)) {
      rv->m_type = KindOfNull;
      th_6Vector_splice((this_), (args-0), (count > 1) ? (args-1) : (TypedValue*)(&null_variant), (count > 2) ? (args-2) : (TypedValue*)(&null_variant));
    } else {
      throw_wrong_arguments_nr("Vector::splice", count, 1, 3, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::splice");
  }
  frame_free_locals_inl(ar, 3, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_linearSearch(ActRec* ar) {
  int64_t (*th_6Vector_linearSearch)(c_Vector*,TypedValue*) =
    (int64_t (*)(c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t_linearsearch);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfInt64;
      rv->m_data.num = (int64_t)th_6Vector_linearSearch((this_), (args-0));
    } else {
      throw_wrong_arguments_nr("Vector::linearSearch", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::linearSearch");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_shuffle(ActRec* ar) {
  void (*th_6Vector_shuffle)(c_Vector*) =
    (void (*)(c_Vector*))getMethodPtr(&HPHP::c_Vector::t_shuffle);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfNull;
      th_6Vector_shuffle((this_));
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::shuffle", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::shuffle");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector___toString(ActRec* ar) {
  Value* (*th_6Vector___toString)(Value*,c_Vector*) =
    (Value* (*)(Value*,c_Vector*))getMethodPtr(&HPHP::c_Vector::t___tostring);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfString;
      th_6Vector___toString(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Vector::__toString", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::__toString");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector___get(ActRec* ar) {
  TypedValue* (*th_6Vector___get)(TypedValue*,c_Vector*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t___get);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_6Vector___get(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::__get", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::__get");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector___set(ActRec* ar) {
  TypedValue* (*th_6Vector___set)(TypedValue*,c_Vector*,TypedValue*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Vector*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t___set);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      th_6Vector___set(rv, (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::__set", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::__set");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector___isset(ActRec* ar) {
  bool (*th_6Vector___isset)(c_Vector*,TypedValue*) =
    (bool (*)(c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t___isset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_6Vector___isset((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("Vector::__isset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::__isset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector___unset(ActRec* ar) {
  TypedValue* (*th_6Vector___unset)(TypedValue*,c_Vector*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Vector*,TypedValue*))getMethodPtr(&HPHP::c_Vector::t___unset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Vector* this_ = (ar->hasThis() ? static_cast<c_Vector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_6Vector___unset(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Vector::__unset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Vector::__unset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_fromItems(ActRec* ar) {
  Value* (*th_6Vector_fromItems)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_Vector::ti_fromitems);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_6Vector_fromItems(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("Vector::fromItems", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_fromKeysOf(ActRec* ar) {
  Value* (*th_6Vector_fromKeysOf)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_Vector::ti_fromkeysof);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_6Vector_fromKeysOf(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("Vector::fromKeysOf", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6Vector_fromArray(ActRec* ar) {
  Value* (*th_6Vector_fromArray)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_Vector::ti_fromarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_6Vector_fromArray(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("Vector::fromArray", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}


ObjectData* new_ImmVector_Instance(HPHP::Class* cls) {
  size_t nProps = cls->numDeclProperties();
  size_t builtinObjSize = sizeof(c_ImmVector) - sizeof(ObjectData);
  size_t size = ObjectData::sizeForNProps(nProps) + builtinObjSize;
  auto o = new (MM().objMalloc(size)) c_ImmVector(cls);
  assert(o->hasExactlyOneRef());
  return o;
}


void delete_ImmVector(ObjectData* obj, const Class* cls) {
  auto const ptr = static_cast<c_ImmVector*>(obj);
  ptr->~c_ImmVector();

  auto const nProps = cls->numDeclProperties();
  auto const propVec = reinterpret_cast<TypedValue*>(ptr + 1);
  for (auto i = Slot{0}; i < nProps; ++i) {
    tvRefcountedDecRef(&propVec[i]);
  }

  auto const builtinSz = sizeof(c_ImmVector) - sizeof(ObjectData);
  auto const size = ObjectData::sizeForNProps(nProps) + builtinSz;
  if (LIKELY(size <= kMaxSmallSize)) {
    return MM().freeSmallSize(ptr, size);
  }
  return MM().freeBigSize(ptr, size);
}

IMPLEMENT_CLASS_NO_SWEEP(ImmVector);
TypedValue* tg_9ImmVector___construct(ActRec* ar) {
  void (*th_9ImmVector___construct)(c_ImmVector*,TypedValue*) =
    (void (*)(c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t___construct);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count <= 1)) {
      rv->m_type = KindOfNull;
      th_9ImmVector___construct((this_), (count > 0) ? (args-0) : (TypedValue*)(&null_variant));
    } else {
      throw_toomany_arguments_nr("ImmVector::__construct", 1, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::__construct");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_fromItems(ActRec* ar) {
  Value* (*th_9ImmVector_fromItems)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::ti_fromitems);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_9ImmVector_fromItems(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("ImmVector::fromItems", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_fromKeysOf(ActRec* ar) {
  Value* (*th_9ImmVector_fromKeysOf)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::ti_fromkeysof);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_9ImmVector_fromKeysOf(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("ImmVector::fromKeysOf", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_isEmpty(ActRec* ar) {
  bool (*th_9ImmVector_isEmpty)(c_ImmVector*) =
    (bool (*)(c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_isempty);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_9ImmVector_isEmpty((this_))) ? 1LL : 0LL;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::isEmpty", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::isEmpty");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_count(ActRec* ar) {
  int64_t (*th_9ImmVector_count)(c_ImmVector*) =
    (int64_t (*)(c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_count);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfInt64;
      rv->m_data.num = (int64_t)th_9ImmVector_count((this_));
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::count", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::count");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_items(ActRec* ar) {
  Value* (*th_9ImmVector_items)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_items);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_items(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::items", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::items");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_containsKey(ActRec* ar) {
  bool (*th_9ImmVector_containsKey)(c_ImmVector*,TypedValue*) =
    (bool (*)(c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_containskey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_9ImmVector_containsKey((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("ImmVector::containsKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::containsKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_at(ActRec* ar) {
  TypedValue* (*th_9ImmVector_at)(TypedValue*,c_ImmVector*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_at);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_9ImmVector_at(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::at", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::at");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_get(ActRec* ar) {
  TypedValue* (*th_9ImmVector_get)(TypedValue*,c_ImmVector*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_get);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_9ImmVector_get(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::get", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::get");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_getIterator(ActRec* ar) {
  Value* (*th_9ImmVector_getIterator)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_getiterator);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_getIterator(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::getIterator", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::getIterator");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_map(ActRec* ar) {
  Value* (*th_9ImmVector_map)(Value*,c_ImmVector*,TypedValue*) =
    (Value* (*)(Value*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_map);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_map(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::map", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::map");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_mapWithKey(ActRec* ar) {
  Value* (*th_9ImmVector_mapWithKey)(Value*,c_ImmVector*,TypedValue*) =
    (Value* (*)(Value*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_mapwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_mapWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::mapWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::mapWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_filter(ActRec* ar) {
  Value* (*th_9ImmVector_filter)(Value*,c_ImmVector*,TypedValue*) =
    (Value* (*)(Value*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_filter);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_filter(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::filter", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::filter");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_filterWithKey(ActRec* ar) {
  Value* (*th_9ImmVector_filterWithKey)(Value*,c_ImmVector*,TypedValue*) =
    (Value* (*)(Value*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_filterwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_filterWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::filterWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::filterWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_zip(ActRec* ar) {
  Value* (*th_9ImmVector_zip)(Value*,c_ImmVector*,TypedValue*) =
    (Value* (*)(Value*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_zip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_zip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::zip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::zip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_take(ActRec* ar) {
  Value* (*th_9ImmVector_take)(Value*,c_ImmVector*,TypedValue*) =
    (Value* (*)(Value*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_take);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_take(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::take", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::take");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_takeWhile(ActRec* ar) {
  Value* (*th_9ImmVector_takeWhile)(Value*,c_ImmVector*,TypedValue*) =
    (Value* (*)(Value*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_takewhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_takeWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::takeWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::takeWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_skip(ActRec* ar) {
  Value* (*th_9ImmVector_skip)(Value*,c_ImmVector*,TypedValue*) =
    (Value* (*)(Value*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_skip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_skip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::skip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::skip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_skipWhile(ActRec* ar) {
  Value* (*th_9ImmVector_skipWhile)(Value*,c_ImmVector*,TypedValue*) =
    (Value* (*)(Value*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_skipwhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_skipWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::skipWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::skipWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_slice(ActRec* ar) {
  Value* (*th_9ImmVector_slice)(Value*,c_ImmVector*,TypedValue*,TypedValue*) =
    (Value* (*)(Value*,c_ImmVector*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_slice);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_slice(&(rv->m_data), (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::slice", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::slice");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_concat(ActRec* ar) {
  Value* (*th_9ImmVector_concat)(Value*,c_ImmVector*,TypedValue*) =
    (Value* (*)(Value*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_concat);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_concat(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::concat", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::concat");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_firstValue(ActRec* ar) {
  TypedValue* (*th_9ImmVector_firstValue)(TypedValue*,c_ImmVector*) =
    (TypedValue* (*)(TypedValue*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_firstvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_9ImmVector_firstValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::firstValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::firstValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_firstKey(ActRec* ar) {
  TypedValue* (*th_9ImmVector_firstKey)(TypedValue*,c_ImmVector*) =
    (TypedValue* (*)(TypedValue*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_firstkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_9ImmVector_firstKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::firstKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::firstKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_lastValue(ActRec* ar) {
  TypedValue* (*th_9ImmVector_lastValue)(TypedValue*,c_ImmVector*) =
    (TypedValue* (*)(TypedValue*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_lastvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_9ImmVector_lastValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::lastValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::lastValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_lastKey(ActRec* ar) {
  TypedValue* (*th_9ImmVector_lastKey)(TypedValue*,c_ImmVector*) =
    (TypedValue* (*)(TypedValue*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_lastkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_9ImmVector_lastKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::lastKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::lastKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_keys(ActRec* ar) {
  Value* (*th_9ImmVector_keys)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_keys);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_keys(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::keys", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::keys");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector___toString(ActRec* ar) {
  Value* (*th_9ImmVector___toString)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t___tostring);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfString;
      th_9ImmVector___toString(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::__toString", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::__toString");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector___get(ActRec* ar) {
  TypedValue* (*th_9ImmVector___get)(TypedValue*,c_ImmVector*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t___get);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_9ImmVector___get(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::__get", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::__get");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector___set(ActRec* ar) {
  TypedValue* (*th_9ImmVector___set)(TypedValue*,c_ImmVector*,TypedValue*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmVector*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t___set);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      th_9ImmVector___set(rv, (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::__set", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::__set");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector___isset(ActRec* ar) {
  bool (*th_9ImmVector___isset)(c_ImmVector*,TypedValue*) =
    (bool (*)(c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t___isset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_9ImmVector___isset((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("ImmVector::__isset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::__isset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector___unset(ActRec* ar) {
  TypedValue* (*th_9ImmVector___unset)(TypedValue*,c_ImmVector*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t___unset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_9ImmVector___unset(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmVector::__unset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::__unset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_toVector(ActRec* ar) {
  Value* (*th_9ImmVector_toVector)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_tovector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_toVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::toVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::toVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_toImmVector(ActRec* ar) {
  Value* (*th_9ImmVector_toImmVector)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_toimmvector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_toImmVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::toImmVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::toImmVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_toMap(ActRec* ar) {
  Value* (*th_9ImmVector_toMap)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_tomap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_toMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::toMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::toMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_toImmMap(ActRec* ar) {
  Value* (*th_9ImmVector_toImmMap)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_toimmmap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_toImmMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::toImmMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::toImmMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_toSet(ActRec* ar) {
  Value* (*th_9ImmVector_toSet)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_toset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_toSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::toSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::toSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_toImmSet(ActRec* ar) {
  Value* (*th_9ImmVector_toImmSet)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_toimmset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_toImmSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::toImmSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::toImmSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_immutable(ActRec* ar) {
  Value* (*th_9ImmVector_immutable)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_immutable);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_immutable(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::immutable", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::immutable");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_values(ActRec* ar) {
  Value* (*th_9ImmVector_values)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_values);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_values(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::values", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::values");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_lazy(ActRec* ar) {
  Value* (*th_9ImmVector_lazy)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_lazy);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_9ImmVector_lazy(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::lazy", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::lazy");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_toArray(ActRec* ar) {
  Value* (*th_9ImmVector_toArray)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_toarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_9ImmVector_toArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::toArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::toArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_toKeysArray(ActRec* ar) {
  Value* (*th_9ImmVector_toKeysArray)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_tokeysarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_9ImmVector_toKeysArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::toKeysArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::toKeysArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_toValuesArray(ActRec* ar) {
  Value* (*th_9ImmVector_toValuesArray)(Value*,c_ImmVector*) =
    (Value* (*)(Value*,c_ImmVector*))getMethodPtr(&HPHP::c_ImmVector::t_tovaluesarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_9ImmVector_toValuesArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmVector::toValuesArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::toValuesArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_9ImmVector_linearSearch(ActRec* ar) {
  int64_t (*th_9ImmVector_linearSearch)(c_ImmVector*,TypedValue*) =
    (int64_t (*)(c_ImmVector*,TypedValue*))getMethodPtr(&HPHP::c_ImmVector::t_linearsearch);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmVector* this_ = (ar->hasThis() ? static_cast<c_ImmVector*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfInt64;
      rv->m_data.num = (int64_t)th_9ImmVector_linearSearch((this_), (args-0));
    } else {
      throw_wrong_arguments_nr("ImmVector::linearSearch", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmVector::linearSearch");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}


ObjectData* new_Map_Instance(HPHP::Class* cls) {
  size_t nProps = cls->numDeclProperties();
  size_t builtinObjSize = sizeof(c_Map) - sizeof(ObjectData);
  size_t size = ObjectData::sizeForNProps(nProps) + builtinObjSize;
  auto o = new (MM().objMalloc(size)) c_Map(cls);
  assert(o->hasExactlyOneRef());
  return o;
}


void delete_Map(ObjectData* obj, const Class* cls) {
  auto const ptr = static_cast<c_Map*>(obj);
  ptr->~c_Map();

  auto const nProps = cls->numDeclProperties();
  auto const propVec = reinterpret_cast<TypedValue*>(ptr + 1);
  for (auto i = Slot{0}; i < nProps; ++i) {
    tvRefcountedDecRef(&propVec[i]);
  }

  auto const builtinSz = sizeof(c_Map) - sizeof(ObjectData);
  auto const size = ObjectData::sizeForNProps(nProps) + builtinSz;
  if (LIKELY(size <= kMaxSmallSize)) {
    return MM().freeSmallSize(ptr, size);
  }
  return MM().freeBigSize(ptr, size);
}

IMPLEMENT_CLASS_NO_SWEEP(Map);
TypedValue* tg_3Map___construct(ActRec* ar) {
  void (*th_3Map___construct)(c_Map*,TypedValue*) =
    (void (*)(c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t___construct);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count <= 1)) {
      rv->m_type = KindOfNull;
      th_3Map___construct((this_), (count > 0) ? (args-0) : (TypedValue*)(&null_variant));
    } else {
      throw_toomany_arguments_nr("Map::__construct", 1, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::__construct");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_isEmpty(ActRec* ar) {
  bool (*th_3Map_isEmpty)(c_Map*) =
    (bool (*)(c_Map*))getMethodPtr(&HPHP::c_Map::t_isempty);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_3Map_isEmpty((this_))) ? 1LL : 0LL;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::isEmpty", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::isEmpty");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_count(ActRec* ar) {
  int64_t (*th_3Map_count)(c_Map*) =
    (int64_t (*)(c_Map*))getMethodPtr(&HPHP::c_Map::t_count);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfInt64;
      rv->m_data.num = (int64_t)th_3Map_count((this_));
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::count", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::count");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_items(ActRec* ar) {
  Value* (*th_3Map_items)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_items);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_items(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::items", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::items");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_keys(ActRec* ar) {
  Value* (*th_3Map_keys)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_keys);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_keys(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::keys", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::keys");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_lazy(ActRec* ar) {
  Value* (*th_3Map_lazy)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_lazy);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_lazy(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::lazy", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::lazy");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_at(ActRec* ar) {
  TypedValue* (*th_3Map_at)(TypedValue*,c_Map*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_at);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_3Map_at(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::at", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::at");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_get(ActRec* ar) {
  TypedValue* (*th_3Map_get)(TypedValue*,c_Map*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_get);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_3Map_get(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::get", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::get");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_set(ActRec* ar) {
  Value* (*th_3Map_set)(Value*,c_Map*,TypedValue*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_set);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      rv->m_type = KindOfObject;
      th_3Map_set(&(rv->m_data), (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::set", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::set");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_setAll(ActRec* ar) {
  Value* (*th_3Map_setAll)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_setall);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_setAll(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::setAll", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::setAll");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_clear(ActRec* ar) {
  Value* (*th_3Map_clear)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_clear);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_clear(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::clear", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::clear");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_contains(ActRec* ar) {
  bool (*th_3Map_contains)(c_Map*,TypedValue*) =
    (bool (*)(c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_contains);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_3Map_contains((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("Map::contains", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::contains");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_containsKey(ActRec* ar) {
  bool (*th_3Map_containsKey)(c_Map*,TypedValue*) =
    (bool (*)(c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_containskey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_3Map_containsKey((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("Map::containsKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::containsKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_remove(ActRec* ar) {
  Value* (*th_3Map_remove)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_remove);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_remove(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::remove", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::remove");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_removeKey(ActRec* ar) {
  Value* (*th_3Map_removeKey)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_removekey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_removeKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::removeKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::removeKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_add(ActRec* ar) {
  Value* (*th_3Map_add)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_add);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_add(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::add", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::add");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_addAll(ActRec* ar) {
  Value* (*th_3Map_addAll)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_addall);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_addAll(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::addAll", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::addAll");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_reserve(ActRec* ar) {
  void (*th_3Map_reserve)(c_Map*,TypedValue*) =
    (void (*)(c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_reserve);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfNull;
      th_3Map_reserve((this_), (args-0));
    } else {
      throw_wrong_arguments_nr("Map::reserve", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::reserve");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_toArray(ActRec* ar) {
  Value* (*th_3Map_toArray)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_toarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_3Map_toArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::toArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::toArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_toVector(ActRec* ar) {
  Value* (*th_3Map_toVector)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_tovector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_toVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::toVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::toVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_toImmVector(ActRec* ar) {
  Value* (*th_3Map_toImmVector)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_toimmvector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_toImmVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::toImmVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::toImmVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_toMap(ActRec* ar) {
  Value* (*th_3Map_toMap)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_tomap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_toMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::toMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::toMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_toImmMap(ActRec* ar) {
  Value* (*th_3Map_toImmMap)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_toimmmap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_toImmMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::toImmMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::toImmMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_toSet(ActRec* ar) {
  Value* (*th_3Map_toSet)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_toset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_toSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::toSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::toSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_toImmSet(ActRec* ar) {
  Value* (*th_3Map_toImmSet)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_toimmset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_toImmSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::toImmSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::toImmSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_immutable(ActRec* ar) {
  Value* (*th_3Map_immutable)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_immutable);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_immutable(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::immutable", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::immutable");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_values(ActRec* ar) {
  Value* (*th_3Map_values)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_values);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_values(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::values", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::values");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_toKeysArray(ActRec* ar) {
  Value* (*th_3Map_toKeysArray)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_tokeysarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_3Map_toKeysArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::toKeysArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::toKeysArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_toValuesArray(ActRec* ar) {
  Value* (*th_3Map_toValuesArray)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_tovaluesarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_3Map_toValuesArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::toValuesArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::toValuesArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_differenceByKey(ActRec* ar) {
  Value* (*th_3Map_differenceByKey)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_differencebykey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_differenceByKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::differenceByKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::differenceByKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_getIterator(ActRec* ar) {
  Value* (*th_3Map_getIterator)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t_getiterator);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Map_getIterator(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::getIterator", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::getIterator");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_map(ActRec* ar) {
  Value* (*th_3Map_map)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_map);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_map(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::map", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::map");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_mapWithKey(ActRec* ar) {
  Value* (*th_3Map_mapWithKey)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_mapwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_mapWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::mapWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::mapWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_filter(ActRec* ar) {
  Value* (*th_3Map_filter)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_filter);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_filter(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::filter", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::filter");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_filterWithKey(ActRec* ar) {
  Value* (*th_3Map_filterWithKey)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_filterwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_filterWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::filterWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::filterWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_retain(ActRec* ar) {
  Value* (*th_3Map_retain)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_retain);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_retain(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::retain", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::retain");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_retainWithKey(ActRec* ar) {
  Value* (*th_3Map_retainWithKey)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_retainwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_retainWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::retainWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::retainWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_zip(ActRec* ar) {
  Value* (*th_3Map_zip)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_zip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_zip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::zip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::zip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_take(ActRec* ar) {
  Value* (*th_3Map_take)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_take);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_take(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::take", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::take");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_takeWhile(ActRec* ar) {
  Value* (*th_3Map_takeWhile)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_takewhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_takeWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::takeWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::takeWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_skip(ActRec* ar) {
  Value* (*th_3Map_skip)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_skip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_skip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::skip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::skip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_skipWhile(ActRec* ar) {
  Value* (*th_3Map_skipWhile)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_skipwhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_skipWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::skipWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::skipWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_slice(ActRec* ar) {
  Value* (*th_3Map_slice)(Value*,c_Map*,TypedValue*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_slice);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      rv->m_type = KindOfObject;
      th_3Map_slice(&(rv->m_data), (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::slice", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::slice");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_concat(ActRec* ar) {
  Value* (*th_3Map_concat)(Value*,c_Map*,TypedValue*) =
    (Value* (*)(Value*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t_concat);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Map_concat(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::concat", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::concat");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_firstValue(ActRec* ar) {
  TypedValue* (*th_3Map_firstValue)(TypedValue*,c_Map*) =
    (TypedValue* (*)(TypedValue*,c_Map*))getMethodPtr(&HPHP::c_Map::t_firstvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_3Map_firstValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::firstValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::firstValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_firstKey(ActRec* ar) {
  TypedValue* (*th_3Map_firstKey)(TypedValue*,c_Map*) =
    (TypedValue* (*)(TypedValue*,c_Map*))getMethodPtr(&HPHP::c_Map::t_firstkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_3Map_firstKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::firstKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::firstKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_lastValue(ActRec* ar) {
  TypedValue* (*th_3Map_lastValue)(TypedValue*,c_Map*) =
    (TypedValue* (*)(TypedValue*,c_Map*))getMethodPtr(&HPHP::c_Map::t_lastvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_3Map_lastValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::lastValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::lastValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_lastKey(ActRec* ar) {
  TypedValue* (*th_3Map_lastKey)(TypedValue*,c_Map*) =
    (TypedValue* (*)(TypedValue*,c_Map*))getMethodPtr(&HPHP::c_Map::t_lastkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_3Map_lastKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::lastKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::lastKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map___toString(ActRec* ar) {
  Value* (*th_3Map___toString)(Value*,c_Map*) =
    (Value* (*)(Value*,c_Map*))getMethodPtr(&HPHP::c_Map::t___tostring);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfString;
      th_3Map___toString(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Map::__toString", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::__toString");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map___get(ActRec* ar) {
  TypedValue* (*th_3Map___get)(TypedValue*,c_Map*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t___get);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_3Map___get(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::__get", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::__get");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map___set(ActRec* ar) {
  TypedValue* (*th_3Map___set)(TypedValue*,c_Map*,TypedValue*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Map*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_Map::t___set);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      th_3Map___set(rv, (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::__set", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::__set");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map___isset(ActRec* ar) {
  bool (*th_3Map___isset)(c_Map*,TypedValue*) =
    (bool (*)(c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t___isset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_3Map___isset((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("Map::__isset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::__isset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map___unset(ActRec* ar) {
  TypedValue* (*th_3Map___unset)(TypedValue*,c_Map*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Map*,TypedValue*))getMethodPtr(&HPHP::c_Map::t___unset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Map* this_ = (ar->hasThis() ? static_cast<c_Map*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_3Map___unset(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Map::__unset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Map::__unset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_fromItems(ActRec* ar) {
  Value* (*th_3Map_fromItems)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_Map::ti_fromitems);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_3Map_fromItems(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("Map::fromItems", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Map_fromArray(ActRec* ar) {
  Value* (*th_3Map_fromArray)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_Map::ti_fromarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_3Map_fromArray(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("Map::fromArray", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}


ObjectData* new_ImmMap_Instance(HPHP::Class* cls) {
  size_t nProps = cls->numDeclProperties();
  size_t builtinObjSize = sizeof(c_ImmMap) - sizeof(ObjectData);
  size_t size = ObjectData::sizeForNProps(nProps) + builtinObjSize;
  auto o = new (MM().objMalloc(size)) c_ImmMap(cls);
  assert(o->hasExactlyOneRef());
  return o;
}


void delete_ImmMap(ObjectData* obj, const Class* cls) {
  auto const ptr = static_cast<c_ImmMap*>(obj);
  ptr->~c_ImmMap();

  auto const nProps = cls->numDeclProperties();
  auto const propVec = reinterpret_cast<TypedValue*>(ptr + 1);
  for (auto i = Slot{0}; i < nProps; ++i) {
    tvRefcountedDecRef(&propVec[i]);
  }

  auto const builtinSz = sizeof(c_ImmMap) - sizeof(ObjectData);
  auto const size = ObjectData::sizeForNProps(nProps) + builtinSz;
  if (LIKELY(size <= kMaxSmallSize)) {
    return MM().freeSmallSize(ptr, size);
  }
  return MM().freeBigSize(ptr, size);
}

IMPLEMENT_CLASS_NO_SWEEP(ImmMap);
TypedValue* tg_6ImmMap___construct(ActRec* ar) {
  void (*th_6ImmMap___construct)(c_ImmMap*,TypedValue*) =
    (void (*)(c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t___construct);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count <= 1)) {
      rv->m_type = KindOfNull;
      th_6ImmMap___construct((this_), (count > 0) ? (args-0) : (TypedValue*)(&null_variant));
    } else {
      throw_toomany_arguments_nr("ImmMap::__construct", 1, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::__construct");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_isEmpty(ActRec* ar) {
  bool (*th_6ImmMap_isEmpty)(c_ImmMap*) =
    (bool (*)(c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_isempty);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_6ImmMap_isEmpty((this_))) ? 1LL : 0LL;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::isEmpty", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::isEmpty");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_count(ActRec* ar) {
  int64_t (*th_6ImmMap_count)(c_ImmMap*) =
    (int64_t (*)(c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_count);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfInt64;
      rv->m_data.num = (int64_t)th_6ImmMap_count((this_));
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::count", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::count");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_items(ActRec* ar) {
  Value* (*th_6ImmMap_items)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_items);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_items(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::items", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::items");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_keys(ActRec* ar) {
  Value* (*th_6ImmMap_keys)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_keys);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_keys(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::keys", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::keys");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_lazy(ActRec* ar) {
  Value* (*th_6ImmMap_lazy)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_lazy);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_lazy(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::lazy", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::lazy");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_at(ActRec* ar) {
  TypedValue* (*th_6ImmMap_at)(TypedValue*,c_ImmMap*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_at);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_6ImmMap_at(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::at", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::at");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_get(ActRec* ar) {
  TypedValue* (*th_6ImmMap_get)(TypedValue*,c_ImmMap*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_get);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_6ImmMap_get(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::get", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::get");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_contains(ActRec* ar) {
  bool (*th_6ImmMap_contains)(c_ImmMap*,TypedValue*) =
    (bool (*)(c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_contains);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_6ImmMap_contains((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("ImmMap::contains", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::contains");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_containsKey(ActRec* ar) {
  bool (*th_6ImmMap_containsKey)(c_ImmMap*,TypedValue*) =
    (bool (*)(c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_containskey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_6ImmMap_containsKey((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("ImmMap::containsKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::containsKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_toArray(ActRec* ar) {
  Value* (*th_6ImmMap_toArray)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_toarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_6ImmMap_toArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::toArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::toArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_toVector(ActRec* ar) {
  Value* (*th_6ImmMap_toVector)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_tovector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_toVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::toVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::toVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_toImmVector(ActRec* ar) {
  Value* (*th_6ImmMap_toImmVector)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_toimmvector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_toImmVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::toImmVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::toImmVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_toMap(ActRec* ar) {
  Value* (*th_6ImmMap_toMap)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_tomap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_toMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::toMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::toMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_toImmMap(ActRec* ar) {
  Value* (*th_6ImmMap_toImmMap)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_toimmmap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_toImmMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::toImmMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::toImmMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_toSet(ActRec* ar) {
  Value* (*th_6ImmMap_toSet)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_toset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_toSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::toSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::toSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_toImmSet(ActRec* ar) {
  Value* (*th_6ImmMap_toImmSet)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_toimmset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_toImmSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::toImmSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::toImmSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_immutable(ActRec* ar) {
  Value* (*th_6ImmMap_immutable)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_immutable);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_immutable(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::immutable", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::immutable");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_values(ActRec* ar) {
  Value* (*th_6ImmMap_values)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_values);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_values(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::values", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::values");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_toKeysArray(ActRec* ar) {
  Value* (*th_6ImmMap_toKeysArray)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_tokeysarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_6ImmMap_toKeysArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::toKeysArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::toKeysArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_toValuesArray(ActRec* ar) {
  Value* (*th_6ImmMap_toValuesArray)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_tovaluesarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_6ImmMap_toValuesArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::toValuesArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::toValuesArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_differenceByKey(ActRec* ar) {
  Value* (*th_6ImmMap_differenceByKey)(Value*,c_ImmMap*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_differencebykey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_differenceByKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::differenceByKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::differenceByKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_getIterator(ActRec* ar) {
  Value* (*th_6ImmMap_getIterator)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_getiterator);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_getIterator(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::getIterator", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::getIterator");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_map(ActRec* ar) {
  Value* (*th_6ImmMap_map)(Value*,c_ImmMap*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_map);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_map(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::map", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::map");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_mapWithKey(ActRec* ar) {
  Value* (*th_6ImmMap_mapWithKey)(Value*,c_ImmMap*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_mapwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_mapWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::mapWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::mapWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_filter(ActRec* ar) {
  Value* (*th_6ImmMap_filter)(Value*,c_ImmMap*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_filter);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_filter(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::filter", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::filter");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_filterWithKey(ActRec* ar) {
  Value* (*th_6ImmMap_filterWithKey)(Value*,c_ImmMap*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_filterwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_filterWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::filterWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::filterWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_zip(ActRec* ar) {
  Value* (*th_6ImmMap_zip)(Value*,c_ImmMap*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_zip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_zip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::zip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::zip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_take(ActRec* ar) {
  Value* (*th_6ImmMap_take)(Value*,c_ImmMap*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_take);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_take(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::take", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::take");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_takeWhile(ActRec* ar) {
  Value* (*th_6ImmMap_takeWhile)(Value*,c_ImmMap*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_takewhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_takeWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::takeWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::takeWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_skip(ActRec* ar) {
  Value* (*th_6ImmMap_skip)(Value*,c_ImmMap*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_skip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_skip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::skip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::skip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_skipWhile(ActRec* ar) {
  Value* (*th_6ImmMap_skipWhile)(Value*,c_ImmMap*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_skipwhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_skipWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::skipWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::skipWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_slice(ActRec* ar) {
  Value* (*th_6ImmMap_slice)(Value*,c_ImmMap*,TypedValue*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_slice);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_slice(&(rv->m_data), (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::slice", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::slice");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_concat(ActRec* ar) {
  Value* (*th_6ImmMap_concat)(Value*,c_ImmMap*,TypedValue*) =
    (Value* (*)(Value*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t_concat);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmMap_concat(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::concat", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::concat");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_firstValue(ActRec* ar) {
  TypedValue* (*th_6ImmMap_firstValue)(TypedValue*,c_ImmMap*) =
    (TypedValue* (*)(TypedValue*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_firstvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6ImmMap_firstValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::firstValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::firstValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_firstKey(ActRec* ar) {
  TypedValue* (*th_6ImmMap_firstKey)(TypedValue*,c_ImmMap*) =
    (TypedValue* (*)(TypedValue*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_firstkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6ImmMap_firstKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::firstKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::firstKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_lastValue(ActRec* ar) {
  TypedValue* (*th_6ImmMap_lastValue)(TypedValue*,c_ImmMap*) =
    (TypedValue* (*)(TypedValue*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_lastvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6ImmMap_lastValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::lastValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::lastValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_lastKey(ActRec* ar) {
  TypedValue* (*th_6ImmMap_lastKey)(TypedValue*,c_ImmMap*) =
    (TypedValue* (*)(TypedValue*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t_lastkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6ImmMap_lastKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::lastKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::lastKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap___toString(ActRec* ar) {
  Value* (*th_6ImmMap___toString)(Value*,c_ImmMap*) =
    (Value* (*)(Value*,c_ImmMap*))getMethodPtr(&HPHP::c_ImmMap::t___tostring);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfString;
      th_6ImmMap___toString(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmMap::__toString", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::__toString");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap___get(ActRec* ar) {
  TypedValue* (*th_6ImmMap___get)(TypedValue*,c_ImmMap*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t___get);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_6ImmMap___get(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::__get", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::__get");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap___set(ActRec* ar) {
  TypedValue* (*th_6ImmMap___set)(TypedValue*,c_ImmMap*,TypedValue*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmMap*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t___set);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      th_6ImmMap___set(rv, (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::__set", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::__set");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap___isset(ActRec* ar) {
  bool (*th_6ImmMap___isset)(c_ImmMap*,TypedValue*) =
    (bool (*)(c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t___isset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_6ImmMap___isset((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("ImmMap::__isset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::__isset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap___unset(ActRec* ar) {
  TypedValue* (*th_6ImmMap___unset)(TypedValue*,c_ImmMap*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmMap*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::t___unset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmMap* this_ = (ar->hasThis() ? static_cast<c_ImmMap*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_6ImmMap___unset(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmMap::__unset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmMap::__unset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmMap_fromItems(ActRec* ar) {
  Value* (*th_6ImmMap_fromItems)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_ImmMap::ti_fromitems);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_6ImmMap_fromItems(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("ImmMap::fromItems", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}


ObjectData* new_Set_Instance(HPHP::Class* cls) {
  size_t nProps = cls->numDeclProperties();
  size_t builtinObjSize = sizeof(c_Set) - sizeof(ObjectData);
  size_t size = ObjectData::sizeForNProps(nProps) + builtinObjSize;
  auto o = new (MM().objMalloc(size)) c_Set(cls);
  assert(o->hasExactlyOneRef());
  return o;
}


void delete_Set(ObjectData* obj, const Class* cls) {
  auto const ptr = static_cast<c_Set*>(obj);
  ptr->~c_Set();

  auto const nProps = cls->numDeclProperties();
  auto const propVec = reinterpret_cast<TypedValue*>(ptr + 1);
  for (auto i = Slot{0}; i < nProps; ++i) {
    tvRefcountedDecRef(&propVec[i]);
  }

  auto const builtinSz = sizeof(c_Set) - sizeof(ObjectData);
  auto const size = ObjectData::sizeForNProps(nProps) + builtinSz;
  if (LIKELY(size <= kMaxSmallSize)) {
    return MM().freeSmallSize(ptr, size);
  }
  return MM().freeBigSize(ptr, size);
}

IMPLEMENT_CLASS_NO_SWEEP(Set);
TypedValue* tg_3Set___construct(ActRec* ar) {
  void (*th_3Set___construct)(c_Set*,TypedValue*) =
    (void (*)(c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t___construct);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count <= 1)) {
      rv->m_type = KindOfNull;
      th_3Set___construct((this_), (count > 0) ? (args-0) : (TypedValue*)(&null_variant));
    } else {
      throw_toomany_arguments_nr("Set::__construct", 1, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::__construct");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_isEmpty(ActRec* ar) {
  bool (*th_3Set_isEmpty)(c_Set*) =
    (bool (*)(c_Set*))getMethodPtr(&HPHP::c_Set::t_isempty);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_3Set_isEmpty((this_))) ? 1LL : 0LL;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::isEmpty", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::isEmpty");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_count(ActRec* ar) {
  int64_t (*th_3Set_count)(c_Set*) =
    (int64_t (*)(c_Set*))getMethodPtr(&HPHP::c_Set::t_count);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfInt64;
      rv->m_data.num = (int64_t)th_3Set_count((this_));
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::count", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::count");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_items(ActRec* ar) {
  Value* (*th_3Set_items)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_items);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_items(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::items", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::items");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_keys(ActRec* ar) {
  Value* (*th_3Set_keys)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_keys);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_keys(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::keys", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::keys");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_values(ActRec* ar) {
  Value* (*th_3Set_values)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_values);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_values(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::values", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::values");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_lazy(ActRec* ar) {
  Value* (*th_3Set_lazy)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_lazy);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_lazy(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::lazy", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::lazy");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_clear(ActRec* ar) {
  Value* (*th_3Set_clear)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_clear);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_clear(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::clear", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::clear");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_contains(ActRec* ar) {
  bool (*th_3Set_contains)(c_Set*,TypedValue*) =
    (bool (*)(c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_contains);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_3Set_contains((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("Set::contains", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::contains");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_remove(ActRec* ar) {
  Value* (*th_3Set_remove)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_remove);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_remove(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::remove", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::remove");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_add(ActRec* ar) {
  Value* (*th_3Set_add)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_add);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_add(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::add", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::add");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_addAll(ActRec* ar) {
  Value* (*th_3Set_addAll)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_addall);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_addAll(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::addAll", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::addAll");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_addAllKeysOf(ActRec* ar) {
  Value* (*th_3Set_addAllKeysOf)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_addallkeysof);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_addAllKeysOf(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::addAllKeysOf", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::addAllKeysOf");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_reserve(ActRec* ar) {
  void (*th_3Set_reserve)(c_Set*,TypedValue*) =
    (void (*)(c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_reserve);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfNull;
      th_3Set_reserve((this_), (args-0));
    } else {
      throw_wrong_arguments_nr("Set::reserve", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::reserve");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_toArray(ActRec* ar) {
  Value* (*th_3Set_toArray)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_toarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_3Set_toArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::toArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::toArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_toVector(ActRec* ar) {
  Value* (*th_3Set_toVector)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_tovector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_toVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::toVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::toVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_toImmVector(ActRec* ar) {
  Value* (*th_3Set_toImmVector)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_toimmvector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_toImmVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::toImmVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::toImmVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_toMap(ActRec* ar) {
  Value* (*th_3Set_toMap)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_tomap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_toMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::toMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::toMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_toImmMap(ActRec* ar) {
  Value* (*th_3Set_toImmMap)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_toimmmap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_toImmMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::toImmMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::toImmMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_toSet(ActRec* ar) {
  Value* (*th_3Set_toSet)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_toset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_toSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::toSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::toSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_toImmSet(ActRec* ar) {
  Value* (*th_3Set_toImmSet)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_toimmset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_toImmSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::toImmSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::toImmSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_immutable(ActRec* ar) {
  Value* (*th_3Set_immutable)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_immutable);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_immutable(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::immutable", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::immutable");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_toKeysArray(ActRec* ar) {
  Value* (*th_3Set_toKeysArray)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_tokeysarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_3Set_toKeysArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::toKeysArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::toKeysArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_toValuesArray(ActRec* ar) {
  Value* (*th_3Set_toValuesArray)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_tovaluesarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_3Set_toValuesArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::toValuesArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::toValuesArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_getIterator(ActRec* ar) {
  Value* (*th_3Set_getIterator)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t_getiterator);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_3Set_getIterator(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::getIterator", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::getIterator");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_map(ActRec* ar) {
  Value* (*th_3Set_map)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_map);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_map(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::map", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::map");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_mapWithKey(ActRec* ar) {
  Value* (*th_3Set_mapWithKey)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_mapwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_mapWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::mapWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::mapWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_filter(ActRec* ar) {
  Value* (*th_3Set_filter)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_filter);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_filter(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::filter", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::filter");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_filterWithKey(ActRec* ar) {
  Value* (*th_3Set_filterWithKey)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_filterwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_filterWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::filterWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::filterWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_retain(ActRec* ar) {
  Value* (*th_3Set_retain)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_retain);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_retain(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::retain", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::retain");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_retainWithKey(ActRec* ar) {
  Value* (*th_3Set_retainWithKey)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_retainwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_retainWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::retainWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::retainWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_zip(ActRec* ar) {
  Value* (*th_3Set_zip)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_zip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_zip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::zip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::zip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_take(ActRec* ar) {
  Value* (*th_3Set_take)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_take);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_take(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::take", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::take");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_takeWhile(ActRec* ar) {
  Value* (*th_3Set_takeWhile)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_takewhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_takeWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::takeWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::takeWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_skip(ActRec* ar) {
  Value* (*th_3Set_skip)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_skip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_skip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::skip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::skip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_skipWhile(ActRec* ar) {
  Value* (*th_3Set_skipWhile)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_skipwhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_skipWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::skipWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::skipWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_slice(ActRec* ar) {
  Value* (*th_3Set_slice)(Value*,c_Set*,TypedValue*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_slice);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      rv->m_type = KindOfObject;
      th_3Set_slice(&(rv->m_data), (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::slice", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::slice");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_concat(ActRec* ar) {
  Value* (*th_3Set_concat)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_concat);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_concat(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::concat", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::concat");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_firstValue(ActRec* ar) {
  TypedValue* (*th_3Set_firstValue)(TypedValue*,c_Set*) =
    (TypedValue* (*)(TypedValue*,c_Set*))getMethodPtr(&HPHP::c_Set::t_firstvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_3Set_firstValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::firstValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::firstValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_firstKey(ActRec* ar) {
  TypedValue* (*th_3Set_firstKey)(TypedValue*,c_Set*) =
    (TypedValue* (*)(TypedValue*,c_Set*))getMethodPtr(&HPHP::c_Set::t_firstkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_3Set_firstKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::firstKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::firstKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_lastValue(ActRec* ar) {
  TypedValue* (*th_3Set_lastValue)(TypedValue*,c_Set*) =
    (TypedValue* (*)(TypedValue*,c_Set*))getMethodPtr(&HPHP::c_Set::t_lastvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_3Set_lastValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::lastValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::lastValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_lastKey(ActRec* ar) {
  TypedValue* (*th_3Set_lastKey)(TypedValue*,c_Set*) =
    (TypedValue* (*)(TypedValue*,c_Set*))getMethodPtr(&HPHP::c_Set::t_lastkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_3Set_lastKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::lastKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::lastKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_removeAll(ActRec* ar) {
  Value* (*th_3Set_removeAll)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_removeall);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_removeAll(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::removeAll", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::removeAll");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_difference(ActRec* ar) {
  Value* (*th_3Set_difference)(Value*,c_Set*,TypedValue*) =
    (Value* (*)(Value*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t_difference);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_3Set_difference(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::difference", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::difference");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set___toString(ActRec* ar) {
  Value* (*th_3Set___toString)(Value*,c_Set*) =
    (Value* (*)(Value*,c_Set*))getMethodPtr(&HPHP::c_Set::t___tostring);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfString;
      th_3Set___toString(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("Set::__toString", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::__toString");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set___get(ActRec* ar) {
  TypedValue* (*th_3Set___get)(TypedValue*,c_Set*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t___get);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_3Set___get(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::__get", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::__get");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set___set(ActRec* ar) {
  TypedValue* (*th_3Set___set)(TypedValue*,c_Set*,TypedValue*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Set*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_Set::t___set);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      th_3Set___set(rv, (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::__set", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::__set");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set___isset(ActRec* ar) {
  bool (*th_3Set___isset)(c_Set*,TypedValue*) =
    (bool (*)(c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t___isset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_3Set___isset((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("Set::__isset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::__isset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set___unset(ActRec* ar) {
  TypedValue* (*th_3Set___unset)(TypedValue*,c_Set*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_Set*,TypedValue*))getMethodPtr(&HPHP::c_Set::t___unset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_Set* this_ = (ar->hasThis() ? static_cast<c_Set*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_3Set___unset(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("Set::__unset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("Set::__unset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_fromItems(ActRec* ar) {
  Value* (*th_3Set_fromItems)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_Set::ti_fromitems);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_3Set_fromItems(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("Set::fromItems", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_fromKeysOf(ActRec* ar) {
  Value* (*th_3Set_fromKeysOf)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_Set::ti_fromkeysof);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_3Set_fromKeysOf(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("Set::fromKeysOf", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_fromArray(ActRec* ar) {
  Value* (*th_3Set_fromArray)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_Set::ti_fromarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_3Set_fromArray(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("Set::fromArray", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_3Set_fromArrays(ActRec* ar) {
  Value* (*th_3Set_fromArrays)(Value*,int64_t,Value*) =
    (Value* (*)(Value*,int64_t,Value*))getMethodPtr(&HPHP::c_Set::ti_fromarrays);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  rv->m_type = KindOfObject;

  Array extraArgs;
  if (count > 0) {
    ArrayInit ai((size_t)count-0, ArrayInit::Mixed{});
    for (int32_t i = 0; i < count; ++i) {
      TypedValue* extraArg = ar->getExtraArg(i-0);
      if (tvIsStronglyBound(extraArg)) {
        ai.setRef(i-0, tvAsVariant(extraArg));
      } else {
        ai.set(i-0, tvAsVariant(extraArg));
      }
    }
    extraArgs = ai.toArray();
  }
  th_3Set_fromArrays(&(rv->m_data), count, (Value*)(&extraArgs));
  if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  frame_free_locals_no_this_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}


ObjectData* new_ImmSet_Instance(HPHP::Class* cls) {
  size_t nProps = cls->numDeclProperties();
  size_t builtinObjSize = sizeof(c_ImmSet) - sizeof(ObjectData);
  size_t size = ObjectData::sizeForNProps(nProps) + builtinObjSize;
  auto o = new (MM().objMalloc(size)) c_ImmSet(cls);
  assert(o->hasExactlyOneRef());
  return o;
}


void delete_ImmSet(ObjectData* obj, const Class* cls) {
  auto const ptr = static_cast<c_ImmSet*>(obj);
  ptr->~c_ImmSet();

  auto const nProps = cls->numDeclProperties();
  auto const propVec = reinterpret_cast<TypedValue*>(ptr + 1);
  for (auto i = Slot{0}; i < nProps; ++i) {
    tvRefcountedDecRef(&propVec[i]);
  }

  auto const builtinSz = sizeof(c_ImmSet) - sizeof(ObjectData);
  auto const size = ObjectData::sizeForNProps(nProps) + builtinSz;
  if (LIKELY(size <= kMaxSmallSize)) {
    return MM().freeSmallSize(ptr, size);
  }
  return MM().freeBigSize(ptr, size);
}

IMPLEMENT_CLASS_NO_SWEEP(ImmSet);
TypedValue* tg_6ImmSet___construct(ActRec* ar) {
  void (*th_6ImmSet___construct)(c_ImmSet*,TypedValue*) =
    (void (*)(c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t___construct);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count <= 1)) {
      rv->m_type = KindOfNull;
      th_6ImmSet___construct((this_), (count > 0) ? (args-0) : (TypedValue*)(&null_variant));
    } else {
      throw_toomany_arguments_nr("ImmSet::__construct", 1, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::__construct");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_isEmpty(ActRec* ar) {
  bool (*th_6ImmSet_isEmpty)(c_ImmSet*) =
    (bool (*)(c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_isempty);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_6ImmSet_isEmpty((this_))) ? 1LL : 0LL;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::isEmpty", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::isEmpty");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_count(ActRec* ar) {
  int64_t (*th_6ImmSet_count)(c_ImmSet*) =
    (int64_t (*)(c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_count);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfInt64;
      rv->m_data.num = (int64_t)th_6ImmSet_count((this_));
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::count", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::count");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_items(ActRec* ar) {
  Value* (*th_6ImmSet_items)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_items);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_items(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::items", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::items");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_keys(ActRec* ar) {
  Value* (*th_6ImmSet_keys)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_keys);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_keys(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::keys", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::keys");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_values(ActRec* ar) {
  Value* (*th_6ImmSet_values)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_values);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_values(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::values", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::values");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_lazy(ActRec* ar) {
  Value* (*th_6ImmSet_lazy)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_lazy);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_lazy(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::lazy", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::lazy");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_contains(ActRec* ar) {
  bool (*th_6ImmSet_contains)(c_ImmSet*,TypedValue*) =
    (bool (*)(c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_contains);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_6ImmSet_contains((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("ImmSet::contains", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::contains");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_toArray(ActRec* ar) {
  Value* (*th_6ImmSet_toArray)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_toarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_6ImmSet_toArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::toArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::toArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_toVector(ActRec* ar) {
  Value* (*th_6ImmSet_toVector)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_tovector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_toVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::toVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::toVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_toImmVector(ActRec* ar) {
  Value* (*th_6ImmSet_toImmVector)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_toimmvector);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_toImmVector(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::toImmVector", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::toImmVector");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_toMap(ActRec* ar) {
  Value* (*th_6ImmSet_toMap)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_tomap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_toMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::toMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::toMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_toImmMap(ActRec* ar) {
  Value* (*th_6ImmSet_toImmMap)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_toimmmap);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_toImmMap(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::toImmMap", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::toImmMap");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_toSet(ActRec* ar) {
  Value* (*th_6ImmSet_toSet)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_toset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_toSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::toSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::toSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_toImmSet(ActRec* ar) {
  Value* (*th_6ImmSet_toImmSet)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_toimmset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_toImmSet(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::toImmSet", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::toImmSet");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_immutable(ActRec* ar) {
  Value* (*th_6ImmSet_immutable)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_immutable);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_immutable(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::immutable", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::immutable");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_toKeysArray(ActRec* ar) {
  Value* (*th_6ImmSet_toKeysArray)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_tokeysarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_6ImmSet_toKeysArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::toKeysArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::toKeysArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_toValuesArray(ActRec* ar) {
  Value* (*th_6ImmSet_toValuesArray)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_tovaluesarray);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfArray;
      th_6ImmSet_toValuesArray(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::toValuesArray", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::toValuesArray");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_getIterator(ActRec* ar) {
  Value* (*th_6ImmSet_getIterator)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_getiterator);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_getIterator(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::getIterator", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::getIterator");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_map(ActRec* ar) {
  Value* (*th_6ImmSet_map)(Value*,c_ImmSet*,TypedValue*) =
    (Value* (*)(Value*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_map);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_map(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::map", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::map");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_mapWithKey(ActRec* ar) {
  Value* (*th_6ImmSet_mapWithKey)(Value*,c_ImmSet*,TypedValue*) =
    (Value* (*)(Value*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_mapwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_mapWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::mapWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::mapWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_filter(ActRec* ar) {
  Value* (*th_6ImmSet_filter)(Value*,c_ImmSet*,TypedValue*) =
    (Value* (*)(Value*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_filter);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_filter(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::filter", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::filter");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_filterWithKey(ActRec* ar) {
  Value* (*th_6ImmSet_filterWithKey)(Value*,c_ImmSet*,TypedValue*) =
    (Value* (*)(Value*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_filterwithkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_filterWithKey(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::filterWithKey", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::filterWithKey");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_zip(ActRec* ar) {
  Value* (*th_6ImmSet_zip)(Value*,c_ImmSet*,TypedValue*) =
    (Value* (*)(Value*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_zip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_zip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::zip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::zip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_take(ActRec* ar) {
  Value* (*th_6ImmSet_take)(Value*,c_ImmSet*,TypedValue*) =
    (Value* (*)(Value*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_take);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_take(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::take", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::take");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_takeWhile(ActRec* ar) {
  Value* (*th_6ImmSet_takeWhile)(Value*,c_ImmSet*,TypedValue*) =
    (Value* (*)(Value*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_takewhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_takeWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::takeWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::takeWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_skip(ActRec* ar) {
  Value* (*th_6ImmSet_skip)(Value*,c_ImmSet*,TypedValue*) =
    (Value* (*)(Value*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_skip);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_skip(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::skip", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::skip");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_skipWhile(ActRec* ar) {
  Value* (*th_6ImmSet_skipWhile)(Value*,c_ImmSet*,TypedValue*) =
    (Value* (*)(Value*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_skipwhile);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_skipWhile(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::skipWhile", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::skipWhile");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_slice(ActRec* ar) {
  Value* (*th_6ImmSet_slice)(Value*,c_ImmSet*,TypedValue*,TypedValue*) =
    (Value* (*)(Value*,c_ImmSet*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_slice);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_slice(&(rv->m_data), (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::slice", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::slice");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_concat(ActRec* ar) {
  Value* (*th_6ImmSet_concat)(Value*,c_ImmSet*,TypedValue*) =
    (Value* (*)(Value*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t_concat);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfObject;
      th_6ImmSet_concat(&(rv->m_data), (this_), (args-0));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::concat", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::concat");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_firstValue(ActRec* ar) {
  TypedValue* (*th_6ImmSet_firstValue)(TypedValue*,c_ImmSet*) =
    (TypedValue* (*)(TypedValue*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_firstvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6ImmSet_firstValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::firstValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::firstValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_firstKey(ActRec* ar) {
  TypedValue* (*th_6ImmSet_firstKey)(TypedValue*,c_ImmSet*) =
    (TypedValue* (*)(TypedValue*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_firstkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6ImmSet_firstKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::firstKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::firstKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_lastValue(ActRec* ar) {
  TypedValue* (*th_6ImmSet_lastValue)(TypedValue*,c_ImmSet*) =
    (TypedValue* (*)(TypedValue*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_lastvalue);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6ImmSet_lastValue(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::lastValue", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::lastValue");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_lastKey(ActRec* ar) {
  TypedValue* (*th_6ImmSet_lastKey)(TypedValue*,c_ImmSet*) =
    (TypedValue* (*)(TypedValue*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t_lastkey);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      th_6ImmSet_lastKey(rv, (this_));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::lastKey", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::lastKey");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet___toString(ActRec* ar) {
  Value* (*th_6ImmSet___toString)(Value*,c_ImmSet*) =
    (Value* (*)(Value*,c_ImmSet*))getMethodPtr(&HPHP::c_ImmSet::t___tostring);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 0)) {
      rv->m_type = KindOfString;
      th_6ImmSet___toString(&(rv->m_data), (this_));
      if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
      frame_free_inl(ar, rv);
      ar->m_r = *rv;
      return &ar->m_r;
    } else {
      throw_toomany_arguments_nr("ImmSet::__toString", 0, count, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::__toString");
  }
  frame_free_locals_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet___get(ActRec* ar) {
  TypedValue* (*th_6ImmSet___get)(TypedValue*,c_ImmSet*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t___get);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_6ImmSet___get(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::__get", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::__get");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet___set(ActRec* ar) {
  TypedValue* (*th_6ImmSet___set)(TypedValue*,c_ImmSet*,TypedValue*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmSet*,TypedValue*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t___set);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 2)) {
      th_6ImmSet___set(rv, (this_), (args-0), (args-1));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::__set", count, 2, 2, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::__set");
  }
  frame_free_locals_inl(ar, 2, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet___isset(ActRec* ar) {
  bool (*th_6ImmSet___isset)(c_ImmSet*,TypedValue*) =
    (bool (*)(c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t___isset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      rv->m_type = KindOfBoolean;
      rv->m_data.num = (th_6ImmSet___isset((this_), (args-0))) ? 1LL : 0LL;
    } else {
      throw_wrong_arguments_nr("ImmSet::__isset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::__isset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet___unset(ActRec* ar) {
  TypedValue* (*th_6ImmSet___unset)(TypedValue*,c_ImmSet*,TypedValue*) =
    (TypedValue* (*)(TypedValue*,c_ImmSet*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::t___unset);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  c_ImmSet* this_ = (ar->hasThis() ? static_cast<c_ImmSet*>(ar->getThis()) :  nullptr);
  if (LIKELY(this_ != nullptr)) {
    if (LIKELY(count == 1)) {
      th_6ImmSet___unset(rv, (this_), (args-0));
      if (UNLIKELY(rv->m_type == KindOfUninit)) rv->m_type = KindOfNull;
    } else {
      throw_wrong_arguments_nr("ImmSet::__unset", count, 1, 1, 1, rv);
    }
  } else {
    throw_instance_method_fatal("ImmSet::__unset");
  }
  frame_free_locals_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_fromItems(ActRec* ar) {
  Value* (*th_6ImmSet_fromItems)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::ti_fromitems);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_6ImmSet_fromItems(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("ImmSet::fromItems", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_fromKeysOf(ActRec* ar) {
  Value* (*th_6ImmSet_fromKeysOf)(Value*,TypedValue*) =
    (Value* (*)(Value*,TypedValue*))getMethodPtr(&HPHP::c_ImmSet::ti_fromkeysof);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  if (LIKELY(count == 1)) {
    rv->m_type = KindOfObject;
    th_6ImmSet_fromKeysOf(&(rv->m_data), (args-0));
    if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  } else {
    throw_wrong_arguments_nr("ImmSet::fromKeysOf", count, 1, 1, 1, rv);
  }
  frame_free_locals_no_this_inl(ar, 1, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

TypedValue* tg_6ImmSet_fromArrays(ActRec* ar) {
  Value* (*th_6ImmSet_fromArrays)(Value*,int64_t,Value*) =
    (Value* (*)(Value*,int64_t,Value*))getMethodPtr(&HPHP::c_ImmSet::ti_fromarrays);
  TypedValue rvSpace;
  TypedValue* rv = &rvSpace;
  int32_t count = ar->numArgs();
  TypedValue* args UNUSED = ((TypedValue*)ar) - 1;
  rv->m_type = KindOfObject;

  Array extraArgs;
  if (count > 0) {
    ArrayInit ai((size_t)count-0, ArrayInit::Mixed{});
    for (int32_t i = 0; i < count; ++i) {
      TypedValue* extraArg = ar->getExtraArg(i-0);
      if (tvIsStronglyBound(extraArg)) {
        ai.setRef(i-0, tvAsVariant(extraArg));
      } else {
        ai.set(i-0, tvAsVariant(extraArg));
      }
    }
    extraArgs = ai.toArray();
  }
  th_6ImmSet_fromArrays(&(rv->m_data), count, (Value*)(&extraArgs));
  if (UNLIKELY(rv->m_data.num == 0LL)) rv->m_type = KindOfNull;
  frame_free_locals_no_this_inl(ar, 0, rv);
  ar->m_r = *rv;
  return &ar->m_r;
}

} // namespace HPHP
