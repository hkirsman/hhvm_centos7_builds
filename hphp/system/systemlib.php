<?hh
// {@}generated

namespace {

// default base
class stdClass {
}

// used in unserialize() for unknown classes
class __PHP_Incomplete_Class {
  public $__PHP_Incomplete_Class_Name;
}
}

namespace {

// Used as a sentinel type in 86pinit().
class __pinitSentinel {
}
}

namespace {

interface XHPChild {}

interface Stringish {
  public function __toString();
}
}

namespace {

// Used to represent resources
class __resource {
  public function __toString() {
    return hphp_to_string($this);
  }
}
}


namespace HH {

interface AsyncIterator {
  /**
   * Returns new Awaitable that will produce the next (key, value) Pair, or
   * null if the iteration has finished. It's illegal to call next() while
   * the previously returned Awaitable has not finished yet.
   */
  public function next();
}

}


namespace HH {

interface AsyncKeyedIterator extends \HH\AsyncIterator {}

}


namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.traversable.php )
 *
 * Interface to detect if a class is traversable using foreach.
 *
 * Abstract base interface that cannot be implemented alone. Instead it
 * must be implemented by either IteratorAggregate or Iterator.
 *
 * Internal (built-in) classes that implement this interface can be used
 * in a foreach construct and do not need to implement IteratorAggregate or
 * Iterator.
 *
 * This is an internal engine interface which cannot be implemented in PHP
 * scripts. Either IteratorAggregate or Iterator must be used instead. When
 * implementing an interface which extends Traversable, make sure to list
 * IteratorAggregate or Iterator before its name in the implements clause.
 *
 */
interface Traversable {
}

}

namespace HH {

interface Traversable {
}

interface Container extends \HH\Traversable {
}

interface KeyedTraversable extends \HH\Traversable {
}

interface KeyedContainer extends \HH\Container, \HH\KeyedTraversable {
}

}


namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.iterator.php )
 *
 * Interface for external iterators or objects that can be iterated
 * themselves internally.
 *
 */
interface Iterator extends \Traversable {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iterator.current.php )
   *
   * Returns the current element.
   *
   * @return     mixed   Can return any type.
   */
  public function current();
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iterator.key.php )
   *
   * Returns the key of the current element.
   *
   * @return     mixed   Returns scalar on success, or NULL on failure.
   */
  public function key();
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iterator.next.php )
   *
   * Moves the current position to the next element.
   *
   * This method is called after each foreach loop.
   *
   * @return     mixed   Any returned value is ignored.
   */
  public function next();
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iterator.rewind.php )
   *
   * Rewinds back to the first element of the Iterator.
   *
   * This is the first method called when starting a foreach loop. It will
   * not be executed after foreach loops.
   *
   * @return     mixed   Any returned value is ignored.
   */
  public function rewind();
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iterator.valid.php )
   *
   * This method is called after Iterator::rewind() and Iterator::next() to
   * check if the current position is valid.
   *
   * @return     mixed   The return value will be casted to boolean and then
   *                     evaluated. Returns TRUE on success or FALSE on
   *                     failure.
   */
  public function valid();
}

}

namespace HH {

interface Iterator extends \HH\Traversable, \Iterator {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iterator.current.php )
   *
   * Returns the current element.
   *
   * @return     mixed   Can return any type.
   */
  public function current();
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iterator.key.php )
   *
   * Returns the key of the current element.
   *
   * @return     mixed   Returns scalar on success, or NULL on failure.
   */
  public function key();
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iterator.next.php )
   *
   * Moves the current position to the next element.
   *
   * This method is called after each foreach loop.
   *
   * @return     mixed   Any returned value is ignored.
   */
  public function next();
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iterator.rewind.php )
   *
   * Rewinds back to the first element of the Iterator.
   *
   * This is the first method called when starting a foreach loop. It will
   * not be executed after foreach loops.
   *
   * @return     mixed   Any returned value is ignored.
   */
  public function rewind();
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iterator.valid.php )
   *
   * This method is called after Iterator::rewind() and Iterator::next() to
   * check if the current position is valid.
   *
   * @return     mixed   The return value will be casted to boolean and then
   *                     evaluated. Returns TRUE on success or FALSE on
   *                     failure.
   */
  public function valid();
}

}



namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.iteratoraggregate.php )
 *
 * Interface to create an external Iterator.
 *
 */
interface IteratorAggregate extends \Traversable {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/iteratoraggregate.getiterator.php )
   *
   * Returns an external iterator.
   *
   * @return     mixed   An instance of an object implementing Iterator or
   *                     Traversable
   */
  public function getIterator();
}

}

namespace HH {

interface Iterable extends \HH\Traversable, \IteratorAggregate {
}

}



namespace HH {

interface KeyedIterator extends \HH\Iterator, \HH\KeyedTraversable {}

}



namespace HH {

interface KeyedIterable extends \HH\Iterable, \HH\KeyedTraversable {
  public function mapWithKey($callback);
  public function filterWithKey($callback);
  public function keys();
}

}

namespace __SystemLib {
interface Throwable {
  public function getMessage(): string;
  public function getCode(): int;
  public function getFile(): string;
  public function getLine(): int;
  public function getTrace(): array;
  public function getTraceAsString(): string;
  public function getPrevious(): Throwable;
  public function __toString(): string;
}
}

namespace __SystemLib {
// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.exception.php )
 *
 * Exception is the base class for all Exceptions.
 *
 */
trait BaseException {
  require implements Throwable;

  protected $message = '';  // exception message
  private $string = '';     // php5 has this, we don't use it
  protected $code = 0;      // user defined exception code
  protected $file;          // source filename of exception
  protected $line;          // source line of exception
  private $trace;           // full stacktrace
  private $previous = null;

  private static $traceOpts = 0;

  /*
   * There is no constructor in this trait-- It should be possible to extend
   * Exception and add a PHP4 constructor, traits play poorly with PHP4
   * constructors.
   */

  /**
   * This cannot be implemented in __construct, because a derived class may
   * implement its own __construct, losing the stacktrace. The runtime has
   * special logic to call the __init__ method before
   * calling __construct just to make sure $this->trace is always populated.
   */
  final public function __init__() {
    if (isset($this->trace)) {
      return;
    }
    $this->initTrace();
  }

  private function __check_init($context) {
    if (!isset($this->trace)) {
      \trigger_error($context.': exception object not initialized', E_WARNING);
      return false;
    } else {
      return true;
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/exception.getmessage.php )
   *
   * Returns the Exception message.
   *
   * @return     mixed   Returns the Exception message as a string.
   */
  public function getMessage() {
    return $this->message;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/exception.getprevious.php )
   *
   * Returns previous Exception (the third parameter of
   * Exception::__construct()).
   *
   * @return     mixed   Returns the previous Exception if available or NULL
   *                     otherwise.
   */
  final public function getPrevious() {
    return $this->previous;
  }

  final public function setPrevious(\__SystemLib\Throwable $previous) {
    $this->previous = $previous;
  }

  final public function setPreviousChain(\__SystemLib\Throwable $previous) {
    $cur = $this;
    $next = $cur->getPrevious();
    while ($next instanceof \__SystemLib\Throwable) {
      $cur = $next;
      $next = $cur->getPrevious();
    }
    $cur->setPrevious($previous);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/exception.getcode.php )
   *
   * Returns the Exception code.
   *
   * @return     mixed   Returns the exception code as integer in Exception
   *                     but possibly as other type in Exception descendants
   *                     (for example as string in PDOException).
   */
  public function getCode() {
    return $this->code;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/exception.getfile.php )
   *
   * Get the name of the file the exception was created.
   *
   * @return     mixed   Returns the filename in which the exception was
   *                     created.
   */
  final public function getFile() {
    if (!$this->__check_init(__METHOD__)) {
      return null;
    }
    return $this->file;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/exception.getline.php )
   *
   * Get line number where the exception was created.
   *
   * @return     mixed   Returns the line number where the exception was
   *                     created.
   */
  final public function getLine() {
    if (!$this->__check_init(__METHOD__)) {
      return null;
    }
    return $this->line;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/exception.gettrace.php )
   *
   * Returns the Exception stack trace.
   *
   * @return     mixed   Returns the Exception stack trace as an array.
   */
  final public function getTrace() {
    if (!$this->__check_init(__METHOD__)) {
      return null;
    }
    return $this->trace;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/exception.gettraceasstring.php )
   *
   * Returns the Exception stack trace as a string.
   *
   * @return     mixed   Returns the Exception stack trace as a string.
   */
  final public function getTraceAsString() {
    if (!$this->__check_init(__METHOD__)) {
      return null;
    }
    $i = 0;
    $s = "";
    foreach ($this->getTrace() as $frame) {
      if (!\is_array($frame)) continue;
      $s .= "#$i " .
        (isset($frame['file']) ? $frame['file'] : "") . "(" .
        (isset($frame['line']) ? $frame['line'] : "") . "): " .
        (isset($frame['class']) ? $frame['class'] . $frame['type'] : "") .
        $frame['function'] . "()\n";
      $i++;
    }
    $s .= "#$i {main}";
    return $s;
  }

  /* Overrideable */
  // formated string for display
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/exception.tostring.php )
   *
   * Returns the string representation of the exception.
   *
   * @return     mixed   Returns the string representation of the exception.
   */
  public function __toString() {
    $res = "";
    $lst = array();
    $ex = $this;
    while ($ex != null) {
      $lst[] = $ex;
      $ex = $ex->getPrevious();
    }
    $lst = \array_reverse($lst);
    foreach ($lst as $i => $ex) {
      if ($i > 0) {
        $res .= "\n\nNext ";
      }
      $cls = \get_class($ex);
      if (\substr($cls, 0, strlen("__SystemLib\\")) === "__SystemLib\\") {
        $cls = \substr($cls, strlen("__SystemLib\\"));
      }
      $res .= $ex instanceof Error
        ? $cls . ": " . $ex->getMessage()
        : "exception '" . $cls . "' with message '" . $ex->getMessage() . "'";
      $res .=  " in " . $ex->getFile() . ":" .
        $ex->getLine() . "\nStack trace:\n" . $ex->getTraceAsString();
    }
    return $res;
  }

  /**
   * Derived classes may override the methods below if different behavior
   * for initializing the trace is desired
   */
  protected function initTrace() {
    $this->trace = \debug_backtrace(static::getTraceOptions());
    // Remove top stack frames up to and including Exception::__init__,
    // set the 'file' and 'line' properties appropriately
    while (!empty($this->trace)) {
      $top = \array_shift($this->trace);
      if (isset($top['class']) && isset($top['function']) &&
          (\strcasecmp($top['class'], 'exception') === 0 ||
           \strcasecmp($top['class'], '__systemlib\error') === 0) &&
          \strcasecmp($top['function'], '__init__') === 0) {
        if (isset($top['file'])) $this->file = $top['file'];
        if (isset($top['line'])) $this->line = $top['line'];
        break;
      }
    }
    // Remove systemlib stack frames until we hit the user code.
    // Assume user code will contain the elements for file and line.
    if (($this->file === null) && ($this->line === null)) {
      while (!empty($this->trace)
        && !isset($this->trace[0]['file']) && !isset($this->trace[0]['line'])
      ) {
        \array_shift($this->trace);
      }
      if (isset($this->trace[0]['file'])) {
        $this->file = $this->trace[0]['file'];
      }
      if (isset($this->trace[0]['line'])) {
        $this->line = $this->trace[0]['line'];
      }
    }
  }

  public static function getTraceOptions() {
    return self::$traceOpts;
  }

  public static function setTraceOptions($opts) {
    self::$traceOpts = (int)$opts;
  }

  final private function __clone() {
    \trigger_error("Trying to clone an uncloneable object of class " .
                   \get_class($this), E_USER_ERROR);
  }
}
}

namespace __SystemLib {
class Error implements Throwable {
  use BaseException;
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/exception.construct.php )
   *
   * Constructs the Exception.
   *
   * @message    mixed   The Exception message to throw.
   * @code       mixed   The Exception code.
   * @previous   mixed   The previous exception used for the exception
   *                     chaining.
   */
  public function __construct($message = '', $code = 0,
                              \__SystemLib\Throwable $previous = null) {

    // Child classes may just override the protected property
    // without implementing a constructor or calling parent one.
    // In this case we should not override it from the param.

    if ($message !== '' || $this->message === '') {
      $this->message = $message;
    }

    if ($code !== 0 || $this->code === 0) {
      $this->code = $code;
    }

    $this->previous = $previous;
  }
}

class ArithmeticError extends Error {}
class AssertionError extends Error {}
class DivisionByZeroError extends Error {}
class ParseError extends Error {}
class TypeError extends Error {}
}

namespace {

class Exception implements \__SystemLib\Throwable {
  use \__SystemLib\BaseException;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/exception.construct.php )
   *
   * Constructs the Exception.
   *
   * @message    mixed   The Exception message to throw.
   * @code       mixed   The Exception code.
   * @previous   mixed   The previous exception used for the exception
   *                     chaining.
   */
  public function __construct($message = '', $code = 0,
                              \__SystemLib\Throwable $previous = null) {

    // Child classes may just override the protected property
    // without implementing a constructor or calling parent one.
    // In this case we should not override it from the param.

    if ($message !== '' || $this->message === '') {
      $this->message = $message;
    }

    if ($code !== 0 || $this->code === 0) {
      $this->code = $code;
    }

    $this->previous = $previous;
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.logicexception.php )
 *
 * Exception that represents error in the program logic. This kind of
 * exceptions should directly lead to a fix in your code.
 *
 */
class LogicException extends Exception {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://docs.hhvm.com/manual/en/class.badfunctioncallexception.php )
 *
 * Exception thrown if a callback refers to an undefined function or if
 * some arguments are missing.
 *
 */
class BadFunctionCallException extends LogicException {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.badmethodcallexception.php
 * )
 *
 * Exception thrown if a callback refers to an undefined method or if some
 * arguments are missing.
 *
 */
class BadMethodCallException extends BadFunctionCallException {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.domainexception.php )
 *
 * Exception thrown if a value does not adhere to a defined valid data
 * domain.
 *
 */
class DomainException extends LogicException {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://docs.hhvm.com/manual/en/class.invalidargumentexception.php )
 *
 * Exception thrown if an argument does not match with the expected value.
 *
 */
class InvalidArgumentException extends LogicException {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.lengthexception.php )
 *
 * Exception thrown if a length is invalid.
 *
 */
class LengthException extends LogicException {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.outofrangeexception.php )
 *
 * Exception thrown when an illegal index was requested. This represents
 * errors that should be detected at compile time.
 *
 */
class OutOfRangeException extends LogicException {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.runtimeexception.php )
 *
 * Exception thrown if an error which can only be found on runtime occurs.
 *
 */
class RuntimeException extends Exception {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.outofboundsexception.php )
 *
 * Exception thrown if a value is not a valid key. This represents errors
 * that cannot be detected at compile time.
 *
 */
class OutOfBoundsException extends RuntimeException {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.overflowexception.php )
 *
 * Exception thrown when adding an element to a full container.
 *
 */
class OverflowException extends RuntimeException {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.rangeexception.php )
 *
 * Exception thrown to indicate range errors during program execution.
 * Normally this means there was an arithmetic error other than
 * under/overflow. This is the runtime version of DomainException.
 *
 */
class RangeException extends RuntimeException {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.underflowexception.php )
 *
 * Exception thrown when performing an invalid operation on an empty
 * container, such as removing an element.
 *
 */
class UnderflowException extends RuntimeException {}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://docs.hhvm.com/manual/en/class.unexpectedvalueexception.php )
 *
 * Exception thrown if a value does not match with a set of values.
 * Typically this happens when a function calls another function and
 * expects the return value to be of a certain type or value not including
 * arithmetic or buffer related errors.
 *
 */
class UnexpectedValueException extends RuntimeException {}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.countable.php )
 *
 * Classes implementing Countable can be used with the count() function.
 *
 */
interface Countable {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/countable.count.php )
   *
   * This method is executed when using the count() function on an object
   * implementing Countable.
   *
   * @return     mixed   The custom count as an integer.
   *
   *                     The return value is cast to an integer.
   */
  public function count();
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.recursiveiterator.php )
 *
 * Classes implementing RecursiveIterator can be used to iterate over
 * iterators recursively.
 *
 */
interface RecursiveIterator extends \HH\Iterator {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveiterator.getchildren.php )
   *
   * Returns an iterator for the current iterator entry.
   *
   * @return     mixed   An iterator for the current entry.
   */
  public function getChildren();
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveiterator.haschildren.php )
   *
   * Returns if an iterator can be created for the current entry.
   * RecursiveIterator::getChildren().
   *
   * @return     mixed   Returns TRUE if the current entry can be iterated
   *                     over, otherwise returns FALSE.
   */
  public function hasChildren();
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.splheap.php )
 *
 * The SplHeap class provides the main functionalities of a Heap.
 *
 */
abstract class SplHeap implements \HH\Iterator, Countable {

  // Only here to be var_dump compatible with zend
  private $flags = 0;

  private $isCorrupted = false;
  private $heap = array();

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.construct.php )
   *
   * This constructs a new empty heap.
   *
   * @return     mixed   No value is returned.
   */
  public function __construct() {}

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.compare.php )
   *
   * Compare value1 with value2. Warning
   *
   * Throwing exceptions in SplHeap::compare() can corrupt the Heap and
   * place it in a blocked state. You can unblock it by calling
   * SplHeap::recoverFromCorruption(). However, some elements might not be
   * placed correctly and it may hence break the heap-property.
   *
   * @value1     mixed   The value of the first node being compared.
   * @value2     mixed   The value of the second node being compared.
   *
   * @return     mixed   Result of the comparison, positive integer if value1
   *                     is greater than value2, 0 if they are equal,
   *                     negative integer otherwise.
   *
   *                     Having multiple elements with the same value in a
   *                     Heap is not recommended. They will end up in an
   *                     arbitrary relative position.
   */
  abstract protected function compare($value1, $value2);

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.extract.php )
   *
   *
   * @return     mixed   The value of the extracted node.
   */
  public function extract() {
    $this->checkNotCorrupted();
    if ($this->isEmpty()) {
      throw new RuntimeException(
        'Can\'t extract from an empty heap'
      );
    }

    $result = $this->top();
    $end = $this->highestUsedIndex();
    $this->swapElements(0, $end);
    unset($this->heap[$end]);

    try {
      $this->heapifyDown(0);
    } catch (Exception $e) {
      $this->isCorrupted = true;
      throw $e;
    }
    return $result;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.insert.php )
   *
   * Insert value in the heap.
   *
   * @value      mixed   The value to insert.
   *
   * @return     mixed   No value is returned.
   */
  public function insert($value) {
    $this->checkNotCorrupted();
    $index = $this->lowestFreeIndex();
    $this->heap[$index] = $value;

    try {
      $this->heapifyUp($index);
    } catch (Exception $e) {
      $this->isCorrupted = true;
      throw $e;
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.isempty.php )
   *
   *
   * @return     mixed   Returns whether the heap is empty.
   */
  public function isEmpty() {
    return $this->count() == 0;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/splheap.recoverfromcorruption.php )
   *
   *
   * @return     mixed   No value is returned.
   */
  public function recoverFromCorruption() {
    $this->isCorrupted = false;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.count.php )
   *
   *
   * @return     mixed   Returns the number of elements in the heap.
   */
  public function count() {
    return count($this->heap);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.current.php )
   *
   * Get the current datastructure node.
   *
   * @return     mixed   The current node value.
   */
  public function current() {
    return $this->isEmpty() ? null : $this->top();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.key.php )
   *
   * This function returns the current node index
   *
   * @return     mixed   The current node index.
   */
  public function key() {
    return $this->highestUsedIndex();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.next.php )
   *
   * Move to the next node.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    if ($this->isEmpty()) {
      // don't error, just silently stop
      return;
    }
    $this->extract();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.rewind.php )
   *
   * This rewinds the iterator to the beginning. This is a no-op for heaps
   * as the iterator is virtual and in fact never moves from the top of the
   * heap.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    // Do nothing, the iterator always points to the top element
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.top.php )
   *
   *
   * @return     mixed   The value of the node on the top.
   */
  public function top() {
    $this->checkNotCorrupted();
    if ($this->isEmpty()) {
      throw new RuntimeException(
        'Can\'t peek at an empty heap'
      );
    }

    return $this->heap[0];
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splheap.valid.php )
   *
   * Checks if the heap contains any more nodes.
   *
   * @return     mixed   Returns TRUE if the heap contains any more nodes,
   *                     FALSE otherwise.
   */
  public function valid() {
    return !$this->isEmpty();
  }

  private function heapifyUp($index) {
    if ($index != 0) {
      $parentIndex = self::parentIndex($index);
      if ($this->compare($this->heap[$index],
                         $this->heap[$parentIndex]) > 0) {
        $this->swapElements($parentIndex, $index);
        $this->heapifyUp($parentIndex);
      }
    }
  }

  private function heapifyDown($index) {
    $highestChildIndex = $this->getHighestChildIndex($index);
    if ($highestChildIndex !== null &&
        $this->compare($this->heap[$highestChildIndex],
                       $this->heap[$index]) > 0) {
      $this->swapElements($index, $highestChildIndex);
      $this->heapifyDown($highestChildIndex);
    }
  }

  private function getHighestChildIndex($index) {
    if (isset($this->heap[self::leftChildIndex($index)])) {
      if (isset($this->heap[self::rightChildIndex($index)])) {
        if ($this->compare($this->heap[self::rightChildIndex($index)],
                           $this->heap[self::leftChildIndex($index)]) > 0) {
          return self::rightChildIndex($index);
        } else {
          return self::leftChildIndex($index);
        }
      } else {
        return self::leftChildIndex($index);
      }
    } else {
      return null;
    }
  }

  private function swapElements($firstIndex, $secondIndex) {
    $temporary = $this->heap[$firstIndex];
    $this->heap[$firstIndex] = $this->heap[$secondIndex];
    $this->heap[$secondIndex] = $temporary;
  }

  private function lowestFreeIndex() {
    return $this->count();
  }

  private function highestUsedIndex() {
    return $this->count() - 1;
  }

  private function checkNotCorrupted() {
    if ($this->isCorrupted) {
      throw new RuntimeException(
        'Heap is corrupted, heap properties are no longer ensured.'
      );
    }
  }

  private static function leftChildIndex($rootIndex) {
    return 2 * $rootIndex + 1;
  }

  private static function rightChildIndex($rootIndex) {
    return 2 * $rootIndex + 2;
  }

  private static function parentIndex($childIndex) {
    return floor(($childIndex - 1) / 2);
  }
}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.splmaxheap.php )
 *
 * The SplMaxHeap class provides the main functionalities of a heap,
 * keeping the maximum on the top.
 *
 */
class SplMaxHeap extends SplHeap implements \HH\Iterator, Countable {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splmaxheap.compare.php )
   *
   * Compare value1 with value2.
   *
   * @value1     mixed   The value of the first node being compared.
   * @value2     mixed   The value of the second node being compared.
   *
   * @return     mixed   Result of the comparison, positive integer if value1
   *                     is greater than value2, 0 if they are equal,
   *                     negative integer otherwise.
   *
   *                     Having multiple elements with the same value in a
   *                     Heap is not recommended. They will end up in an
   *                     arbitrary relative position.
   */
  protected function compare($value1, $value2) {
    if ($value1 > $value2) {
      return 1;
    } else if ($value1 < $value2) {
      return -1;
    } else {
      return 0;
    }
  }
}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.splminheap.php )
 *
 * The SplMinHeap class provides the main functionalities of a heap,
 * keeping the minimum on the top.
 *
 */
class SplMinHeap extends SplHeap implements \HH\Iterator, Countable {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splminheap.compare.php )
   *
   * Compare value1 with value2.
   *
   * @value1     mixed   The value of the first node being compared.
   * @value2     mixed   The value of the second node being compared.
   *
   * @return     mixed   Result of the comparison, positive integer if value1
   *                     is lower than value2, 0 if they are equal, negative
   *                     integer otherwise.
   *
   *                     Having multiple elements with the same value in a
   *                     Heap is not recommended. They will end up in an
   *                     arbitrary relative position.
   */
  protected function compare($value1, $value2) {
    if ($value2 > $value1) {
      return 1;
    } else if ($value2 < $value1) {
      return -1;
    } else {
      return 0;
    }
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.splfileinfo.php )
 *
 * The SplFileInfo class offers a high-level object oriented interface to
 * information for an individual file.
 *
 */
class SplFileInfo {

  private $fileName;
  private $fileClass = "SplFileObject";
  private $infoClass = "SplFileInfo";

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.construct.php )
   *
   * Creates a new SplFileInfo object for the file_name specified. The file
   * does not need to exist, or be readable.
   *
   * @file_name  mixed   Path to the file.
   */
  public function __construct($file_name) {
    $this->setPathname($file_name);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getpath.php )
   *
   * Returns the path to the file, omitting the filename and any trailing
   * slash.
   *
   * @return     mixed   Returns the path to the file.
   */
  public function getPath() {
    return dirname($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getfilename.php )
   *
   * Gets the filename without any path information.
   *
   * @return     mixed   The filename.
   */
  public function getFilename() {
    return $this->getBasename();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getfileinfo.php )
   *
   * This method gets an SplFileInfo object for the referenced file.
   *
   * @class_name mixed   Name of an SplFileInfo derived class to use.
   *
   * @return     mixed   An SplFileInfo object created for the file.
   */
  public function getFileInfo($class_name = null) {
    if (!$class_name) {
      $class_name = $this->infoClass;
    }
    return new $class_name($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getbasename.php )
   *
   * This method returns the base name of the file, directory, or link
   * without path info.
   *
   * @suffix     mixed   Optional suffix to omit from the base name returned.
   *
   * @return     mixed   Returns the base name without path information.
   */
  public function getBasename($suffix = "") {
    return basename($this->getPathname(), $suffix);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getpathname.php )
   *
   * Returns the path to the file.
   *
   * @return     mixed   The path to the file.
   */
  public function getPathname() {
    return $this->fileName;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getpathinfo.php )
   *
   * Gets an SplFileInfo object for the parent of the current file.
   *
   * @class_name mixed   Name of an SplFileInfo derived class to use.
   *
   * @return     mixed   Returns an SplFileInfo object for the parent path of
   *                     the file.
   */
  public function getPathInfo($class_name = null) {
    if (!$class_name) {
      $class_name = $this->infoClass;
    }
    return new $class_name($this->getPath());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getperms.php )
   *
   * Gets the file permissions for the file.
   *
   * @return     mixed   Returns the file permissions.
   */
  public function getPerms() {
    return fileperms($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getinode.php )
   *
   * Gets the inode number for the filesystem object.
   *
   * @return     mixed   Returns the inode number for the filesystem object.
   */
  public function getInode() {
    return fileinode($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getsize.php )
   *
   * Returns the filesize in bytes for the file referenced.
   *
   * @return     mixed   The filesize in bytes.
   */
  public function getSize() {
    return filesize($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getowner.php )
   *
   * Gets the file owner. The owner ID is returned in numerical format.
   *
   * @return     mixed   The owner id in numerical format.
   */
  public function getOwner() {
    return fileowner($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getgroup.php )
   *
   * Gets the file group. The group ID is returned in numerical format.
   *
   * @return     mixed   The group id in numerical format.
   */
  public function getGroup() {
    return filegroup($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getatime.php )
   *
   * Gets the last access time for the file.
   *
   * @return     mixed   Returns the time the file was last accessed.
   */
  public function getATime() {
    return fileatime($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getmtime.php )
   *
   * Returns the time when the contents of the file were changed. The time
   * returned is a Unix timestamp.
   *
   * @return     mixed   Returns the last modified time for the file, in a
   *                     Unix timestamp.
   */
  public function getMTime() {
    return filemtime($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getctime.php )
   *
   * Returns the inode change time for the file. The time returned is a Unix
   * timestamp.
   *
   * @return     mixed   The last change time, in a Unix timestamp.
   */
  public function getCTime() {
    return filectime($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.gettype.php )
   *
   * Returns the type of the file referenced.
   *
   * @return     mixed   A string representing the type of the entry. May be
   *                     one of file, link, or dir
   */
  public function getType() {
    return filetype($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getextension.php )
   *
   * Retrieves the file extension.
   *
   * @return     mixed   Returns a string containing the file extension, or
   *                     an empty string if the file has no extension.
   */
  public function getExtension() {
    return pathinfo($this->getPathname(), PATHINFO_EXTENSION);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.iswritable.php )
   *
   * Checks if the current entry is writable.
   *
   * @return     mixed   Returns TRUE if writable, FALSE otherwise;
   */
  public function isWritable() {
    return is_writable($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.isreadable.php )
   *
   * Check if the file is readable.
   *
   * @return     mixed   Returns TRUE if readable, FALSE otherwise.
   */
  public function isReadable() {
    return is_readable($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.isexecutable.php )
   *
   * Checks if the file is executable.
   *
   * @return     mixed   Returns TRUE if executable, FALSE otherwise.
   */
  public function isExecutable() {
    return is_executable($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.isfile.php )
   *
   * Checks if the file referenced by this SplFileInfo object exists and is
   * a regular file.
   *
   * @return     mixed   Returns TRUE if the file exists and is a regular
   *                     file (not a link), FALSE otherwise.
   */
  public function isFile() {
    return is_file($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.isdir.php )
   *
   * This method can be used to determine if the file is a directory.
   *
   * @return     mixed   Returns TRUE if a directory, FALSE otherwise.
   */
  public function isDir() {
    return is_dir($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.islink.php )
   *
   * Use this method to check if the file referenced by the SplFileInfo
   * object is a link.
   *
   * @return     mixed   Returns TRUE if the file is a link, FALSE otherwise.
   */
  public function isLink() {
    return is_link($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getlinktarget.php )
   *
   * Gets the target of a filesystem link.
   *
   * The target may not be the real path on the filesystem. Use
   * SplFileInfo::getRealPath() to determine the true path on the filesystem.
   *
   * @return     mixed   Returns the target of the filesystem link.
   */
  public function getLinkTarget() {
    $link = @readlink($this->getPathname());
    if ($link === false) {
      throw new Exception(
        'Unable to read link '.$this->getPathname()
      );
    }
    return $link;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.getrealpath.php )
   *
   * This method expands all symbolic links, resolves relative references
   * and returns the real path to the file.
   *
   * @return     mixed   Returns the path to the file.
   */
  public function getRealPath() {
    return realpath($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.tostring.php )
   *
   * This method will return the file name of the referenced file.
   *
   * @return     mixed   Returns the path to the file.
   */
  public function __toString() {
    return $this->getPathname();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.openfile.php )
   *
   * Creates an SplFileObject object of the file. This is useful because
   * SplFileObject contains additional methods for manipulating the file
   * whereas SplFileInfo is only useful for gaining information, like whether
   * the file is writable.
   *
   * @mode       mixed   The mode for opening the file. See the fopen()
   *                     documentation for descriptions of possible modes.
   *                     The default is read only.
   * @use_include_path
   *             mixed   When set to TRUE, the filename is also searched for
   *                     within the include_path
   * @context    mixed   Refer to the context section of the manual for a
   *                     description of contexts.
   *
   * @return     mixed   The opened file as an SplFileObject object.
   */
  public function openFile($mode = 'r', $use_include_path = false,
                           $context = null) {
    $class_name = $this->fileClass;
    return new $class_name(
      $this->getPathname(),
      $mode,
      $use_include_path,
      $context
    );
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.setfileclass.php )
   *
   * Set the class name which SplFileInfo will use to open files with when
   * openFile() is called. The class name passed to this method must be
   * derived from SplFileObject.
   *
   * @class_name mixed   The class name to use when openFile() is called.
   *
   * @return     mixed   No value is returned.
   */
  public function setFileClass($class_name = "SplFileObject") {
    if (!is_a($class_name, "SplFileObject", true)) {
      throw new UnexpectedValueException(
        "SplFileInfo::setFileClass() expects parameter 1 to be a class name ".
        "derived from SplFileObject, '$class_name' given"
      );
    }
    $this->fileClass = $class_name;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileinfo.setinfoclass.php )
   *
   * Use this method to set a custom class which will be used when
   * getFileInfo and getPathInfo are called. The class name passed to this
   * method must be derived from SplFileInfo.
   *
   * @class_name mixed   The class name to use.
   *
   * @return     mixed   No value is returned.
   */
  public function setInfoClass($class_name = "SplFileInfo") {
    if (!is_a($class_name, "SplFileInfo", true)) {
      throw new UnexpectedValueException(
        "SplFileInfo::setInfoClass() expects parameter 1 to be a class name ".
        "derived from SplFileInfo, '$class_name' given"
      );
    }
    $this->infoClass = $class_name;
  }

  protected function setPathname($file_name) {
    if ($file_name !== false) {
      $file_name = rtrim($file_name, '/');
    }
    $this->fileName = $file_name;
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.seekableiterator.php )
 *
 * The Seekable iterator.
 *
 */
interface SeekableIterator extends \HH\Iterator {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/seekableiterator.seek.php )
   *
   * Seeks to a given position in the iterator.
   *
   * @position   mixed   The position to seek to.
   *
   * @return     mixed   No value is returned.
   */
  public function seek($position);
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.directoryiterator.php )
 *
 * The DirectoryIterator class provides a simple interface for viewing the
 * contents of filesystem directories.
 *
 */
class DirectoryIterator extends SplFileInfo implements SeekableIterator {

  private $dir;
  private $dirName;
  private $index;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/directoryiterator.construct.php
   * )
   *
   * Constructs a new directory iterator from a path.
   *
   * @path       mixed   The path of the directory to traverse.
   */
  public function __construct($path) {
    if (empty($path)) {
      throw new RuntimeException("Directory name must not be empty.");
    }
    $this->dir = @opendir($path);
    if ($this->dir === false) {
      throw new UnexpectedValueException(
        "DirectoryIterator::__construct($path): failed to open dir"
      );
    }
    $this->dirName = rtrim($path, DIRECTORY_SEPARATOR);
    $this->index = 0;
    parent::__construct($this->readDir());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/directoryiterator.current.php )
   *
   * Get the current DirectoryIterator item.
   *
   * @return     mixed   The current DirectoryIterator item.
   */
  public function current() {
    return clone $this;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/directoryiterator.key.php )
   *
   * Get the key for the current DirectoryIterator item.
   *
   * @return     mixed   The key for the current DirectoryIterator item.
   */
  public function key() {
    return $this->index;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/directoryiterator.next.php )
   *
   * Move forward to the next DirectoryIterator item.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    $this->setPathname($this->readDir());
    $this->index++;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/directoryiterator.rewind.php )
   *
   * Rewind the DirectoryIterator back to the start.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    rewinddir($this->dir);
    $this->index = -1;
    $this->next();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/directoryiterator.seek.php )
   *
   * Seek to a given position in the DirectoryIterator.
   *
   * @position   mixed   The zero-based numeric position to seek to.
   *
   * @return     mixed   No value is returned.
   */
  public function seek($position) {
    $this->rewind();
    for ($i = $this->index; $i < $position; $i++) {
      $this->next();
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/directoryiterator.tostring.php )
   *
   * Get the file name of the current DirectoryIterator item.
   *
   * @return     mixed   Returns the file name of the current
   *                     DirectoryIterator item.
   */
  public function __toString() {
    return $this->getFilename();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/directoryiterator.valid.php )
   *
   * Check whether current DirectoryIterator position is a valid file.
   *
   * @return     mixed   Returns TRUE if the position is valid, otherwise
   *                     FALSE
   */
  public function valid() {
    return $this->getPathname() !== false;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/directoryiterator.isdot.php )
   *
   * Determines if the current DirectoryIterator item is a directory and
   * either . or ...
   *
   * @return     mixed   TRUE if the entry is . or .., otherwise FALSE
   */
  public function isDot() {
    return $this->getPathname() !== false && (
      $this->getFilename() == '.' || $this->getFilename() == '..'
    );
  }

  private function readDir() {
    // hh_readdir will set $this->dirName if necessary
    $file_name = $this->hh_readdir();
    if ($file_name === false) {
      return false;
    } else {
      return $this->dirName.DIRECTORY_SEPARATOR.$file_name;
    }
  }

  <<__Native>>
  private function hh_readdir(): mixed;

}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.filesystemiterator.php )
 *
 * The Filesystem iterator
 *
 */
class FilesystemIterator extends DirectoryIterator {

  const CURRENT_AS_PATHNAME = 32;
  const CURRENT_AS_FILEINFO = 0;
  const CURRENT_AS_SELF = 16;
  const CURRENT_MODE_MASK = 240;
  const KEY_AS_PATHNAME = 0;
  const KEY_AS_FILENAME = 256;
  const FOLLOW_SYMLINKS = 512;
  const KEY_MODE_MASK = 3840;
  const NEW_CURRENT_AND_KEY = 256;
  const SKIP_DOTS = 4096;
  const UNIX_PATHS = 8192;

  protected $flags;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filesystemiterator.construct.php
   * )
   *
   * Constructs a new filesystem iterator from the path.
   *
   * @path       mixed   The path of the filesystem item to be iterated over.
   * @flags      mixed   Flags may be provided which will affect the behavior
   *                     of some methods. A list of the flags can found under
   *                     FilesystemIterator predefined constants. They can
   *                     also be set later with
   *                     FilesystemIterator::setFlags()
   *
   * @return     mixed   No value is returned.
   */
  public function __construct($path, $flags = null) {
    parent::__construct($path);
    if ($flags === null) {
      $flags = FilesystemIterator::KEY_AS_PATHNAME |
               FilesystemIterator::CURRENT_AS_FILEINFO |
               FilesystemIterator::SKIP_DOTS;
    }
    $this->flags = $flags;
    $this->goPastDotsIfNeeded();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filesystemiterator.current.php )
   *
   * Get file information of the current element.
   *
   * @return     mixed   The filename, file information, or $this depending
   *                     on the set flags. See the FilesystemIterator
   *                     constants.
   */
  public function current() {
    if ($this->flags & FilesystemIterator::CURRENT_AS_PATHNAME) {
      return $this->getPathname();
    } else if ($this->flags & FilesystemIterator::CURRENT_AS_SELF) {
      return $this;
    }
    // FilesystemIterator::CURRENT_AS_FILEINFO == 0
    return new SplFileInfo($this->getPathname());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filesystemiterator.getflags.php
   * )
   *
   * Gets the handling flags, as set in FilesystemIterator::__construct() or
   * FilesystemIterator::setFlags().
   *
   * @return     mixed   The integer value of the set flags.
   */
  public function getFlags() {
    return $this->flags;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filesystemiterator.key.php )
   *
   *
   * @return     mixed   Returns the pathname or filename depending on the
   *                     set flags. See the FilesystemIterator constants.
   */
  public function key() {
    if ($this->flags & FilesystemIterator::KEY_AS_FILENAME) {
      return $this->getFilename();
    }
    // FilesystemIterator::KEY_AS_PATHNAME == 0
    return $this->getPathname();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filesystemiterator.next.php )
   *
   * Move to the next file.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    parent::next();
    $this->goPastDotsIfNeeded();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filesystemiterator.rewind.php )
   *
   * Rewinds the directory back to the start.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    parent::rewind();
    $this->goPastDotsIfNeeded();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filesystemiterator.setflags.php
   * )
   *
   * Sets handling flags.
   *
   * @flags      mixed   The handling flags to set. See the
   *                     FilesystemIterator constants.
   *
   * @return     mixed   No value is returned.
   */
  public function setFlags(int $flags) {
    $this->flags = $flags;
  }

  private function goPastDotsIfNeeded() {
    if ($this->flags & FilesystemIterator::SKIP_DOTS) {
      $f = parent::current();
      while ($f && $f->isDot()) {
        parent::next();
        $f = parent::current();
      }
    }
  }

  public function __toString() {
    return $this->getPathname();
  }
}
}

namespace {

class GlobIterator extends FilesystemIterator
  implements SeekableIterator, Countable {

  public function __construct($path, $flags = null) {
    if (is_null($flags)) {
      $flags = FilesystemIterator::KEY_AS_PATHNAME |
        FilesystemIterator::CURRENT_AS_FILEINFO;
    }
    // prepend the "glob://" prefix if it isn't there
    $prefix = 'glob://';
    $prefix_len = strlen($prefix);

    if (strncmp($path, $prefix, $prefix_len) !== 0) {
      $path = $prefix . $path;
    }

    parent::__construct($path, $flags);
  }

  <<__Native>>
  public function count(): int;
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://docs.hhvm.com/manual/en/class.recursivedirectoryiterator.php )
 *
 * The RecursiveDirectoryIterator provides an interface for iterating
 * recursively over filesystem directories.
 *
 */
class RecursiveDirectoryIterator extends FilesystemIterator
  implements RecursiveIterator {

  const FOLLOW_SYMLINKS = 512;

  private $subPath;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivedirectoryiterator.construct.php )
   *
   * Constructs a RecursiveDirectoryIterator() for the provided path.
   *
   * @path       mixed   The path of the directory to be iterated over.
   * @flags      mixed   Flags may be provided which will affect the behavior
   *                     of some methods. A list of the flags can found under
   *                     FilesystemIterator predefined constants. They can
   *                     also be set later with
   *                     FilesystemIterator::setFlags().
   *
   * @return     mixed   Returns the newly created
   *                     RecursiveDirectoryIterator.
   */
  public function __construct($path, $flags = null) {
    if ($flags === null) {
      $flags = FilesystemIterator::KEY_AS_PATHNAME |
               FilesystemIterator::CURRENT_AS_FILEINFO;
    }
    parent::__construct($path, $flags);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivedirectoryiterator.haschildren.php )
   *
   *
   * @return     mixed   Returns whether the current entry is a directory,
   *                     but not '.' or '..'
   */
  public function hasChildren() {
    if ($this->isDot()) {
      return false;
    }
    if (is_link($this->getPathname()) &&
        !($this->flags & self::FOLLOW_SYMLINKS)) {
      return false;
    }
    return $this->isDir();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivedirectoryiterator.getchildren.php )
   *
   *
   * @return     mixed   The filename, file information, or $this depending
   *                     on the set flags. See the FilesystemIterator
   *                     constants.
   */
  public function getChildren() {
    if ($this->getFlags() & FilesystemIterator::CURRENT_AS_PATHNAME) {
      return $this->current();
    }
    $child = new static($this->getPathname(), $this->getFlags());
    $child->subPath = $this->subPath;
    if ($child->subPath) {
      $child->subPath .= DIRECTORY_SEPARATOR;
    }
    $child->subPath .= $this->getBasename();
    return $child;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivedirectoryiterator.getsubpath.php )
   *
   * Gets the sub path. Warning: This function is currently not documented;
   * only its argument list is available.
   *
   * @return     mixed   The sub path (sub directory).
   */
  public function getSubPath() {
    return $this->subPath;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivedirectoryiterator.getsubpathname.php )
   *
   * Gets the sub path and filename. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   The sub path (sub directory) and filename.
   */
  public function getSubPathname() {
    return ($this->subPath ? $this->subPath . DIRECTORY_SEPARATOR : '') .
      $this->getFilename();
  }

}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.splfileobject.php )
 *
 * The SplFileObject class offers an object oriented interface for a file.
 *
 */
class SplFileObject extends SplFileInfo
  implements RecursiveIterator, SeekableIterator {

  const DROP_NEW_LINE = 1;
  const READ_AHEAD = 2;
  const SKIP_EMPTY = 4;
  const READ_CSV = 8;

  private $delimiter = ',';
  private $enclosure = '"';
  private $escape = '\\';
  private $flags;
  private $filename;
  private $maxLineLen = 0;
  private $currentLineNum = 0;
  private $rsrc;
  private $currentLine = false;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.construct.php )
   *
   * Construct a new file object.
   *
   * @filename   mixed   The file to read. TipA URL can be used as a filename
   *                     with this function if the fopen wrappers have been
   *                     enabled. See fopen() for more details on how to
   *                     specify the filename. See the Supported Protocols
   *                     and Wrappers for links to information about what
   *                     abilities the various wrappers have, notes on their
   *                     usage, and information on any predefined variables
   *                     they may provide.
   * @open_mode  mixed   The mode in which to open the file. See fopen() for
   *                     a list of allowed modes.
   * @use_include_path
   *             mixed   Whether to search in the include_path for filename.
   * @context    mixed   A valid context resource created with
   *                     stream_context_create().
   *
   * @return     mixed   No value is returned.
   */
  public function __construct($filename, $open_mode = 'r',
                              $use_include_path = false,
                              $context = null) {
    if (is_string($filename) && empty($filename)) {
      throw new RuntimeException(
        __METHOD__."({$filename}): Filename cannot be empty"
      );
    }
    if (!is_string($open_mode)) {
      throw new Exception(
        'SplFileObject::__construct() expects parameter 2 to be string, '.
        gettype($open_mode).' given'
      );
    }
    parent::__construct($filename);
    $this->filename = $filename;
    $this->rsrc = @fopen($filename, $open_mode, $use_include_path, $context);
    if (false === $this->rsrc) {
      throw new RuntimeException(
        __METHOD__.
        "({$filename}): failed to open stream: No such file or directory"
      );
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.eof.php )
   *
   * Determine whether the end of file has been reached
   *
   * @return     mixed   Returns TRUE if file is at EOF, FALSE otherwise.
   */
  public function eof() {
    return feof($this->rsrc);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.fflush.php )
   *
   * Forces a write of all buffered output to the file.
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function fflush() {
    return fflush($this->rsrc);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.fgetc.php )
   *
   * Gets a character from the file.
   *
   * @return     mixed   Returns a string containing a single character read
   *                     from the file or FALSE on EOF. Warning: This
   *                     function may return Boolean FALSE, but may also
   *                     return a non-Boolean value which evaluates to FALSE.
   *                     Please read the section on Booleans for more
   *                     information. Use the === operator for testing the
   *                     return value of this function.
   */
  public function fgetc() {
    $char = fgetc($this->rsrc);
    if ($char == "\n") {
      $this->currentLineNum++;
    }
    return $char;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.fgetcsv.php )
   *
   * Gets a line from the file which is in CSV format and returns an array
   * containing the fields read.
   *
   * @delimiter  mixed   The field delimiter (one character only). Defaults
   *                     as a comma or the value set using
   *                     SplFileObject::setCsvControl().
   * @enclosure  mixed   The field enclosure character (one character only).
   *                     Defaults as a double quotation mark or the value set
   *                     using SplFileObject::setCsvControl().
   * @escape     mixed   The escape character (one character only). Defaults
   *                     as a backslash (\) or the value set using
   *                     SplFileObject::setCsvControl().
   *
   * @return     mixed   Returns an indexed array containing the fields read,
   *                     or FALSE on error.
   *
   *                     A blank line in a CSV file will be returned as an
   *                     array comprising a single NULL field unless using
   *                     SplFileObject::SKIP_EMPTY |
   *                     SplFileObject::DROP_NEW_LINE, in which case empty
   *                     lines are skipped.
   */
  public function fgetcsv(
      $delimiter = null,
      $enclosure = null,
      $escape = null) {
    $num_args = func_num_args();
    if ($num_args < 3) {
      $escape = $this->escape;

      if ($num_args < 2) {
        $enclosure = $this->enclosure;

        if ($num_args < 1) {
          $delimiter = $this->delimiter;
        }
      }
    }

    if (!$this->checkCsvControl($delimiter, $enclosure, $escape)) {
      return false;
    }

    do {
      $ret = fgetcsv(
        $this->rsrc,
        $this->maxLineLen,
        $delimiter,
        $enclosure,
        $escape,
      );
    } while($this->getFlags() & (self::SKIP_EMPTY | self::DROP_NEW_LINE) &&
            $ret !== false && $ret[0] === null);
    return $ret;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.fgets.php )
   *
   * Gets a line from the file.
   *
   * @return     mixed   Returns a string containing the next line from the
   *                     file, or FALSE on error.
   */
  public function fgets() {
    if(false !== $this->currentLine) {
      $this->next();
    }

    return $this->currentLine = $this->getCurrentLineImpl();
  }

  public function getCurrentLine() {
    return $this->fgets();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.fgetss.php )
   *
   * Identical to SplFileObject::fgets(), except that
   * SplFileObject::fgetss() attempts to strip any HTML and PHP tags from the
   * text it reads.
   *
   * @allowable_tags
   *             mixed   Optional parameter to specify tags which should not
   *                     be stripped.
   *
   * @return     mixed   Returns a string containing the next line of the
   *                     file with HTML and PHP code stripped, or FALSE on
   *                     error.
   */
  public function fgetss($allowable_tags = null) {
    return fgetss($this->rsrc, $this->maxLineLen, $allowable_tags);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.flock.php )
   *
   * Locks or unlocks the file in the same portable way as flock().
   *
   * @operation  mixed   operation is one of the following: LOCK_SH to
   *                     acquire a shared lock (reader). LOCK_EX to acquire
   *                     an exclusive lock (writer). LOCK_UN to release a
   *                     lock (shared or exclusive). LOCK_NB to not block
   *                     while locking (not supported on Windows).
   * @wouldblock mixed   Set to TRUE if the lock would block (EWOULDBLOCK
   *                     errno condition).
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function flock($operation, &$wouldblock = false) {
    return flock($this->rsrc, $operation, $wouldblock);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.fpassthru.php )
   *
   * Reads to EOF on the given file pointer from the current position and
   * writes the results to the output buffer.
   *
   * You may need to call SplFileObject::rewind() to reset the file pointer
   * to the beginning of the file if you have already written data to the
   * file.
   *
   * @return     mixed   Returns the number of characters read from handle
   *                     and passed through to the output.
   */
  public function fpassthru() {
    return fpassthru($this->rsrc);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.fputcsv.php )
   *
   * Writes the fields array to the file as a CSV line.
   *
   * @fields     mixed   An array of values.
   * @delimiter  mixed   The optional delimiter parameter sets the field
   *                     delimiter (one character only).
   * @enclosure  mixed   The optional enclosure parameter sets the field
   *                     enclosure (one character only).
   *
   * @return     mixed   Returns the length of the written string or FALSE on
   *                     failure.
   *
   *                     Returns FALSE, and does not write the CSV line to
   *                     the file, if the delimiter or enclosure parameter is
   *                     not a single character.
   */
  public function fputcsv($fields, $delimiter = null, $enclosure = null) {
    $num_args = func_num_args();
    if ($num_args < 3) {
      $enclosure = $this->enclosure;

      if ($num_args < 2) {
        $delimiter = $this->delimiter;
      }
    }

    if (!$this->checkCsvControl($delimiter, $enclosure)) {
      return false;
    }

    return fputcsv(
      $this->rsrc,
      $fields,
      $delimiter,
      $enclosure
    );
  }

  public function fread($length) {
    return fread($this->rsrc, $length);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.fscanf.php )
   *
   * Reads a line from the file and interprets it according to the specified
   * format, which is described in the documentation for sprintf().
   *
   * Any whitespace in the format string matches any whitespace in the line
   * from the file. This means that even a tab \t in the format string can
   * match a single space character in the input stream.
   *
   * @format     mixed   The specified format as described in the sprintf()
   *                     documentation.
   *
   * @return     mixed   If only one parameter is passed to this method, the
   *                     values parsed will be returned as an array.
   *                     Otherwise, if optional parameters are passed, the
   *                     function will return the number of assigned values.
   *                     The optional parameters must be passed by reference.
   */
  public function fscanf($format) {
    $argv = array($this->rsrc);
    for ($i = 0; $i < func_num_args(); $i++) {
      $argv[] = func_get_arg($i);
    }
    return call_user_func_array('fscanf', $argv);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.fseek.php )
   *
   * Seek to a position in the file measured in bytes from the beginning of
   * the file, obtained by adding offset to the position specified by whence.
   *
   * @offset     mixed   The offset. A negative value can be used to move
   *                     backwards through the file which is useful when
   *                     SEEK_END is used as the whence value.
   * @whence     mixed   whence values are: SEEK_SET - Set position equal to
   *                     offset bytes. SEEK_CUR - Set position to current
   *                     location plus offset. SEEK_END - Set position to
   *                     end-of-file plus offset.
   *
   *                     If whence is not specified, it is assumed to be
   *                     SEEK_SET.
   *
   * @return     mixed   Returns 0 if the seek was successful, -1 otherwise.
   *                     Note that seeking past EOF is not considered an
   *                     error.
   */
  public function fseek($offset, $whence = SEEK_SET) {
    return fseek($this->rsrc, $offset, $whence);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.fstat.php )
   *
   * Gathers the statistics of the file. Behaves identically to fstat().
   *
   * @return     mixed   Returns an array with the statistics of the file;
   *                     the format of the array is described in detail on
   *                     the stat() manual page.
   */
  public function fstat() {
    return fstat($this->rsrc);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.ftell.php )
   *
   * Returns the position of the file pointer which represents the current
   * offset in the file stream.
   *
   * @return     mixed   Returns the position of the file pointer as an
   *                     integer, or FALSE on error.
   */
  public function ftell() {
    return ftell($this->rsrc);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.ftruncate.php )
   *
   * Truncates the file to size bytes.
   *
   * @size       mixed   The size to truncate to.
   *
   *                     If size is larger than the file it is extended with
   *                     null bytes.
   *
   *                     If size is smaller than the file, the extra data
   *                     will be lost.
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function ftruncate($size) {
    return ftruncate($this->rsrc, $size);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.fwrite.php )
   *
   * Writes the contents of string to the file
   *
   * @str        mixed   The string to be written to the file.
   * @length     mixed   If the length argument is given, writing will stop
   *                     after length bytes have been written or the end of
   *                     string is reached, whichever comes first.
   *
   * @return     mixed   Returns the number of bytes written, or NULL on
   *                     error.
   */
  public function fwrite($str, $length = 0) {
    return fwrite($this->rsrc, $str, $length);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.getchildren.php )
   *
   * An SplFileObject does not have children so this method returns NULL.
   *
   * @return     mixed   No value is returned.
   */
  public function getChildren() {
    return null; // An SplFileOjbect does not have children
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.getcsvcontrol.php
   * )
   *
   * Gets the delimiter and enclosure character used for parsing CSV fields.
   *
   * @return     mixed   Returns an indexed array containing the delimiter
   *                     and enclosure character.
   */
  public function getCsvControl() {
    return array($this->delimiter, $this->enclosure);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.getflags.php )
   *
   * Gets the flags set for an instance of SplFileObject as an integer.
   *
   * @return     mixed   Returns an integer representing the flags.
   */
  public function getFlags() {
    return $this->flags;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.getmaxlinelen.php
   * )
   *
   * Gets the maximum line length as set by SplFileObject::setMaxLineLen().
   *
   * @return     mixed   Returns the maximum line length if one has been set
   *                     with SplFileObject::setMaxLineLen(), default is 0.
   */
  public function getMaxLineLen() {
    return $this->maxLineLen;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.haschildren.php )
   *
   * An SplFileObject does not have children so this method always return
   * FALSE.
   *
   * @return     mixed   Returns FALSE
   */
  public function hasChildren() {
    return false; // An SplFileOjbect does not have children
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.setcsvcontrol.php
   * )
   *
   * Sets the delimiter and enclosure character for parsing CSV fields.
   *
   * @delimiter  mixed   The field delimiter (one character only).
   * @enclosure  mixed   The field enclosure character (one character only).
   * @escape     mixed   The field escape character (one character only).
   *
   * @return     mixed   No value is returned.
   */
  public function setCsvControl(
      $delimiter = ",",
      $enclosure = "\"",
      $escape = "\\") {
    if (!$this->checkCsvControl($delimiter, $enclosure, $escape)) {
      return;
    }

    $this->delimiter = $delimiter;
    $this->enclosure = $enclosure;
    $this->escape = $escape;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.setflags.php )
   *
   * Sets the flags to be used by the SplFileObject.
   *
   * @flags      mixed   Bit mask of the flags to set. See SplFileObject
   *                     constants for the available flags.
   *
   * @return     mixed   No value is returned.
   */
  public function setFlags($flags) {
    $this->flags = $flags;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.setmaxlinelen.php
   * )
   *
   * Sets the maximum length of a line to be read.
   *
   * @max_len    mixed   The maximum length of a line.
   *
   * @return     mixed   No value is returned.
   */
  public function setMaxLineLen($max_len) {
    if ($max_len < 0) {
      throw new DomainException(
        'Maximum line length must be greater than or equal zero'
      );
    }
    $this->maxLineLen = $max_len;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.current.php )
   *
   * Retrieves the current line of the file.
   *
   * @return     mixed   Retrieves the current line of the file. If the
   *                     SplFileObject::READ_CSV flag is set, this method
   *                     returns an array containing the current line parsed
   *                     as CSV data.
   */
  public function current() {
    if ($this->currentLine === false) {
      if (($this->flags & SplFileObject::READ_CSV) == SplFileObject::READ_CSV) {
        $this->currentLine = $this->fgetcsv(
          $this->delimiter,
          $this->enclosure,
          $this->escape
        );
      } else {
        $this->currentLine = $this->getCurrentLineImpl();
      }
    }
    return $this->currentLine;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.key.php )
   *
   * Gets the current line number.
   *
   * This number may not reflect the actual line number in the file if
   * SplFileObject::setMaxLineLen() is used to read fixed lengths of the
   * file.
   *
   * @return     mixed   Returns the current line number.
   */
  public function key() {
    return $this->currentLineNum;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.next.php )
   *
   * Moves ahead to the next line in the file.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    $this->currentLine = false;
    $this->currentLineNum++;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.rewind.php )
   *
   * Rewinds the file back to the first line.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    rewind($this->rsrc);
    $this->currentLineNum = 0;
    $this->currentLine = false;
    if ($this->flags & self::READ_AHEAD) {
      $this->current();
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.seek.php )
   *
   * Seek to specified line in the file.
   *
   * @line_pos   mixed   The zero-based line number to seek to.
   *
   * @return     mixed   No value is returned.
   */
  public function seek($line_pos) {
    if ($line_pos < 0) {
      throw new LogicException("Can't seek file " .
        $this->filename . " to negative line $line_pos");
    }
    $this->rewind();
    for ($i = 0; $i < $line_pos; $i++) {
      $this->current();
      $this->next();
      if ($this->eof()) {
        $this->currentLineNum--;
        break;
      }
    }
    $this->current();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfileobject.valid.php )
   *
   * Check whether EOF has been reached.
   *
   * @return     mixed   Returns TRUE if not reached EOF, FALSE otherwise.
   */
  public function valid() {
    if ($this->flags & self::READ_AHEAD) {
      return $this->current() !== false;
    }
    return !$this->eof();
  }

  private function checkCsvParameter($value, $name) {
    if (!is_string($value) || strlen($value) != 1) {
      error_log("\nWarning: ".$name.' must be a character');
      return false;
    }
    return true;
  }

  private function checkCsvControl($delimiter, $enclosure, $escape = null) {
    if (!$this->checkCsvParameter($delimiter, 'delimiter') ||
        !$this->checkCsvParameter($enclosure, 'enclosure') ||
        func_num_args() > 2 && !$this->checkCsvParameter($escape, 'escape')) {
      return false;
    }

    return true;
  }

  private function getCurrentLineImpl()
  {
    do {
      $line = fgets($this->rsrc, $this->maxLineLen);
    } while($this->getFlags() & (self::SKIP_EMPTY | self::DROP_NEW_LINE) &&
            $line !== false && rtrim($line) === "");
    if ($line !== false && $this->flags & self::DROP_NEW_LINE) {
      $line = rtrim($line);
    }

    return $line;
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.spltempfileobject.php )
 *
 * The SplTempFileObject class offers an object oriented interface for a
 * temporary file.
 *
 */
class SplTempFileObject extends SplFileObject {

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spltempfileobject.construct.php
   * )
   *
   * Construct a new temporary file object.
   *
   * @maxMemory  mixed   The maximum amount of memory (in bytes, default is 2
   *                     MB) for the temporary file to use. If the temporary
   *                     file exceeds this size, it will be moved to a file
   *                     in the system's temp directory.
   *
   *                     If max_memory is negative, only memory will be
   *                     used. If max_memory is zero, no memory will be used.
   *
   * @return     mixed   No value is returned.
   */
  public function __construct($maxMemory = null) {
    if ($maxMemory === null) {
      parent::__construct('php://temp', 'r+');
    } else {
      parent::__construct("php://temp/maxmemory:$maxMemory", 'r+');
    }
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.arrayaccess.php )
 *
 * Interface to provide accessing objects as arrays.
 *
 */
interface ArrayAccess {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayaccess.offsetexists.php )
   *
   * Whether or not an offset exists.
   *
   * This method is executed when using isset() or empty() on objects
   * implementing ArrayAccess.
   *
   * When using empty() ArrayAccess::offsetGet() will be called and checked
   * if empty only if ArrayAccess::offsetExists() returns TRUE.
   *
   * @index      mixed   An offset to check for.
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   *
   *                     The return value will be casted to boolean if
   *                     non-boolean was returned.
   */
  public function offsetExists($index);
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayaccess.offsetget.php )
   *
   * Returns the value at specified offset.
   *
   * This method is executed when checking if offset is empty().
   *
   * @index      mixed   The offset to retrieve.
   *
   * @return     mixed   Can return all value types.
   */
  public function offsetGet($index);
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayaccess.offsetset.php )
   *
   * Assigns a value to the specified offset.
   *
   * @index      mixed   The offset to assign the value to.
   * @newvalue   mixed   The value to set.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetSet($index, $newvalue);
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayaccess.offsetunset.php )
   *
   * Unsets an offset.
   *
   * This method will not be called when type-casting to (unset)
   *
   * @index      mixed   The offset to unset.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetUnset($index);
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.serializable.php )
 *
 * Interface for customized serializing.
 *
 * Classes that implement this interface no longer support __sleep() and
 * __wakeup(). The method serialize is called whenever an instance needs to
 * be serialized. This does not invoke __destruct() or has any other side
 * effect unless programmed inside the method. When the data is
 * unserialized the class is known and the appropriate unserialize() method
 * is called as a constructor instead of calling __construct(). If you need
 * to execute the standard constructor you may do so in the method.
 *
 */
interface Serializable {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/serializable.serialize.php )
   *
   * Should return the string representation of the object.
   *
   * This method acts as the destructor of the object. The __destruct()
   * method will not be called after this method.
   *
   * @return     mixed   Returns the string representation of the object or
   *                     NULL
   */
  public function serialize();
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/serializable.unserialize.php )
   *
   * Called during unserialization of the object.
   *
   * This method acts as the constructor of the object. The __construct()
   * method will not be called after this method.
   *
   * @serialized mixed   The string representation of the object.
   *
   * @return     mixed   The return value from this method is ignored.
   */
  public function unserialize($serialized);
}
}

namespace {

class _SplDoublyLinkedListNode {
  public $data = null;
  public $next = null;
  public $prev = null;

  public function getNext($fifo = true) {
    return $fifo ? $this->next : $this->prev;
  }

  public function getPrev($fifo = true) {
    return $fifo ? $this->prev : $this->next;
  }
}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.spldoublylinkedlist.php )
 *
 * The SplDoublyLinkedList class provides the main functionalities of a
 * doubly linked list.
 *
 */
class SplDoublyLinkedList
  implements \HH\Iterator, ArrayAccess, Countable, Serializable {

  const IT_MODE_LIFO = 2;
  const IT_MODE_FIFO = 0;
  const IT_MODE_DELETE = 1;
  const IT_MODE_KEEP = 0;

  protected $head = null;
  protected $tail = null;
  protected $key = 0;
  protected $current = null;
  protected $count = 0;
  protected $mode = 0;

  public function add($index, $value) {
    if ((!is_int($index) && !is_numeric($index)) ||
        $index < 0 || $index > $this->count()) {
      throw new OutOfRangeException(
        "Offset invalid or out of range"
      );
    }
    if ($index == $this->count()) {
      // End of list, simply push it
      $this->push($value);
    } else {
      $pos = $this->head;
      for ($i = 0; $i < $index; ++$i) {
        // Fetch element to insert before
        $pos = $pos->next;
      }
      $node = new _SplDoublyLinkedListNode;
      $node->data = $value;
      $node->prev = $pos->prev;
      $node->next = $pos;
      if ($node->prev === null) {
        $this->head = $node;
      } else {
        $pos->prev->next = $node;
      }
      $pos->prev = $node;
      ++$this->count;
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.bottom.php )
   *
   *
   * @return     mixed   The value of the first node.
   */
  public function bottom() {
    if ($this->head === null) {
      throw new RuntimeException("Can't shift from an empty datastructure");
    }
    return $this->head->data;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.top.php )
   *
   *
   * @return     mixed   The value of the last node.
   */
  public function top() {
    if ($this->tail === null) {
      throw new RuntimeException("Can't pop from an empty datastructure");
    }
    return $this->tail->data;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.isempty.php
   * )
   *
   *
   * @return     mixed   Returns whether the doubly linked list is empty.
   */
  public function isEmpty() {
    return !$this->count;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.push.php )
   *
   * Pushes value at the end of the doubly linked list.
   *
   * @value      mixed   The value to push.
   *
   * @return     mixed   No value is returned.
   */
  public function push($value) {
    $node = new _SplDoublyLinkedListNode;
    $node->data = $value;

    if ($this->isEmpty()) {
      $this->head = $node;
    } else {
      $node->prev = $this->tail;
      $this->tail->next = $node;
    }
    $this->tail = $node;

    ++$this->count;
    return;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.pop.php )
   *
   *
   * @return     mixed   The value of the popped node.
   */
  public function pop() {
    $retval = $this->top();
    $this->tail = $this->tail->prev;
    if ($this->tail !== null) {
      $this->tail->next = null;
    }
    --$this->count;
    return $retval;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.unshift.php
   * )
   *
   * Prepends value at the beginning of the doubly linked list.
   *
   * @value      mixed   The value to unshift.
   *
   * @return     mixed   No value is returned.
   */
  public function unshift($value) {
    $node = new _SplDoublyLinkedListNode;
    $node->data = $value;

    if ($this->isEmpty()) {
      $this->head = $this->tail = $node;
    } else {
      $node->next = $this->head;
      $this->head->prev = $node;
      $this->head = $node;
    }

    ++$this->count;
    return;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.shift.php )
   *
   *
   * @return     mixed   The value of the shifted node.
   */
  public function shift() {
    $retval = $this->bottom();
    $this->head = $this->head->next;
    if ($this->head !== null) {
      $this->head->prev = null;
    }
    --$this->count;
    return $retval;
  }


  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.current.php
   * )
   *
   * Get the current doubly linked list node.
   *
   * @return     mixed   The current node value.
   */
  public function current() {
    if (!$this->valid()) {
      return null;
    }
    return $this->current->data;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.key.php )
   *
   * This function returns the current node index
   *
   * @return     mixed   The current node index.
   */
  public function key() {
    return $this->key;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.next.php )
   *
   * Move the iterator to the next node.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    if ($this->mode & self::IT_MODE_DELETE) {
      --$this->count;
      if ($this->current->prev !== null) {
        $this->current->prev->next = $this->current->next;
      }
      if ($this->current->next !== null) {
        $this->current->next->prev = $this->current->prev;
      }
      if ($this->current === $this->tail) {
        $this->tail = $this->current->prev;
      }
      if ($this->current === $this->head) {
        $this->head = $this->current->next;
      }
    }

    if ($this->mode & self::IT_MODE_LIFO) {
      --$this->key;
      $this->current = $this->current ? $this->current->prev : null;
    } else {
      if (!($this->mode & self::IT_MODE_DELETE)) {
        ++$this->key;
      }
      $this->current = $this->current ? $this->current->next : null;
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.prev.php )
   *
   * Move the iterator to the previous node.
   *
   * @return     mixed   No value is returned.
   */
  public function prev() {
    if ($this->mode & self::IT_MODE_DELETE) {
      --$this->count;
      if ($this->current->prev !== null) {
        $this->current->prev->next = $this->current->next;
      }
      if ($this->current->next !== null) {
        $this->current->next->prev = $this->current->prev;
      }
    }

    if ($this->mode & self::IT_MODE_LIFO) {
      if (!($this->mode & self::IT_MODE_DELETE)) {
        ++$this->key;
      }
      $this->current = $this->current ? $this->current->next : null;
    } else {
      --$this->key;
      $this->current = $this->current ? $this->current->prev : null;
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.rewind.php )
   *
   * This rewinds the iterator to the beginning.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    if ($this->mode & self::IT_MODE_LIFO) {
      $this->key = $this->count - 1;
      $this->current = $this->tail;
    } else {
      $this->key = 0;
      $this->current = $this->head;
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.valid.php )
   *
   * Checks if the doubly linked list contains any more nodes.
   *
   * @return     mixed   Returns TRUE if the doubly linked list contains any
   *                     more nodes, FALSE otherwise.
   */
  public function valid() {
    return $this->current !== null;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/spldoublylinkedlist.getiteratormode.php )
   *
   *
   * @return     mixed   Returns the different modes and flags that affect
   *                     the iteration.
   */
  public function getIteratorMode() {
    return $this->mode;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/spldoublylinkedlist.setiteratormode.php )
   *
   *
   * @mode       mixed   There are two orthogonal sets of modes that can be
   *                     set: The direction of the iteration (either one or
   *                     the other): SplDoublyLinkedList::IT_MODE_LIFO (Stack
   *                     style) SplDoublyLinkedList::IT_MODE_FIFO (Queue
   *                     style) The behavior of the iterator (either one or
   *                     the other): SplDoublyLinkedList::IT_MODE_DELETE
   *                     (Elements are deleted by the iterator)
   *                     SplDoublyLinkedList::IT_MODE_KEEP (Elements are
   *                     traversed by the iterator)
   *
   *                     The default mode is:
   *                     SplDoublyLinkedList::IT_MODE_FIFO |
   *                     SplDoublyLinkedList::IT_MODE_KEEP
   *
   * @return     mixed   No value is returned.
   */
  public function setIteratorMode($mode) {
    $this->mode = $mode;
  }


  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/spldoublylinkedlist.offsetexists.php )
   *
   *
   * @index      mixed   The index being checked.
   *
   * @return     mixed   TRUE if the requested index exists, otherwise FALSE
   */
  public function offsetExists($index) {
    return $index < $this->count;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/spldoublylinkedlist.offsetget.php )
   *
   *
   * @index      mixed   The index with the value.
   *
   * @return     mixed   The value at the specified index.
   */
  public function offsetGet($index) {
    if (!is_int($index) && !is_numeric($index)) {
      throw new OutOfRangeException("Offset invalid or out of range");
    }
    $node = ($this->mode & self::IT_MODE_LIFO) ? $this->tail : $this->head;
    for ($i = 0; $i < $index && $node !== null; ++$i) {
      $node = $node->getNext(!($this->mode & self::IT_MODE_LIFO));
    }
    if (!$node) {
      throw new OutOfRangeException("Offset invalid or out of range");
    }
    return $node->data;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/spldoublylinkedlist.offsetset.php )
   *
   * Sets the value at the specified index to newval.
   *
   * @index      mixed   The index being set.
   * @newval     mixed   The new value for the index.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetSet($index, $newval) {
    if ($index === null) {
      $this->push($newval);
      return;
    }
    if ($index < 0 || $index >= $this->count) {
      throw new OutOfRangeException("Offset invalid or out of range");
    }
    if ($this->isEmpty()) {
      $node = new _SplDoublyLinkedListNode;
      $this->head = $node;
      $this->tail = $node;
      ++$this->count;
    }
    $node = ($this->mode & self::IT_MODE_LIFO) ? $this->tail : $this->head;
    for ($i = 0; $i < $index; ++$i) {
      $node = $node->getNext(!($this->mode & self::IT_MODE_LIFO));
    }
    $node->data = $newval;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/spldoublylinkedlist.offsetunset.php )
   *
   * Unsets the value at the specified index.
   *
   * @index      mixed   The index being unset.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetUnset($index) {
    if (!is_int($index) && !is_numeric($index)) {
      throw new OutOfRangeException("Offset invalid or out of range");
    }
    if ($index < 0 || $index >= $this->count()) {
      throw new OutOfRangeException("Offset out of range");
    }
    $node = ($this->mode & self::IT_MODE_LIFO) ? $this->tail : $this->head;
    for ($i = 0; $i < $index; ++$i) {
      $node = $node->getNext(!($this->mode & self::IT_MODE_LIFO));
    }

    --$this->count;
    if ($node->prev) {
      $node->prev->next = $node->next;
    } else {
      $this->head = $node->next;
    }

    if ($node->next) {
      $node->next->prev = $node->prev;
    } else {
      $this->tail = $node->prev;
    }
  }


  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/spldoublylinkedlist.count.php )
   *
   *
   * @return     mixed   Returns the number of elements in the doubly linked
   *                     list.
   */
  public function count() {
    return $this->count;
  }


  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/spldoublylinkedlist.serialize.php )
   *
   * Serializes the storage. WarningThis function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   The serialized string.
   */
  public function serialize() {
    $data = array();
    foreach ($this as $val) {
      $data[] = $val;
    }
    return serialize(array($data, $this->mode));
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/spldoublylinkedlist.unserialize.php )
   *
   * Unserializes the storage, from SplDoublyLinkedList::serialize().
   * WarningThis function is currently not documented; only its argument list
   * is available.
   *
   * @serialized mixed   The serialized string.
   *
   * @return     mixed   No value is returned.
   */
  public function unserialize($serialized) {
    list($data, $this->mode) = unserialize($serialized);
    foreach ($data as $elem) {
      $this->push($elem);
    }
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * (excerpt from http://docs.hhvm.com/manual/en/class.splqueue.php)
 *
 * The SplQueue class provides the main functionalities of a queue
 * implemented using a doubly linked list.
 *
 */
class SplQueue extends SplDoublyLinkedList
  implements \HH\Iterator, ArrayAccess, Countable {

  // This doc comment block generated by idl/sysdoc.php
  /**
   * (excerpt from http://docs.hhvm.com/manual/en/splqueue.dequeue.php)
   *
   * Dequeues value from the top of the queue.
   *
   * SplQueue::dequeue() is an alias of SplDoublyLinkedList::shift().
   *
   * @return     mixed   The value of the dequeued node.
   */
  public function dequeue() {
    return $this->shift();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * (excerpt from http://docs.hhvm.com/manual/en/splqueue.enqueue.php)
   *
   * Enqueues value at the end of the queue.
   *
   * SplQueue::enqueue() is an alias of SplDoublyLinkedList::push().
   *
   * @value      mixed   The value to enqueue.
   *
   * @return     mixed   No value is returned.
   */
  public function enqueue($value) {
    $this->push($value);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * (excerpt from http://docs.hhvm.com/manual/en/splqueue.setiteratormode.php)
   *
   *
   * @mode       mixed   There is only one iteration parameter you can
   *                     modify. The behavior of the iterator (either one or
   *                     the other): SplDoublyLinkedList::IT_MODE_DELETE
   *                     (Elements are deleted by the iterator)
   *                     SplDoublyLinkedList::IT_MODE_KEEP (Elements are
   *                     traversed by the iterator)
   *
   *                     The default mode is:
   *                     SplDoublyLinkedList::IT_MODE_FIFO |
   *                     SplDoublyLinkedList::IT_MODE_KEEP Warning
   *
   *                     The direction of iteration can not be changed for
   *                     SplQueues, it is always
   *                     SplDoublyLinkedList::IT_MODE_FIFO.
   *
   * @return     mixed   No value is returned.
   */
  public function setIteratorMode($mode) {
    if ($mode & self::IT_MODE_LIFO) {
      throw new RuntimeException(
        'Iterators\' LIFO/FIFO modes for SplStack/SplQueue objects are frozen');
    }
    parent::setIteratorMode($mode);
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * (excerpt from http://docs.hhvm.com/manual/en/class.splstack.php)
 *
 * The SplStack class provides the main functionalities of a stack
 * implemented using a doubly linked list.
 *
 */
class SplStack extends SplDoublyLinkedList
  implements \HH\Iterator, ArrayAccess, Countable {

  // This doc comment block generated by idl/sysdoc.php
  /**
   * (excerpt from http://docs.hhvm.com/manual/en/splstack.construct.php)
   *
   * This constructs a new empty stack.
   *
   * This method automatically sets the iterator mode to
   * SplDoublyLinkedList::IT_MODE_LIFO.
   *
   * @return     mixed   No value is returned.
   */
  public function __construct() {
    $this->setIteratorMode(self::IT_MODE_LIFO | self::IT_MODE_KEEP);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * (excerpt from http://docs.hhvm.com/manual/en/splstack.setiteratormode.php)
   *
   *
   * @mode       mixed   There is only one iteration parameter you can
   *                     modify. The behavior of the iterator (either one or
   *                     the other): SplDoublyLinkedList::IT_MODE_DELETE
   *                     (Elements are deleted by the iterator)
   *                     SplDoublyLinkedList::IT_MODE_KEEP (Elements are
   *                     traversed by the iterator)
   *
   *                     The default mode is 0x2 :
   *                     SplDoublyLinkedList::IT_MODE_LIFO |
   *                     SplDoublyLinkedList::IT_MODE_KEEP Warning
   *
   *                     The direction of iteration can no longer be changed
   *                     for SplStacks. Trying to do so will result in a
   *                     RuntimeException being thrown.
   *
   * @return     mixed   No value is returned.
   */
  public function setIteratorMode($mode) {
    if (($mode & self::IT_MODE_LIFO) == 0) {
      throw new RuntimeException(
        'Iterators\' LIFO/FIFO modes for SplStack/SplQueue objects are frozen');
    }
    parent::setIteratorMode($mode);
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.outeriterator.php )
 *
 * Classes implementing OuterIterator can be used to iterate over
 * iterators.
 *
 */
interface OuterIterator extends \HH\Iterator {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/outeriterator.getinneriterator.php )
   *
   * Returns the inner iterator for the current iterator entry.
   *
   * @return     mixed   The inner iterator for the current entry.
   */
  public function getInnerIterator();
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.iteratoriterator.php )
 *
 * This iterator wrapper allows the conversion of anything that is
 * Traversable into an Iterator. It is important to understand that most
 * classes that do not implement Iterators have reasons as most likely they
 * do not allow the full Iterator feature set. If so, techniques should be
 * provided to prevent misuse, otherwise expect exceptions or fatal errors.
 *
 */
class IteratorIterator implements OuterIterator {
  private $iterator;
  private $current;
  private $key;
  private $position;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iteratoriterator.construct.php )
   *
   * Creates an iterator from anything that is traversable.
   *
   * @iterator   mixed   The traversable iterator.
   *
   * @return     mixed   No value is returned.
   */
  public function __construct($iterator) {
    while ($iterator instanceof IteratorAggregate) {
      $iterator = $iterator->getIterator();
    }
    if ($iterator instanceof \Iterator) {
      $this->iterator = $iterator;
    } else if ($iterator instanceof \SimpleXMLElement) {
      $this->iterator = $iterator->getIterator();
    } else {
      throw new Exception(
        "Need to pass a Traversable that is convertable to an iterator");
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/iteratoriterator.getinneriterator.php )
   *
   * Get the inner iterator.
   *
   * @return     mixed   The inner iterator as passed to
   *                     IteratorIterator::__construct().
   */
  public function getInnerIterator() {
    return $this->iterator;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iteratoriterator.valid.php )
   *
   * Checks if the iterator is valid.
   *
   * @return     mixed   Returns TRUE if the iterator is valid, otherwise
   *                     FALSE
   */
  public function valid() {
    return $this->iterator->valid();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iteratoriterator.key.php )
   *
   * Get the key of the current element.
   *
   * @return     mixed   The key of the current element.
   */
  public function key() {
    return $this->key;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iteratoriterator.current.php )
   *
   * Get the value of the current element.
   *
   * @return     mixed   The value of the current element.
   */
  public function current() {
    return $this->current;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iteratoriterator.next.php )
   *
   * Forward to the next element.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    $this->iterator->next();
    $this->position++;
    $this->_fetch(true);
    return;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/iteratoriterator.rewind.php )
   *
   * Rewinds to the first element.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    $this->iterator->rewind();
    $this->position = 0;
    $this->_fetch(true);
    return;
  }

  public function __call($func, $params) {
    return call_user_func_array(array($this->iterator, $func), $params);
  }

  /**
   * This function appears in the php source in spl_iterators.c as
   * spl_dual_it_fetch. Apparently, all iterators that store other
   * iterators are forced to do this layer of caching. If you call
   * next(), these "dual" iterators will need to get the key and
   * current value out of the underlying iterator and store it.
   *
   * Basically, if you see a call to spl_dual_it_fetch in the
   * PHP source, it's very likely that you should call this.
   */
  protected function _fetch($check) {
    if (!$check || $this->iterator->valid()) {
      $this->current = $this->iterator->current();
      $key = $this->iterator->key();
      $this->key = is_null($key) ? $this->position : $key;
      return true;
    } else {
      $this->current = null;
      $this->key = null;
      return false;
    }
  }

  protected function _getPosition() {
    return $this->position;
  }

  protected function _setPosition($position) {
    $this->position = $position;
  }

}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.appenditerator.php )
 *
 * An Iterator that iterates over several iterators one after the other.
 *
 */
class AppendIterator extends IteratorIterator implements OuterIterator {
  private $iterators;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/appenditerator.construct.php )
   *
   * Constructs an AppendIterator.
   *
   * @return     mixed   No value is returned.
   */
  function __construct() {
    $this->iterators = new ArrayIterator(array());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/appenditerator.append.php )
   *
   * Appends an iterator.
   *
   * @it         mixed   The iterator to append.
   *
   * @return     mixed   No value is returned.
   */
  function append(\Iterator $it) {
    $it->rewind();
    $this->iterators->append($it);

    // if we will start at $it and $it is empty, advance our position past
    if ($this->iterators->current() === $it && !$it->valid()) {
      $this->iterators->next();
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/appenditerator.getarrayiterator.php )
   *
   * This method gets the ArrayIterator that is used to store the iterators
   * added with AppendIterator::append().
   *
   * @return     mixed   Returns an ArrayIterator containing the appended
   *                     iterators.
   */
  function getArrayIterator() {
    return $this->iterators;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/appenditerator.getiteratorindex.php )
   *
   * Gets the index of the current inner iterator.
   *
   * @return     mixed   Returns an integer, which is the zero-based index of
   *                     the current inner iterator.
   */
  function getIteratorIndex() {
    return $this->iterators->key();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/appenditerator.getinneriterator.php )
   *
   * This method returns the current inner iterator.
   *
   * @return     mixed   The current inner iterator, or NULL if there is not
   *                     one.
   */
  function getInnerIterator() {
    return $this->iterators->current();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/appenditerator.rewind.php )
   *
   * Rewind to the first element of the first inner Iterator.
   *
   * @return     mixed   No value is returned.
   */
  function rewind() {
    $this->iterators->rewind();

    /**
     * Advance to the first valid element contained in a child iterator
     */
    while ($this->iterators->valid()) {
      $this->getInnerIterator()->rewind();
      if ($this->getInnerIterator()->valid()) {
        return; /* found a valid element to start on */
      }
      $this->iterators->next();
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/appenditerator.valid.php )
   *
   * Checks validity of the current element.
   *
   * @return     mixed   Returns TRUE if the current iteration is valid,
   *                     FALSE otherwise.
   */
  function valid() {
    return $this->iterators->valid() && $this->getInnerIterator()->valid();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/appenditerator.current.php )
   *
   * Gets the current value.
   *
   * @return     mixed   The current value if it is valid or NULL otherwise.
   */
  function current() {
    /* Using $this->valid() would be exactly the same; it would omit
     * the access to a non valid element in the inner iterator. Since
     * the user didn't respect the valid() return value false this
     * must be intended hence we go on. */
    return $this->iterators->valid() ?
      $this->getInnerIterator()->current() : NULL;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/appenditerator.key.php )
   *
   * Get the current key.
   *
   * @return     mixed   The current key if it is valid or NULL otherwise.
   */
  function key() {
    return $this->iterators->valid() ? $this->getInnerIterator()->key() : NULL;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/appenditerator.next.php )
   *
   * Moves to the next element. If this means to another Iterator then it
   * rewinds that Iterator.
   *
   * @return     mixed   No value is returned.
   */
  function next() {
    if (!$this->iterators->valid()){
      return; /* done all */
    }
    $this->getInnerIterator()->next();
    if ($this->getInnerIterator()->valid()) {
      return; /* found valid element in current inner iterator */
    }
    $this->iterators->next();
    while ($this->iterators->valid()) {
      $this->getInnerIterator()->rewind();
      if ($this->getInnerIterator()->valid()) {
        return; /* found element as first elemet in another iterator */
      }
      $this->iterators->next();
    }
  }

  function __call($func, $params) {
    return call_user_func_array(array($this->getInnerIterator(), $func),
                                $params);
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.filteriterator.php )
 *
 * This abstract iterator filters out unwanted values. This class should
 * be extended to implement custom iterator filters. The
 * FilterIterator::accept() must be implemented in the subclass.
 *
 */
abstract class FilterIterator extends IteratorIterator {
  private $it;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filteriterator.construct.php )
   *
   * Constructs a new FilterIterator, which consists of a passed in iterator
   * with filters applied to it. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @it         mixed   The iterator that is being filtered.
   *
   * @return     mixed   The FilterIterator.
   */
  public function __construct(\Iterator $it) {
    $this->it = $it;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filteriterator.rewind.php )
   *
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    $this->it->rewind();
    $this->fetch();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filteriterator.accept.php )
   *
   * Returns whether the current element of the iterator is acceptable
   * through this filter.
   *
   * @return     mixed   TRUE if the current element is acceptable, otherwise
   *                     FALSE.
   */
  abstract function accept();

  private function fetch() {
    while ($this->it->valid()) {
      if ($this->accept()) {
        return;
      }
      $this->it->next();
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filteriterator.next.php )
   *
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    $this->it->next();
    $this->fetch();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filteriterator.valid.php )
   *
   *
   * @return     mixed   TRUE if the current element is valid, otherwise
   *                     FALSE
   */
  public function valid() {
    return $this->it->valid();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filteriterator.key.php )
   *
   *
   * @return     mixed   The current key.
   */
  public function key() {
    return $this->it->key();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filteriterator.current.php )
   *
   *
   * @return     mixed   The current element value.
   */
  public function current() {
    return $this->it->current();
  }

  protected function __clone() {
    // disallow clone
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/filteriterator.getinneriterator.php )
   *
   *
   * @return     mixed   The inner iterator.
   */
  public function getInnerIterator() {
    return $this->it;
  }

  public function __call($func, $params) {
    return call_user_func_array(array($this->it, $func), $params);
  }
}

}

namespace {
/**
 * FilterIterator which uses a callback for each element
 */
class CallbackFilterIterator extends FilterIterator {

  protected $callback;

  /**
   * Creates a filtered iterator using the callback to determine which
   * items are accepted or rejected.
   *
   * @iterator \Iterator The iterator to be filtered
   * @callback callable The callback, which should return TRUE to accept the
   * current item or FALSE otherwise.
   */
  public function __construct(\Iterator $iterator, callable $callback) {
    parent::__construct($iterator);
    $this->callback = $callback;
  }

  /**
   * Calls the callback with the current value, the current key and the inner
   * iterator as arguments
   *
   * @return bool The callback is expected to return TRUE if the current item
   * is to be accepted, or FALSE otherwise.
   */
  public function accept() {
    return call_user_func(
        $this->callback,
        $this->current(),
        $this->key(),
        $this->getInnerIterator()
    );
  }

}
}

namespace {

class MultipleIterator implements Iterator {
  /** Inner Iterators */
  private $iterators;

  /** Flags: const MIT_* */
  private $flags;

  /** do not require all sub iterators to be valid in iteration */
  const MIT_NEED_ANY = 0;

  /** require all sub iterators to be valid in iteration */
  const MIT_NEED_ALL  = 1;

  /** keys are created from sub iterators position */
  const MIT_KEYS_NUMERIC  = 0;

  /** keys are created from sub iterators associated information */
  const MIT_KEYS_ASSOC  = 2;

  /** Construct a new empty MultipleIterator
  * @param flags MIT_* flags
  */
  public function __construct(
    $flags = self::MIT_NEED_ALL | self::MIT_KEYS_NUMERIC,
  )  {
    $this->iterators = new SplObjectStorage();
    $this->flags = $flags;
  }

  /** @return current flags MIT_* */
  public function getFlags() {
    return $this->flags;
  }

  /** @param $flags new flags. */
  public function setFlags($flags) {
    $this->flags = $flags;
  }

  /** @param $iter new Iterator to attach.
  * @param $inf associative info forIteraotr, must be NULL, integer or string
  *
  * @throws IllegalValueException if a inf is none of NULL, integer or string
  * @throws IllegalValueException if a inf is already an associated info
  */
  public function attachIterator(Iterator $iter, $inf = NULL) {

    if (!is_null($inf)) {
      if (!is_int($inf) && !is_string($inf)){
        throw new IllegalValueException(
          'Inf must be NULL, integer or string');
      }

      foreach($this->iterators as $iter) {
        if ($inf == $this->iterators->getInfo()) {
          throw new IllegalValueException('Key duplication error');
        }
      }
    }
    $this->iterators->attach($iter, $inf);
  }

  /** @param $iter attached Iterator that should be detached. */
  public function detachIterator(Iterator $iter) {
    $this->iterators->detach($iter);
  }

  /** @param $iter Iterator to check
  * @return whether $iter is attached or not
  */
  public function containsIterator(Iterator $iter) {
    return $this->iterator->contains($iter);
  }

  /** @return number of attached Iterator instances. */
  public function countIterators() {
    return $this->iterators->count();
  }

  /** Rewind all attached Iterator instances. */
  public function rewind() {
    foreach($this->iterators as $iter) {
      $iter->rewind();
    }
  }

  /**
  * @return whether all or one sub iterator is valid depending on flags.
  * In mode MIT_NEED_ALL we expect all sub iterators to be valid and
  * return flase on the first non valid one. If that flag is not set we
  * return true on the first valid sub iterator found. If no Iterator
  * is attached, we always return false.
  */
  public function valid() {
    if (!sizeof($this->iterators)) {
      return false;
    }
    // The following code is an optimized version that executes as few
    // valid() calls as necessary and that only checks the flags once.
    $expect = $this->flags & self::MIT_NEED_ALL;
    foreach($this->iterators as $iter) {
      if ($expect != $iter->valid()) {
        return !$expect;
      }
    }
    return $expect;
  }

  /** Move all attached Iterator instances forward. That is invoke
  * their next() method regardless of their state.
  */
  public function next() {
    foreach($this->iterators as $iter) {
      $iter->next();
    }
  }

  /** @return false if no sub Iterator is attached and an array of
  * all registered Iterator instances current() result.
  * @throws RuntimeException      if mode MIT_NEED_ALL is set and at least one
  *                               attached Iterator is not valid().
  * @throws IllegalValueException if a key is NULL and MIT_KEYS_ASSOC is set.
  */
  public function current() {
    if (!sizeof($this->iterators)) {
      return false;
    }
    $retval = array();
    foreach($this->iterators as $iter) {
      if ($iter->valid()) {
        if ($this->flags & self::MIT_KEYS_ASSOC) {
          $key = $this->iterators->getInfo();
          if (is_null($key)) {
            throw new IllegalValueException(
              'Sub-Iterator is associated with NULL');
          }
          $retval[$key] = $iter->current();
        } else {
          $retval[] = $iter->current();
        }
      } else if ($this->flags & self::MIT_NEED_ALL) {
        throw new RuntimeException(
          'Called current() with non valid sub iterator');
      } else {
        $retval[] = NULL;
      }
    }
    return $retval;
  }

  /** @return false if no sub Iterator is attached and an array of
  * all registered Iterator instances key() result.
  * @throws LogicException if mode MIT_NEED_ALL is set and at least one
  *         attached Iterator is not valid().
  */
  public function key() {
    if (!sizeof($this->iterators)) {
      return false;
    }
    $retval = array();
    foreach($this->iterators as $iter) {
      if ($iter->valid()) {
        $retval[] = $iter->key();
      } else if ($this->flags & self::MIT_NEED_ALL) {
        throw new LogicException('Called key() with non valid sub iterator');
      } else {
        $retval[] = NULL;
      }
    }
    return $retval;
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://docs.hhvm.com/manual/en/class.recursivefilteriterator.php )
 *
 * This abstract iterator filters out unwanted values for a
 * RecursiveIterator. This class should be extended to implement custom
 * filters. The RecursiveFilterIterator::accept() must be implemented in
 * the subclass.
 *
 */
abstract class RecursiveFilterIterator extends FilterIterator
  implements OuterIterator, RecursiveIterator {

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivefilteriterator.construct.php )
   *
   * Create a RecursiveFilterIterator from a RecursiveIterator.
   *
   * @iterator   mixed   The RecursiveIterator to be filtered.
   *
   * @return     mixed   No value is returned.
   */
  public function __construct (RecursiveIterator $iterator) {
    return parent::__construct($iterator);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivefilteriterator.getchildren.php )
   *
   * Return the inner iterator's children contained in a
   * RecursiveFilterIterator.
   *
   * @return     mixed   Returns a RecursiveFilterIterator containing the
   *                     inner iterator's children.
   */
  public function getChildren() {
    return new static($this->getInnerIterator()->getChildren());
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivefilteriterator.haschildren.php )
   *
   * Check whether the inner iterator's current element has children.
   *
   * @return     mixed   TRUE if the inner iterator has children, otherwise
   *                     FALSE
   */
  public function hasChildren() {
    return $this->getInnerIterator()->hasChildren();
  }

}
}

namespace {

class RegexIterator extends FilterIterator
{
  /* Constants */

  const MATCH = 0;
  const GET_MATCH = 1;
  const ALL_MATCHES = 2;
  const SPLIT = 3;
  const REPLACE = 4;

  const USE_KEY = 1;
  const INVERT_MATCH = 2;


  /* Properties */


  /**
   * @var string The regular expression to match.
   */
  private $regex;

  /**
   * @var integer Operation mode, see RegexIterator::setMode() for a list of
   *              modes.
   */
  private $mode;

  /**
   * @var integer Special flags, see RegexIterator::setFlags() for a list of
   *              available flags.
   */
  private $flags;

  /**
   * @var integer The regular expression flags.
   */
  private $pregFlags;

  /**
   * @var mixed
   */
  private $key;

  /**
   * @var mixed
   */
  private $current;

  /**
   * @var string
   */
  public $replacement;


  /* Methods */


  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/regexiterator.construct.php )
   *
   * Create a new RegexIterator which filters an Iterator using a regular
   * expression.
   *
   * @param Iterator $iterator   The iterator to apply this regex filter to.
   * @param string   $regex      The regular expression to match.
   * @param integer  $mode       Operation mode, see RegexIterator::setMode()
   *                             for a list of modes.
   * @param integer  $flags      Special flags, see RegexIterator::setFlags()
   *                             for a list of available flags.
   * @param integer  $preg_flags The regular expression flags. These flags
   *                             depend on the operation mode parameter:
   *                         - RegexIterator::ALL_MATCHES: See preg_match_all().
   *                         - RegexIterator::GET_MATCH: See preg_match().
   *                         - RegexIterator::MATCH: See preg_match().
   *                         - RegexIterator::REPLACE: none.
   *                         - RegexIterator::SPLIT: See preg_split().
   */
  public function __construct(\Iterator $iterator, $regex, $mode = self::MATCH,
                              $flags = 0, $preg_flags = 0) {
    parent::__construct($iterator);

    $this->setMode($mode);

    $this->regex       = $regex;
    $this->flags       = $flags;
    $this->pregFlags   = $preg_flags;
    $this->replacement = '';
  }

  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/regexiterator.accept.php )
   *
   * Matches (string) RegexIterator::current() (or RegexIterator::key() if
   * the RegexIterator::USE_KEY flag is set) against the regular expression.
   *
   * @return boolean TRUE if a match, FALSE otherwise.
   */
  public function accept() {
    if (is_array(parent::current())) {
      return false;
    }

    $this->key     = parent::key();
    $this->current = parent::current();

    $matches = array();
    $useKey  = ($this->flags & self::USE_KEY);
    $subject = $useKey
      ? (string) $this->key
      : (string) $this->current;

    switch ($this->mode) {
      case self::MATCH:
        $ret = (preg_match($this->regex, $subject, $matches,
                           $this->pregFlags) > 0);
        break;
      case self::GET_MATCH:
        $this->current = array();

        $ret = (preg_match($this->regex, $subject, $this->current,
                           $this->pregFlags) > 0);
        break;
      case self::ALL_MATCHES:
        $this->current = array();

        $count = preg_match_all($this->regex, $subject, $this->current,
                       $this->pregFlags);

        $ret = $count > 0;
        break;
      case self::SPLIT:
        $this->current = preg_split($this->regex, $subject, null,
                                    $this->pregFlags);

        $ret = ($this->current && count($this->current) > 1);
        break;
      case self::REPLACE:
        $replace_count = 0;
        $result = preg_replace($this->regex, $this->replacement,
                               $subject, -1, $replace_count);

        if ($result === null || $replace_count == 0) {
          $ret = false;
          break;
        }

        if ($useKey) {
          $this->key = $result;

          $ret = true;
          break;
        }

        $this->current = $result;

        $ret = true;
        break;
      default:
        $ret = false;
        break;
    }
    if ($this->flags & self::INVERT_MATCH) {
      return !$ret;
    } else {
      return $ret;
    }
  }

  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filteriterator.key.php )
   *
   * Get the current key.
   *
   * @return mixed
   */
  public function key() {
    return $this->key;
  }

  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/filteriterator.current.php )
   *
   * Get the current element value.
   *
   * @return mixed
   */
  public function current() {
    return $this->current;
  }

  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/regexiterator.getregex.php )
   *
   * Returns current regular expression.
   *
   * @return string
   */
  public function getRegex() {
    return $this->regex;
  }

  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/regexiterator.getmode.php )
   *
   * Returns the operation mode, see RegexIterator::setMode() for the list
   * of operation modes.
   *
   * @return integer
   */
  public function getMode() {
    return $this->mode;
  }

  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/regexiterator.getflags.php )
   *
   * Returns the flags, see RegexIterator::setFlags() for a list of available
   * flags.
   *
   * @return integer
   */
  public function getFlags() {
    return $this->flags;
  }

  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/regexiterator.getpregflags.php )
   *
   * Returns the regular expression flags, see RegexIterator::__construct()
   * for the list of flags.
   *
   * @return integer
   */
  public function getPregFlags() {
    return $this->pregFlags;
  }

  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/regexiterator.setmode.php )
   *
   * Sets the operation mode.
   *
   * @param integer $mode The operation mode.
   *                      The available modes are listed below. The actual
   *                      meanings of these modes are described in the
   *                      predefined constants.
   *                      - 0: RegexIterator::MATCH
   *                      - 1: RegexIterator::GET_MATCH
   *                      - 2: RegexIterator::ALL_MATCHES
   *                      - 3: RegexIterator::SPLIT
   *                      - 4: RegexIterator::REPLACE
   *
   * @throws InvalidArgumentException
   */
  public function setMode($mode) {
    $mode = (integer) $mode;

    if ($mode < self::MATCH || $mode > self::REPLACE) {
      throw new InvalidArgumentException(sprintf('Illegal mode %ld', $mode));
    }

    $this->mode = $mode;
  }

  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/regexiterator.setflags.php )
   *
   * Sets the flags.
   *
   * @param integer $flags The flags to set, a bitmask of class constants.
   *                       The available flags are listed below. The actual
   *                       meanings of these flags are described in the
   *                       predefined constants.
   *                       - 1: RegexIterator::USE_KEY
   */
  public function setFlags($flags) {
    $this->flags = $flags;
  }

  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/regexiterator.setpregflags.php )
   *
   * Sets the regular expression flags.
   *
   * @param integer $preg_flags The regular expression flags. See
   *                            RegexIterator::__construct() for an overview
   *                            of available flags.
   */
  public function setPregFlags($preg_flags) {
    $preg_flags = (integer) $preg_flags;

    $this->pregFlags = $preg_flags;
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://docs.hhvm.com/manual/en/class.recursiveregexiterator.php )
 *
 * This recursive iterator can filter another recursive iterator via a
 * regular expression.
 *
 */
class RecursiveRegexIterator extends RegexIterator
  implements RecursiveIterator {

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveregexiterator.construct.php )
   *
   * Creates a new regular expression iterator.
   *
   * @iterator   mixed   The recursive iterator to apply this regex filter
   *                     to.
   * @regex      mixed   The regular expression to match.
   * @mode       mixed   Operation mode, see RegexIterator::setMode() for a
   *                     list of modes.
   * @flags      mixed   Special flags, see RegexIterator::setFlags() for a
   *                     list of available flags.
   * @preg_flags mixed   The regular expression flags. These flags depend on
   *                     the operation mode parameter:
   *                - RecursiveRegexIterator::ALL_MATCHES: See preg_match_all().
   *                - RecursiveRegexIterator::GET_MATCH: See preg_match().
   *                - RecursiveRegexIterator::MATCH: See preg_match().
   *                - RecursiveRegexIterator::REPLACE: none.
   *                - RecursiveRegexIterator::SPLIT: See preg_split().
   */
  public function __construct(RecursiveIterator $iterator, $regex,
                              $mode = self::MATCH, $flags = 0,
                              $preg_flags = 0) {
    parent::__construct($iterator, $regex, $mode, $flags, $preg_flags);
  }

  public function accept() {
    return $this->hasChildren() || parent::accept();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveregexiterator.getchildren.php )
   *
   * Returns an iterator for the current iterator entry.
   *
   * @return     mixed   An iterator for the current entry, if it can be
   *                     iterated over by the inner iterator.
   */
  public function getChildren() {
    return new RecursiveRegexIterator(
      $this->hasChildren() ? $this->getInnerIterator()->getChildren() : null,
      $this->getRegex(),
      $this->getMode(),
      $this->getFlags(),
      $this->getPregFlags()
    );
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveregexiterator.haschildren.php )
   *
   * Returns whether an iterator can be obtained for the current entry. This
   * iterator can be obtained via RecursiveRegexIterator::getChildren().
   *
   * @return     mixed   Returns TRUE if an iterator can be obtained for the
   *                     current entry, otherwise returns FALSE.
   */
  public function hasChildren() {
    return $this->getInnerIterator()->hasChildren();
  }
}
}

namespace {

class ParentIterator extends RecursiveFilterIterator
 implements RecursiveIterator, OuterIterator {

  public function accept() {
    return $this->getInnerIterator()->hasChildren();
  }
}
}

namespace {

class RecursiveCallbackFilterIterator extends CallbackFilterIterator
  implements OuterIterator, RecursiveIterator {


  public function __construct(\RecursiveIterator $it, callable $callback) {
    parent::__construct($it, $callback);
  }

  public function getChildren() {
    return new RecursiveCallbackFilterIterator(
      $this->getInnerIterator()->getChildren(),
      $this->callback
    );
  }

  public function hasChildren() {
    return $this->getInnerIterator()->hasChildren();
  }

}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.arrayiterator.php )
 *
 * This iterator allows to unset and modify values and keys while
 * iterating over Arrays and Objects.
 *
 * When you want to iterate over the same array multiple times you need to
 * instantiate ArrayObject and let it create ArrayIterator instances that
 * refer to it either by using foreach or by calling its getIterator()
 * method manually.
 *
 */
class ArrayIterator implements ArrayAccess, SeekableIterator, Countable {
  private $storage;
  private $flags;

  const STD_PROP_LIST = 1;
  const ARRAY_AS_PROPS = 2;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.construct.php )
   *
   * Constructs an ArrayIterator object. Warning: This function is currently
   * not documented; only its argument list is available.
   *
   * @array      mixed   The array or object to be iterated on.
   *
   * @return     mixed   An ArrayIterator object.
   */
  public function __construct($array = array(), $flags = null) {
    if (($array instanceof ArrayObject) || ($array instanceof ArrayIterator)) {
      $this->storage = $array->getArrayCopy();
      $flags = ($flags === null) ? $array->getFlags() : $flags;
    } else if (gettype($array) === 'object') {
      $this->storage = get_object_vars($array);
    } else if (is_array($array)) {
      $this->storage = (array) $array;
    } else {
      $this->storage = array();
      throw new InvalidArgumentException(
        "Passed variable is not an array or object, using empty array instead"
      );
    }
    $this->flags = ($flags === null) ? 0 : $flags;
    reset($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.append.php )
   *
   * Appends value as the last element. Warning: This function is currently
   * not documented; only its argument list is available.
   *
   * @value      mixed   The value to append.
   *
   * @return     mixed   No value is returned.
   */
  public function append($value) {
    $this->storage[] = $value;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.asort.php )
   *
   * Sorts an array by values. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   No value is returned.
   */
  public function asort() {
    return asort($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.count.php )
   *
   * Gets the number of elements in the array, or the number of public
   * properties in the object. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   The number of elements or public properties in the
   *                     associated array or object, respectively.
   */
  public function count() {
    return count($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.current.php )
   *
   * Get the current array entry.
   *
   * @return     mixed   The current array entry.
   */
  public function current() {
    return (key($this->storage) === null) ? null : current($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.getarraycopy.php )
   *
   * Get a copy of an array. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   A copy of the array, or array of public properties
   *                     if ArrayIterator refers to an object.
   */
  public function getArrayCopy() {
    return $this->storage;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.getflags.php )
   *
   * Get the current flags. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   The current flags.
   */
  public function getFlags() {
    return $this->flags;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.key.php )
   *
   * This function returns the current array key
   *
   * @return     mixed   The current array key.
   */
  public function key() {
    return key($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.ksort.php )
   *
   * Sorts an array by the keys. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   No value is returned.
   */
  public function ksort() {
    return ksort($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.natcasesort.php )
   *
   * Sort the entries by values using a case insensitive "natural order"
   * algorithm. Warning: This function is currently not documented; only its
   * argument list is available.
   *
   * @return     mixed   No value is returned.
   */
  public function natcasesort() {
    return natcasesort($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.natsort.php )
   *
   * Sort the entries by values using "natural order" algorithm. Warning:
   * This function is currently not documented; only its argument list is
   * available.
   *
   * @return     mixed   No value is returned.
   */
  public function natsort() {
    return natsort($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.next.php )
   *
   * The iterator to the next entry.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    next($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.offsetexists.php )
   *
   * Checks if the offset exists. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @index      mixed   The offset being checked.
   *
   * @return     mixed   TRUE if the offset exists, otherwise FALSE
   */
  public function offsetExists($index) {
    return isset($this->storage[$index]);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.offsetget.php )
   *
   * Gets the value from the provided offset. Warning: This function is
   * currently not documented; only its argument list is available.
   *
   * @index      mixed   The offset to get the value from.
   *
   * @return     mixed   The value at offset index.
   */
  public function offsetGet($index) {
    return $this->storage[$index];
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.offsetset.php )
   *
   * Sets a value for a given offset. Warning: This function is currently
   * not documented; only its argument list is available.
   *
   * @index      mixed   The index to set for.
   * @newval     mixed   The new value to store at the index.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetSet($index, $newval) {
    if ($index === null) {
      $this->storage[] = $newval;
    } else {
      $this->storage[$index] = $newval;
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.offsetunset.php )
   *
   * Unsets a value for an offset. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @index      mixed   The offset to unset.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetUnset($index) {
    unset($this->storage[$index]);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.rewind.php )
   *
   * This rewinds the iterator to the beginning.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    reset($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.seek.php )
   *
   *
   * @position   mixed   The position to seek to.
   *
   * @return     mixed   No value is returned.
   */
  public function seek($position) {
    if (func_num_args() !== 1) {
      return;
    }
    if ($position < 0 || $position >= count($this->storage)) {
      throw new OutOfBoundsException(
        "Seek position {$position} is out of range"
      );
    }
    reset($this->storage);
    for ($i = 0; $i < $position; $i++) {
      if (!next($this->storage)) {
        break;
      }
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.setflags.php )
   *
   * Sets behaviour flags. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @flags      mixed   A bitmask as follows: 0 = Properties of the object
   *                     have their normal functionality when accessed as
   *                     list (var_dump, foreach, etc.). 1 = Array indices
   *                     can be accessed as properties in read/write.
   *
   * @return     mixed   No value is returned.
   */
  public function setFlags($flags) {
    $this->flags = $flags;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.uasort.php )
   *
   * Sort the entries by values using user defined function. Warning: This
   * function is currently not documented; only its argument list is
   * available.
   *
   * @cmp_function
   *             mixed   The compare function used for the sort.
   *
   * @return     mixed   No value is returned.
   */
  public function uasort($cmp_function) {
    return uasort($this->storage, $cmp_function);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.uksort.php )
   *
   * Sort the entries by key using user defined function. Warning: This
   * function is currently not documented; only its argument list is
   * available.
   *
   * @cmp_function
   *             mixed   The compare function used for the sort.
   *
   * @return     mixed   No value is returned.
   */
  public function uksort($cmp_function) {
    return uksort($this->storage, $cmp_function);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayiterator.valid.php )
   *
   * Checks if the array contains any more entries.
   *
   * @return     mixed   No value is returned.
   */
  public function valid() {
    return key($this->storage) !== null;
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.recursivearrayiterator.php
 * )
 *
 * This iterator allows to unset and modify values and keys while
 * iterating over Arrays and Objects in the same way as the ArrayIterator.
 * Additionally it is possible to iterate over the current iterator entry.
 *
 */
class RecursiveArrayIterator
  extends ArrayIterator
  implements RecursiveIterator {

  const CHILD_ARRAYS_ONLY = 4;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivearrayiterator.getchildren.php )
   *
   * Returns an iterator for the current iterator entry.
   *
   * @return     mixed   An iterator for the current entry, if it is an array
   *                     or object.
   */
  public function getChildren() {
    return new RecursiveArrayIterator(
      $this->hasChildren() ? $this->current() : null,
      $this->getFlags()
    );
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivearrayiterator.haschildren.php )
   *
   * Returns whether current entry is an array or an object for which an
   * iterator can be obtained via RecursiveArrayIterator::getChildren().
   *
   * @return     mixed   Returns TRUE if the current entry is an array or an
   *                     object, otherwise FALSE is returned.
   */
  public function hasChildren() {
    return
      is_array($this->current()) ||
      (is_object($this->current()) &&
       ($this->getFlags() & self::CHILD_ARRAYS_ONLY) == 0);
  }

}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.cachingiterator.php )
 *
 * This object supports cached iteration over another iterator.
 *
 */
class CachingIterator
  extends IteratorIterator
  implements OuterIterator, ArrayAccess, Countable {

  private $flags;
  private $fullCacheIterator;
  private $valid;
  private $strValue;

  const CALL_TOSTRING = 1;
  const TOSTRING_USE_KEY = 2;
  const TOSTRING_USE_CURRENT = 4;
  const TOSTRING_USE_INNER = 8;
  const CATCH_GET_CHILD = 16;
  const FULL_CACHE = 256;

  function __construct(\Iterator $iterator, $flags = CachingIterator::CALL_TOSTRING) {
    $flags = $this->validateFlags($flags);
    if ($flags & self::FULL_CACHE) {
      $this->fullCacheIterator = new ArrayIterator();
    }

    $this->flags = $flags;
    parent::__construct($iterator);
  }

  private function validateFlags($flags) {
    $flags = (int)$flags;
    $string_flags = $flags & (
      self::CALL_TOSTRING | self::TOSTRING_USE_KEY |
      self::TOSTRING_USE_CURRENT | self::TOSTRING_USE_INNER
    );

    if ((($string_flags & self::CALL_TOSTRING) &&
        ($string_flags - self::CALL_TOSTRING)) ||
        (($string_flags & self::TOSTRING_USE_KEY) &&
        ($string_flags - self::TOSTRING_USE_KEY)) ||
        (($string_flags & self::TOSTRING_USE_CURRENT) &&
        ($string_flags - self::TOSTRING_USE_CURRENT))) {
      throw new InvalidArgumentException(
        'Flags must contain only one of CALL_TOSTRING, TOSTRING_USE_KEY, '.
        'TOSTRING_USE_CURRENT, TOSTRING_USE_INNER'
      );
    }

    return $flags & 0xFFFF;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.getflags.php )
   *
   *
   * @return     mixed   Description...
   */
  public function getFlags() {
    return $this->flags;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.setflags.php )
   *
   *
   * @flags      mixed   Bitmask of the flags to set.
   *
   * @return     mixed   No value is returned.
   */
  public function setFlags($flags) {
    $flags = $this->validateFlags($flags);

    if (!($flags & self::CALL_TOSTRING) &&
        ($this->flags & self::CALL_TOSTRING)) {
      throw new InvalidArgumentException(
        'Unsetting flag CALL_TO_STRING is not possible'
      );
    }

    if (!($flags & self::TOSTRING_USE_INNER) &&
        ($this->flags & self::TOSTRING_USE_INNER)) {
      throw new InvalidArgumentException(
        'Unsetting flag TOSTRING_USE_INNER is not possible'
      );
    }

    if (($flags & self::FULL_CACHE) && !($this->flags & self::FULL_CACHE)) {
      $this->fullCacheIterator = new ArrayIterator();
    }

    $this->flags = $flags;
  }

  private function getFullCacheIterator() {
    if ($this->fullCacheIterator) {
      return $this->fullCacheIterator;
    }

    throw new BadMethodCallException(
      get_class($this).
      ' does not use a full cache (see CachingIterator::__construct)'
    );
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.rewind.php )
   *
   *
   * @return     mixed   No value is returned.
   */
  function rewind() {
    if ($this->fullCacheIterator) {
      $this->fullCacheIterator = new ArrayIterator();
    }

    parent::rewind();
    $this->moveInnerIteratorNext();
  }

  protected function _fetch($check) {
    $this->valid = parent::_fetch($check);

    if (!$check || $this->valid) {
      $current = $this->current();
      if ($this->flags & self::CALL_TOSTRING) {
        if (is_object($current)) {
          $this->strValue = $current->__toString();
        } else {
          $this->strValue = (string)$current;
        }
      } else if ($this->flags & self::TOSTRING_USE_INNER) {
        $this->strValue = $this->getInnerIterator()->__toString();
      }

      if ($this->fullCacheIterator) {
        $this->fullCacheIterator->offsetSet($this->key(), $current);
      }
    }

    return $this->valid;
  }

  private function moveInnerIteratorNext() {
    $iterator = $this->getInnerIterator();
    if ($iterator->valid()) {
      $iterator->next();
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.next.php )
   *
   *
   * @return     mixed   No value is returned.
   */
  function next() {
    $this->_setPosition($this->_getPosition() + 1);
    $this->_fetch(true);
    $this->moveInnerIteratorNext();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.valid.php )
   *
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  function valid() {
    return $this->valid;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.hasnext.php )
   *
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  function hasNext() {
    return $this->getInnerIterator()->valid();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.count.php )
   *
   *
   * @return     mixed   The count of the elements iterated over.
   */
  function count() {
    return $this->getFullCacheIterator()->count();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.offsetexists.php
   * )
   *
   *
   * @index      mixed   The index being checked.
   *
   * @return     mixed   Returns TRUE if an entry referenced by the offset
   *                     exists, FALSE otherwise.
   */
  function offsetExists($index) {
    return $this->getFullCacheIterator()->offsetExists($index);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.offsetget.php )
   *
   *
   * @index      mixed   Description...
   *
   * @return     mixed   Description...
   */
  function offsetGet($index) {
    return $this->getFullCacheIterator()->offsetGet($index);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.offsetset.php )
   *
   *
   * @index      mixed   The index of the element to be set.
   * @newval     mixed   The new value for the index.
   *
   * @return     mixed   No value is returned.
   */
  function offsetSet($index, $newval) {
    return $this->getFullCacheIterator()->offsetSet($index, $newval);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.offsetunset.php
   * )
   *
   *
   * @index      mixed   The index of the element to be unset.
   *
   * @return     mixed   No value is returned.
   */
  function offsetUnset($index) {
    return $this->getFullCacheIterator()->offsetUnset($index);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.getcache.php )
   *
   *
   * @return     mixed   Description...
   */
  function getCache() {
    return $this->getFullCacheIterator()->getArrayCopy();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/cachingiterator.tostring.php )
   *
   *
   * @return     mixed   The string representation of the current element.
   */
  function __toString() {
    if ($this->flags & self::TOSTRING_USE_KEY) {
      return (string)$this->key();
    } else if ($this->flags & self::TOSTRING_USE_CURRENT) {
      return (string)$this->current();
    }
    if (!($this->flags & (self::CALL_TOSTRING | self::TOSTRING_USE_INNER))) {
      throw new Exception(
        'CachingIterator does not fetch string value '.
        '(see CachingIterator::__construct)'
      );
    }
    return $this->strValue;
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://docs.hhvm.com/manual/en/class.recursivecachingiterator.php )
 *
 * ...
 *
 */
class RecursiveCachingIterator
  extends CachingIterator
  implements RecursiveIterator {

  private $hasChildren;
  private $getChildren;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivecachingiterator.construct.php )
   *
   * Constructs a new RecursiveCachingIterator, which consists of a passed
   * in iterator. Warning: This function is currently not documented; only
   * its argument list is available.
   *
   * @iterator   mixed   The iterator being used.
   * @flags      mixed   The flags. Use CALL_TOSTRING to call
   *                     RecursiveCachingIterator::__toString() for every
   *                     element (the default), and/or CATCH_GET_CHILD to
   *                     catch exceptions when trying to get children.
   *
   * @return     mixed   The RecursiveCachingIterator.
   */
  function __construct(
    \Iterator $iterator,
    $flags = RecursiveCachingIterator::CALL_TOSTRING
  ) {
    if (!($iterator instanceof RecursiveIterator)) {
      throw new InvalidArgumentException(
        __CLASS__ . "::__construct() expects parameter 1 to be RecursiveIterator, ".
        gettype($iterator) . " given"
      );
    }
    parent::__construct($iterator, $flags);
  }

  function _fetch($check) {
    $valid = parent::_fetch($check);

    if (!$check || $valid) {
      $iterator = $this->getInnerIterator();
      if ($this->hasChildren = $iterator->hasChildren()) {
        $this->getChildren = new RecursiveCachingIterator(
          $iterator->getChildren(),
          $this->getFlags()
        );
      } else {
        $this->getChildren = NULL;
      }
    }

    return $valid;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivecachingiterator.haschildren.php )
   *
   *
   * @return     mixed   TRUE if the inner iterator has children, otherwise
   *                     FALSE
   */
  function hasChildren() {
    return $this->hasChildren;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursivecachingiterator.getchildren.php )
   *
   *
   * @return     mixed   The inner iterator's children, as a
   *                     RecursiveCachingIterator.
   */
  function getChildren() {
    return $this->getChildren;
  }
}
}

namespace {

class php_user_filter {
  public function __construct(
    public resource $stream,
    public string $filtername,
    public $params
  ) {
  }

  public function filter(
    resource $in,
    resource $out,
    int &$consumed,
    bool $closed,
  ): int {
    return PSFS_ERR_FATAL;
  }

  public function onClose(): void {
  }

  public function onCreate(): ?bool {
    // Docs say bool, but Zend's default implementation returns null
    return null;
  }
}

function stream_bucket_new(resource $stream, string $buffer) {
  return new __SystemLib\StreamFilterBucket($buffer);
}

namespace __SystemLib {
  class StreamFilterBucket {
    public string $data;
    public int $datalen;

    public function __construct(
      string $data,
      int $datalen = 0,
    ) {
      if ($datalen <= 0) {
        $datalen = strlen($data);
      }
      $this->data = $data;
      $this->datalen = $datalen;
    }

    public function __toString() {
      if ($this->datalen >= 0) {
        $len = min($this->datalen, strlen($this->data));
        if ($len == 0) {
          // substr returns false on empty strings
          return '';
        } else {
          return substr($this->data, 0, $len);
        }
      } else {
        return $this->data;
      }
    }
  }
}
}

namespace {

namespace __SystemLib {
  function register_default_stream_filters() {
    \stream_filter_register('zlib.deflate', '__SystemLib\DeflateStreamFilter');
    \stream_filter_register('zlib.inflate', '__SystemLib\InflateStreamFilter');
    \stream_filter_register(
      'string.rot13',
      '__SystemLib\StringRot13StreamFilter'
    );
    \stream_filter_Register(
      'string.toupper',
      '__SystemLib\StringToUpperStreamFilter'
    );
    \stream_filter_Register(
      'string.tolower',
      '__SystemLib\StringToLowerStreamFilter'
    );
    \stream_filter_Register(
      'convert.iconv.*',
      '__SystemLib\ConvertIconvFilter'
    );
  }

  class ConvertIconvFilter extends \php_user_filter {
    private $fromEncoding;
    private $toEncoding;

    public function onCreate(): bool {
      /* strip out prefix "convert.iconv." */
      $filter = substr($this->filtername, 14);
      if (false === strpos($filter, '/')) {
        return false;
      }
      $encodingPair = explode('/', $filter, 2);
      $this->fromEncoding = strtolower($encodingPair[0]);
      $this->toEncoding = strtolower($encodingPair[1]);
      return true;
    }

    public function filter($in, $out, &$consumed, $closing): int {
      while ($bucket = stream_bucket_make_writeable($in)) {
        $convertedData = iconv(
          $this->fromEncoding,
          $this->toEncoding,
          $bucket->data
        );
        stream_bucket_append(
          $out,
          stream_bucket_new($this->stream, $convertedData)
        );
      }
      return \PSFS_PASS_ON;
    }
  }

  class DeflateStreamFilter extends \php_user_filter {
    private $level = -1; // zlib default
    private $buffer = '';

    public function filter($in, $out, &$consumed, $closing): int {
      while ($bucket = stream_bucket_make_writeable($in)) {
        $this->buffer .= $bucket->data;
      }

      if ($closing) {
        if (is_int($this->params)) {
          $this->level = $this->params;
        }
        if (is_array($this->params) && isset($this->params['level'])) {
          $this->level = $this->params['level'];
        }
        stream_bucket_append(
          $out,
          stream_bucket_new(
            $this->stream,
            gzdeflate($this->buffer, $this->level)
          )
        );
      }

      return \PSFS_PASS_ON;
    }
  }

  class InflateStreamFilter extends \php_user_filter {
    public function onCreate(): bool {
      $this->impl = new \__SystemLib_ChunkedInflator();
      return true;
    }

    public function filter($in, $out, &$consumed, $closing): int {
      while ($bucket = stream_bucket_make_writeable($in)) {
        if ($this->impl->eof()) {
          return \PSFS_ERR_FATAL;
        }
        $this_chunk = $this->impl->inflateChunk($bucket->data);
        stream_bucket_append(
          $out,
          stream_bucket_new($this->stream, $this_chunk)
        );
      }

      return \PSFS_PASS_ON;
    }
  }

  class StringToUpperStreamFilter extends \php_user_filter {
    public function filter($in, $out, &$consumed, $closing): int {
      while ($bucket = stream_bucket_make_writeable($in)) {
        stream_bucket_append(
          $out,
          stream_bucket_new($this->stream, strtoupper($bucket->data))
        );
      }
      return \PSFS_PASS_ON;
    }
  }

  class StringToLowerStreamFilter extends \php_user_filter {
    public function filter($in, $out, &$consumed, $closing): int {
      while ($bucket = stream_bucket_make_writeable($in)) {
        stream_bucket_append(
          $out,
          stream_bucket_new($this->stream, strtolower($bucket->data))
        );
      }
      return \PSFS_PASS_ON;
    }
  }

  class StringRot13StreamFilter extends \php_user_filter {
    public function filter($in, $out, &$consumed, $closing): int {
      while ($bucket = stream_bucket_make_writeable($in)) {
        stream_bucket_append(
          $out,
          stream_bucket_new($this->stream, str_rot13($bucket->data))
        );
      }
      return \PSFS_PASS_ON;
    }
  }
}
}

namespace {

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/function.filter-has-var.php )
   *
   *
   * @type       mixed   One of INPUT_GET, INPUT_POST, INPUT_COOKIE,
   *                     INPUT_SERVER, or INPUT_ENV.
   * @variable_name
   *             mixed   Name of a variable to check.
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
function filter_has_var($type, $variable_name) {
  if (!is_int($type)) {
    trigger_error(
      'filter_has_var() expects parameter 1 to be long, '.
      gettype($type).' given', E_WARNING
    );
    return false;
  }

  switch ($type) {
    case INPUT_GET:
      return isset($_GET[$variable_name]);
    case INPUT_POST:
      return isset($_POST[$variable_name]);
    case INPUT_COOKIE:
      return isset($_COOKIE[$variable_name]);
    case INPUT_SERVER:
      return isset($_SERVER[$variable_name]);
    case INPUT_ENV:
      return isset($_ENV[$variable_name]);
  }
  return false;
}
}

namespace {

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/function.filter-input.php )
   *
   *
   * @type       mixed   One of INPUT_GET, INPUT_POST, INPUT_COOKIE,
   *                     INPUT_SERVER, or INPUT_ENV.
   * @variable_name
   *             mixed   Name of a variable to get.
   * @filter     mixed   The ID of the filter to apply. The Types of filters
   *                     manual page lists the available filters.
   * @options    mixed   Associative array of options or bitwise disjunction
   *                     of flags. If filter accepts options, flags can be
   *                     provided in "flags" field of array.
   *
   * @return     mixed   Value of the requested variable on success, FALSE if
   *                     the filter fails, or NULL if the variable_name
   *                     variable is not set. If the flag
   *                     FILTER_NULL_ON_FAILURE is used, it returns FALSE if
   *                     the variable is not set and NULL if the filter
   *                     fails.
   */
function filter_input(int $type, $variable_name, $filter = FILTER_DEFAULT,
                      $options = null) {
  $var = __SystemLib_filter_input_get_var($type);

  if (!isset($var[$variable_name])) {
    if (is_array($options) && isset($options['options']) &&
        is_array($options['options']) &&
        isset($options['options']['default'])) {
      return $options['options']['default'];
    }
    return null;
  }
  return filter_var($var[$variable_name], $filter, $options);
}

<<__Native>>
function __SystemLib_filter_input_get_var(int $variable_name) : array;

/**
 * You almost never want this. It acts as though the request's globals
 * should be snapshotted now. Useful for unit tests that want to muck with
 * globals, and then lock them in.
 */
<<__Native>>
function _filter_snapshot_globals() : void;
}

namespace {
function _filter_var_array_is_valid_filter($filter) {
  static $ids = null;
  if ($ids === null) {
    // A bit painful in php, exposing the IDs might be better if this is hot
    $ids = array_fill_keys(array_map('filter_id', filter_list()), null);
  }
  return array_key_exists($filter, $ids);
}

function _filter_var_array_single($value, $filter, $options = array()) {
  if (!_filter_var_array_is_valid_filter($filter)) {
    $filter = FILTER_DEFAULT;
  }
  $ret = filter_var($value, (int) $filter, $options);

  $flags = isset($options['flags']) ? $options['flags'] : 0;
  if ($flags & FILTER_FORCE_ARRAY && !is_array($ret)) {
    return array($ret);
  }
  if ($flags & FILTER_REQUIRE_SCALAR && is_array($ret)) {
    return false;
  }
  if ($flags & FILTER_REQUIRE_ARRAY && is_null($ret)) {
    return array();
  }

  return $ret;
}

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/function.filter-var-array.php )
   *
   * This function is useful for retrieving many values without repetitively
   * calling filter_var().
   *
   * @data       mixed   An array with string keys containing the data to
   *                     filter.
   * @definition mixed   An array defining the arguments. A valid key is a
   *                     string containing a variable name and a valid value
   *                     is either a filter type, or an array optionally
   *                     specifying the filter, flags and options. If the
   *                     value is an array, valid keys are filter which
   *                     specifies the filter type, flags which specifies any
   *                     flags that apply to the filter, and options which
   *                     specifies any options that apply to the filter. See
   *                     the example below for a better understanding.
   *
   *                     This parameter can be also an integer holding a
   *                     filter constant. Then all values in the input array
   *                     are filtered by this filter.
   * @add_empty  mixed   Add missing keys as NULL to the return value.
   *
   * @return     mixed   An array containing the values of the requested
   *                     variables on success, or FALSE on failure. An array
   *                     value will be FALSE if the filter fails, or NULL if
   *                     the variable is not set.
   */
function filter_var_array($data, $definition = null, $add_empty = true) {
  if (!is_array($data)) {
    trigger_error('filter_var_array() expects parameter 1 to be array, '.
      gettype($data).' given', E_WARNING);
    return null;
  }

  $default_filter = null;
  if (!is_array($definition)) {
    if ($definition === null) {
      $default_filter = FILTER_DEFAULT;
    } else if (is_int($definition)) {
      if (!_filter_var_array_is_valid_filter($definition)) {
        return false;
      }
      $default_filter = $definition;
    } else {
      return false;
    }

    $definition = array_fill_keys(array_keys($data), null);
  }

  $ret = array();
  foreach ($definition as $key => $def) {
    if ($key === "") {
      trigger_error(
        'filter_var_array(): Empty keys are not allowed in the '.
        'definition array',
        E_WARNING
      );
      return false;
    }

    if (!array_key_exists($key, $data)) {
      if ($add_empty) {
        $ret[$key] = null;
      }
      continue;
    }

    $value = $data[$key];
    if ($default_filter) {
      $ret[$key] = _filter_var_array_single($value, $default_filter);
      continue;
    }

    if (!is_array($def)) {
      $ret[$key] = _filter_var_array_single($value, $def);
      continue;
    }

    if (!isset($def['filter'])) {
      $filter = FILTER_DEFAULT;
    } else {
      $filter = $def['filter'];
    }

    $ret[$key] = _filter_var_array_single($value, $filter, $def);
  }

  return $ret;
}
}

namespace {

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/function.filter-input-array.php
   * )
   *
   * This function is useful for retrieving many values without repetitively
   * calling filter_input().
   *
   * @type       mixed   One of INPUT_GET, INPUT_POST, INPUT_COOKIE,
   *                     INPUT_SERVER, or INPUT_ENV.
   * @definition mixed   An array defining the arguments. A valid key is a
   *                     string containing a variable name and a valid value
   *                     is either a filter type, or an array optionally
   *                     specifying the filter, flags and options. If the
   *                     value is an array, valid keys are filter which
   *                     specifies the filter type, flags which specifies any
   *                     flags that apply to the filter, and options which
   *                     specifies any options that apply to the filter. See
   *                     the example below for a better understanding.
   *
   *                     This parameter can be also an integer holding a
   *                     filter constant. Then all values in the input array
   *                     are filtered by this filter.
   * @add_empty  mixed   Add missing keys as NULL to the return value.
   *
   * @return     mixed   An array containing the values of the requested
   *                     variables on success, or FALSE on failure. An array
   *                     value will be FALSE if the filter fails, or NULL if
   *                     the variable is not set. Or if the flag
   *                     FILTER_NULL_ON_FAILURE is used, it returns FALSE if
   *                     the variable is not set and NULL if the filter
   *                     fails.
   */
function filter_input_array($type, $definition, $add_empty = true) {
  $var = null;
  switch ($type) {
    case INPUT_GET:
      $var = $_GET;
      break;
    case INPUT_POST:
      $var = $_POST;
      break;
    case INPUT_COOKIE:
      $var = $_COOKIE;
      break;
    case INPUT_SERVER:
      $var = $_SERVER;
      break;
    case INPUT_ENV:
      $var = $_ENV;
      break;
  }
  return filter_var_array($var, $definition, $add_empty);
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://docs.hhvm.com/manual/en/class.sessionhandlerinterface.php )
 *
 * SessionHandlerInterface is an interface which defines a prototype for
 * creating a custom session handler. In order to pass a custom session
 * handler to session_set_save_handler() using its OOP invocation, the
 * class must implement this interface.
 *
 * Please note the callback methods of this class are designed to be
 * called internally by PHP and are not meant to be called from user-space
 * code.
 *
 */
interface SessionHandlerInterface {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/sessionhandlerinterface.close.php )
   *
   * Closes the current session. This function is automatically executed
   * when closing the session, or explicitly via session_write_close().
   *
   * @return     mixed   The return value (usually TRUE on success, FALSE on
   *                     failure). Note this value is returned internally to
   *                     PHP for processing.
   */
  public function close();
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/sessionhandlerinterface.destroy.php )
   *
   * Destroys a session. Called by session_regenerate_id() (with $destroy =
   * TRUE), session_destroy() and when session_decode() fails.
   *
   * @session_id mixed   The session ID being destroyed.
   *
   * @return     mixed   The return value (usually TRUE on success, FALSE on
   *                     failure). Note this value is returned internally to
   *                     PHP for processing.
   */
  public function destroy($session_id);
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/sessionhandlerinterface.gc.php )
   *
   * Cleans up expired sessions. Called by session_start(), based on
   * session.gc_divisor, session.gc_probability and session.gc_lifetime
   * settings.
   *
   * @maxlifetime
   *             mixed   Sessions that have not updated for the last
   *                     maxlifetime seconds will be removed.
   *
   * @return     mixed   The return value (usually TRUE on success, FALSE on
   *                     failure). Note this value is returned internally to
   *                     PHP for processing.
   */
  public function gc($maxlifetime);
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/sessionhandlerinterface.open.php
   * )
   *
   * Re-initialize existing session, or creates a new one. Called when a
   * session starts or when session_start() is invoked.
   *
   * @save_path  mixed   The path where to store/retrieve the session.
   * @name       mixed   The session name.
   *
   * @return     mixed   The return value (usually TRUE on success, FALSE on
   *                     failure). Note this value is returned internally to
   *                     PHP for processing.
   */
  public function open($save_path, $name);
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/sessionhandlerinterface.read.php
   * )
   *
   * Reads the session data from the session storage, and returns the
   * results. Called right after the session starts or when session_start()
   * is called. Please note that before this method is called
   * SessionHandlerInterface::open() is invoked.
   *
   * This method is called by PHP itself when the session is started. This
   * method should retrieve the session data from storage by the session ID
   * provided. The returned by this method must be in the same
   * serialized format as when originally passed to the
   * SessionHandlerInterface::write() If the record was not found, return an
   * empty string.
   *
   * The data returned by this method will be decoded internally by PHP
   * using the unserialization method specified in session.serialize_handler.
   * The resultig data will be used to populate the $_SESSION superglobal.
   *
   * Note that the serialization scheme is not the same as unserialize() and
   * can be accessed by session_decode().
   *
   * @session_id mixed   The session id.
   *
   * @return     mixed   Returns an encoded of the read data. If
   *                     nothing was read, it must return an empty string.
   *                     Note this value is returned internally to PHP for
   *                     processing.
   */
  public function read($session_id);
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/sessionhandlerinterface.write.php )
   *
   * Writes the session data to the session storage. Called by
   * session_write_close(), when session_register_shutdown() fails, or during
   * a normal shutdown. Note: SessionHandlerInterface::close() is called
   * immediately after this function.
   *
   * PHP will call this method when the session is ready to be saved and
   * closed. It encodes the session data from the $_SESSION superglobal to a
   * serialized and passes this along with the session ID to this
   * method for storage. The serialization method used is specified in the
   * session.serialize_handler setting.
   *
   * Note this method is normally called by PHP after the output buffers
   * have been closed unless explicitly called by session_write_close()
   *
   * @session_id mixed   The session id.
   * @session_data
   *             mixed   The encoded session data. This data is the result of
   *                     the PHP internally encoding the $_SESSION
   *                     superglobal to a serialized and passing it as
   *                     this parameter. Please note sessions use an
   *                     alternative serialization method.
   *
   * @return     mixed   The return value (usually TRUE on success, FALSE on
   *                     failure). Note this value is returned internally to
   *                     PHP for processing.
   */
  public function write($session_id, $session_data);
}

}

namespace {

class RedisException extends RuntimeException { }
}


namespace __SystemLib {
  class ArchiveEntryStat {
    public function __construct(
      public ?int $crc,
      public int $size,
      public ?int $compresedSize,
      public int $timestamp,
    ) {
    }
  }

  abstract class ArchiveHandler {
    abstract public function getContentsList(): Map<string, ArchiveEntryStat>;
    abstract public function read(string $path): ?string;
    abstract public function extractAllTo(string $path);
    abstract public function addFile(string $path, string $archivePath): bool;
    abstract public function close(): void;

    public function stat($path): ?ArchiveEntryStat {
      $contents = $this->getContentsList();
      if ($contents->contains($path)) {
        return $contents[$path];
      }
      return null;
    }
  }
}


namespace __SystemLib {
  final class TarArchiveHandler extends ArchiveHandler {
    private Map<string, ArchiveEntryData> $entries = Map { };
    private Map<string, string> $contents = Map { };
    private Map<string, string> $symlinks = Map { };
    private string $path = '';
    private $fp = null;

    public function __construct(string $path) {
      $this->path = $path;
      $this->entries = Map { };

      if (file_exists($path)) {
        $this->readTar();
      }
    }

    private function readTar() {
      /* If you have GNU Tar installed, you should be able to find
       * the file format documentation (including header byte offsets) at:
       * - /usr/include/tar.h
       * - the tar info page (Top/Tar Internals/Standard)
       */

      $path = $this->path;
      $fp = fopen($path, 'rb');
      $data = fread($fp, 2);
      fclose($fp);

      if ($data === "\37\213") {
        $fp = gzopen($path, 'rb');
      } else if ($data === 'BZ') {
        $fp = bzopen($path, 'r');
      } else {
        $fp = fopen($path, 'rb');
      }

      $next_file_name = null;
      while (!feof($fp)) {
        $header = fread($fp, 512);
        // skip empty blocks
        if (!trim($header)) {
          continue;
        }

        $filename = trim(substr($header, 0, 100));
        if ($next_file_name) {
          $filename = $next_file_name;
          $next_file_name = null;
        }

        $len = octdec(substr($header, 124, 12));
        $timestamp = octdec(trim(substr($header, 136, 12)));
        $type = substr($header, 156, 1);
        $this->entries[$filename] = new ArchiveEntryStat(
          /* crc = */ null,
          $len,
          /* compressed size = */ null,
          $timestamp
        );
        $data = "";
        $read_len = 0;
        while ($read_len != $len) {
          $read_data = fread($fp, $len - $read_len);
          $data .= $read_data;
          $read_len += strlen($read_data);
        }

        switch ($type) {
          case 'L':
            $next_file_name = trim($data);
            break;

          case '0':
          case "\0":
            $this->contents[$filename] = $data;
            break;

          case '2':
            // Assuming this is from GNU Tar
            $target = trim(substr($header, 157, 100), "\0");
            $this->symlinks[$filename] = $target;
            break;

          case '5':
            // Directory, ignore
            break;

          default:
            throw new \Exception("type $type is not implemented yet");
        }

        if ($len % 512 !== 0) {
          $leftover = 512 - ($len % 512);
          $zeros = fread($fp, $leftover);
          if (strlen(trim($zeros)) != 0) {
            throw new \Exception("Malformed tar. Padding isn't zeros. $zeros");
          }
        }
      }
    }

    public function getContentsList(): Map<string, ArchiveEntryStat> {
      return $this->entries;
    }

    public function read(string $path): ?string {
      if ($this->contents->contains($path)) {
        return $this->contents[$path];
      }
    }

    private function createFullPath(
      string $root,
      string $partial_path,
    ): string {
      $full_path = $root.'/'.$partial_path;
      $dir = dirname($full_path);
      if (!is_dir($dir)) {
        mkdir($dir, 0777, true);
      }
      return $full_path;
    }

    public function extractAllTo(string $root) {
      foreach ($this->contents as $path => $data) {
        file_put_contents($this->createFullPath($root, $path), $data);
      }

      // Intentional difference to PHP5: PHP5 just creates an empty
      // file.
      foreach ($this->symlinks as $path => $target) {
        symlink($target, $this->createFullPath($root, $path));
      }
    }

    public function addFile(string $path, string $archive_path) {
      if ($this->fp === null) {
        $this->fp = fopen($this->path, 'w');
      }

      if (strlen($archive_path) > 100) {
        $header = substr($archive_path, 0, 100);
        $header .= str_repeat("\0", 8); // mode
        $header .= str_repeat("\0", 8); // uid
        $header .= str_repeat("\0", 8); // gid
        $header .= str_pad(decoct(strlen($archive_path)), 11, '0', STR_PAD_LEFT)
          ."\0"; // length
        $header .= str_repeat("\0", 12); // mtime
        // Checksum in the middle...
        $header2 = 'L'; // type == long name
        $header2 .= str_repeat("\0", 100);

        // Checksum calculated as if the checksum field was spaces
        $to_checksum = $header.str_repeat(' ', 8).$header2;
        $sum = 0;
        foreach (unpack('C*', $to_checksum) as $char) {
          $sum += ord($char);
        }
        $checksum = str_pad(decoct($sum), 6, '0', STR_PAD_LEFT)."\0 ";
        fwrite($this->fp, str_pad($header.$checksum.$header2, 512, "\0"));
        $partial_block = strlen($archive_path) % 512;
        $padding = '';
        if ($partial_block !== 0) {
          $padding = str_repeat("\0", 512 - $partial_block);
        }
        fwrite($this->fp, $archive_path.$padding);
      }

      $stat = stat($path);
      $header = str_pad(substr($archive_path, 0, 100), 100, "\0");
      $header .= str_pad(decoct($stat['mode']), 7, '0', STR_PAD_LEFT)."\0";
      $header .= str_pad(decoct($stat['uid']), 7, '0', STR_PAD_LEFT)."\0";
      $header .= str_pad(decoct($stat['gid']), 7, '0', STR_PAD_LEFT)."\0";
      $header .= str_pad(decoct($stat['size']), 11, '0', STR_PAD_LEFT)."\0";
      $header .= str_pad(decoct($stat['mtime']), 11, '0', STR_PAD_LEFT)."\0";
      // Checksum in the middle...
      $header2 = '0'; // type == normal file
      $header2 .= str_repeat("\0", 100);

      // Checksum calculated as if the checksum field was spaces
      $to_checksum = $header.str_repeat(' ', 8).$header2;
      $sum = 0;
      foreach (unpack('C*', $to_checksum) as $char) {
        $sum += ord($char);
      }
      $checksum = str_pad(decoct($sum), 6, '0', STR_PAD_LEFT)."\0 ";
      fwrite($this->fp, str_pad($header.$checksum.$header2, 512, "\0"));
      $partial_block = $stat['size'] % 512;
      $padding = '';
      if ($partial_block !== 0) {
        $padding = str_repeat("\0", 512 - $partial_block);
      }
      fwrite($this->fp, file_get_contents($path).$padding);
      return true;
    }

    public function close(): void {
      if ($this->fp !== null) {
        fwrite($this->fp, str_repeat("\0", 1024));
        fclose($this->fp);
        $this->fp = null;
      }
    }
  }
}


namespace __SystemLib {
  final class ZipArchiveHandler extends ArchiveHandler {
    private \ZipArchive $za;
    private ?Map<string, ArchiveEntryData> $contents;
    private string $path = '';

    public function __construct(string $path) {
      $this->path = $path;
      $this->za = new \ZipArchive();
      if (file_exists($path)) {
        $this->za->open($path);
      } else {
        $this->za->open($path, \ZipArchive::CREATE);
      }
    }

    public function close(): void {
      $this->za->close();
    }

    public function getContentsList(): Map<string, ArchiveEntryStat> {
      $contents = $this->contents;
      if ($contents !== null) {
        return $contents;
      }

      $contents = Map { };
      for ($i = 0; $i < $this->za->numFiles; ++$i) {
        $fname = $this->za->getNameIndex($i);
        if (substr($fname, -1) === '/') {
          continue;
        }
        $stat = $this->za->statIndex($i);
        $contents[$fname] = new ArchiveEntryStat(
          $stat['crc'],
          $stat['size'],
          $stat['comp_size'],
          $stat['mtime'],
        );
      }
      $this->contents = $contents;
      return $contents;
    }

    public function read(string $path): ?string {
      $data = $this->za->getFromName($path);
      if ($data === false) {
        return null;
      }
      return $data;
    }

    public function extractAllTo(string $path) {
      return $this->za->extractTo($path);
    }

    public function addFile(string $path, string $archive_path): bool {
      return $this->za->addFile($path, $archive_path);
    }
  }
}

namespace {
// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.pharexception.php )
 *
 * The PharException class provides a phar-specific exception class for
 * try/catch blocks.
 *
 */
class PharException extends Exception {
}
}

namespace {
// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.phar.php )
 *
 * The Phar class provides a high-level interface to accessing and
 * creating phar archives.
 *
 */
class Phar extends RecursiveDirectoryIterator
  implements Countable, ArrayAccess {

  const NONE = 0;
  const COMPRESSED = 0x0000F000;
  const GZ = 0x00001000;
  const BZ2 = 0x00002000;
  const SIGNATURE = 0x00010000;

  const SAME = 0;
  const PHAR = 1;
  const TAR = 2;
  const ZIP = 3;

  const MD5 = 0x0001;
  const SHA1 = 0x0002;
  const SHA256 = 0x0003;
  const SHA512 = 0x0004;
  const OPENSSL = 0x0010;

  const PHP = 1;
  const PHPS = 2;

  /**
   * A map from filename_or_alias => Phar object
   */
  private static $aliases = array();
  /**
   * Prevent the check for __HALT_COMPILER()
   */
  private static $preventHaltTokenCheck = false;

  private $alias;
  private $fileInfo = array();
  private $fileOffsets = array();
  private $stub;
  private $manifest;
  private $contents;
  private $signature;

  private $count;
  private $apiVersion;
  private $archiveFlags;
  private $metadata;
  private $signatureFlags;

  private $iteratorRoot;
  private $iterator;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.construct.php )
   *
   *
   * @filename   mixed   Path to an existing Phar archive or to-be-created
   *                     archive. The file name's extension must contain
   *                     .phar.
   * @flags      mixed   Flags to pass to parent class
   *                     RecursiveDirectoryIterator.
   * @alias      mixed   Alias with which this Phar archive should be
   *                     referred to in calls to stream functionality.
   */
  public function __construct($filename, $flags = null, $alias = null) {
    if (!is_file($filename)) {
      throw new PharException("$filename is not a file");
    }
    $data = file_get_contents($filename);

    $halt_token = "__HALT_COMPILER();";
    $pos = strpos($data, $halt_token);
    if ($pos === false && !self::$preventHaltTokenCheck) {
      throw new PharException("__HALT_COMPILER(); must be declared in a phar");
    }
    $this->stub = substr($data, 0, $pos);

    $pos += strlen($halt_token);
    // *sigh*. We have to allow whitespace then ending the file
    // before we start the manifest
    while ($data[$pos] == ' ') {
      $pos += 1;
    }
    if ($data[$pos] == '?' && $data[$pos+1] == '>') {
      $pos += 2;
    }
    while ($data[$pos] == "\r") {
      $pos += 1;
    }
    while ($data[$pos] == "\n") {
      $pos += 1;
    }

    $this->contents = substr($data, $pos);
    $this->parsePhar($data, $pos);

    if ($alias) {
      self::$aliases[$alias] = $this;
    }
    // From the manifest
    if ($this->alias) {
      self::$aliases[$this->alias] = $this;
    }
    // We also do filename lookups
    self::$aliases[$filename] = $this;

    $this->iteratorRoot = 'phar://'.realpath($filename).'/';
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.addemptydir.php )
   *
   *
   * @dirname    mixed   The name of the empty directory to create in the
   *                     phar archive
   *
   * @return     mixed   no return value, exception is thrown on failure.
   */
  public function addEmptyDir($dirname) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.addfile.php )
   *
   *
   * @filename   mixed   Full or relative path to a file on disk to be added
   *                     to the phar archive.
   * @localname  mixed   Path that the file will be stored in the archive.
   *
   * @return     mixed   no return value, exception is thrown on failure.
   */
  public function addFile($filename, $localname = null) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.addfromstring.php )
   *
   *
   * @localname  mixed   Path that the file will be stored in the archive.
   * @contents   mixed   The file contents to store
   *
   * @return     mixed   no return value, exception is thrown on failure.
   */
  public function addFromString($localname, $contents) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.buildfromdirectory.php )
   *
   *
   * @base_dir   mixed   The full or relative path to the directory that
   *                     contains all files to add to the archive.
   * @regex      mixed   An optional pcre regular expression that is used to
   *                     filter the list of files. Only file paths matching
   *                     the regular expression will be included in the
   *                     archive.
   *
   * @return     mixed   Phar::buildFromDirectory() returns an associative
   *                     array mapping internal path of file to the full path
   *                     of the file on the filesystem.
   */
  public function buildFromDirectory($base_dir, $regex = null) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.buildfromiterator.php )
   *
   *
   * @iterator   mixed   Any iterator that either associatively maps phar
   *                     file to location or returns SplFileInfo objects
   * @base_directory
   *             mixed   For iterators that return SplFileInfo objects, the
   *                     portion of each file's full path to remove when
   *                     adding to the phar archive
   *
   * @return     mixed   Phar::buildFromIterator() returns an associative
   *                     array mapping internal path of file to the full path
   *                     of the file on the filesystem.
   */
  public function buildFromIterator($iterator, $base_directory = null) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.compressfiles.php )
   *
   *
   * @compression_type
   *             mixed   Compression must be one of Phar::GZ, Phar::BZ2 to
   *                     add compression, or Phar::NONE to remove
   *                     compression.
   *
   * @return     mixed   No value is returned.
   */
  public function compressFiles($compression_type) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.decompressfiles.php )
   *
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function decompressFiles() {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.compress.php )
   *
   *
   * @compression_type
   *             mixed   Compression must be one of Phar::GZ, Phar::BZ2 to
   *                     add compression, or Phar::NONE to remove
   *                     compression.
   * @file_ext   mixed   By default, the extension is .phar.gz or .phar.bz2
   *                     for compressing phar archives, and .phar.tar.gz or
   *                     .phar.tar.bz2 for compressing tar archives. For
   *                     decompressing, the default file extensions are .phar
   *                     and .phar.tar.
   *
   * @return     mixed   Returns a Phar object.
   */
  public function compress($compression_type, $file_ext = null) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.decompress.php )
   *
   *
   * @file_ext   mixed   For decompressing, the default file extensions are
   *                     .phar and .phar.tar. Use this parameter to specify
   *                     another file extension. Be aware that all executable
   *                     phar archives must contain .phar in their filename.
   *
   * @return     mixed   A Phar object is returned.
   */
  public function decompress($file_ext = null) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.converttoexecutable.php )
   *
   *
   * @format     mixed   This should be one of Phar::PHAR, Phar::TAR, or
   *                     Phar::ZIP. If set to NULL, the existing file format
   *                     will be preserved.
   * @compression_type
   *             mixed   This should be one of Phar::NONE for no
   *                     whole-archive compression, Phar::GZ for zlib-based
   *                     compression, and Phar::BZ2 for bzip-based
   *                     compression.
   * @file_ext   mixed   This parameter is used to override the default file
   *                     extension for a converted archive. Note that all
   *                     zip- and tar-based phar archives must contain .phar
   *                     in their file extension in order to be processed as
   *                     a phar archive.
   *
   *                     If converting to a phar-based archive, the default
   *                     extensions are .phar, .phar.gz, or .phar.bz2
   *                     depending on the specified compression. For
   *                     tar-based phar archives, the default extensions are
   *                     .phar.tar, .phar.tar.gz, and .phar.tar.bz2. For
   *                     zip-based phar archives, the default extension is
   *                     .phar.zip.
   *
   * @return     mixed   The method returns a Phar object on success and
   *                     throws an exception on failure.
   */
  public function convertToExecutable($format = 9021976,
                                      $compression_type = 9021976,
                                      $file_ext = null) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.converttodata.php )
   *
   * This method is used to convert an executable phar archive to either a
   * tar or zip file. To make the tar or zip non-executable, the phar stub
   * and phar alias files are removed from the newly created archive.
   *
   * If no changes are specified, this method throws a
   * BadMethodCallException if the archive is in phar file format. For
   * archives in tar or zip file format, this method converts the archive to
   * a non-executable archive.
   *
   * If successful, the method creates a new archive on disk and returns a
   * PharData object. The old archive is not removed from disk, and should be
   * done manually after the process has finished.
   *
   * @format     mixed   This should be one of Phar::TAR or Phar::ZIP. If set
   *                     to NULL, the existing file format will be preserved.
   * @compression_type
   *             mixed   This should be one of Phar::NONE for no
   *                     whole-archive compression, Phar::GZ for zlib-based
   *                     compression, and Phar::BZ2 for bzip-based
   *                     compression.
   * @file_ext   mixed   This parameter is used to override the default file
   *                     extension for a converted archive. Note that .phar
   *                     cannot be used anywhere in the filename for a
   *                     non-executable tar or zip archive.
   *
   *                     If converting to a tar-based phar archive, the
   *                     default extensions are .tar, .tar.gz, and .tar.bz2
   *                     depending on specified compression. For zip-based
   *                     archives, the default extension is .zip.
   *
   * @return     mixed   The method returns a PharData object on success and
   *                     throws an exception on failure.
   */
  public function convertToData($format = 9021976,
                                $compression_type = 9021976,
                                $file_ext = null) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.copy.php )
   *
   *
   * @newfile    mixed
   * @oldfile    mixed
   *
   * @return     mixed   returns TRUE on success, but it is safer to encase
   *                     method call in a try/catch block and assume success
   *                     if no exception is thrown.
   */
  public function copy($newfile, $oldfile) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.count.php )
   *
   *
   * @return     mixed   The number of files contained within this phar, or 0
   *                     (the number zero) if none.
   */
  public function count() {
    return $this->count;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.delete.php )
   *
   *
   * @entry      mixed   Path within an archive to the file to delete.
   *
   * @return     mixed   returns TRUE on success, but it is better to check
   *                     for thrown exception, and assume success if none is
   *                     thrown.
   */
  public function delete($entry) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.delmetadata.php )
   *
   *
   * @return     mixed   returns TRUE on success, but it is better to check
   *                     for thrown exception, and assume success if none is
   *                     thrown.
   */
  public function delMetadata() {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.extractto.php )
   *
   *
   * @pathto     mixed   Path within an archive to the file to delete.
   * @files      mixed   The name of a file or directory to extract, or an
   *                     array of files/directories to extract
   * @overwrite  mixed   Set to TRUE to enable overwriting existing files
   *
   * @return     mixed   returns TRUE on success, but it is better to check
   *                     for thrown exception, and assume success if none is
   *                     thrown.
   */
  public function extractTo($pathto, $files = null, $overwrite = false) {
    throw new UnexpectedValueException('phar is read-only');
  }

  public function getAlias() {
    return $this->alias;
  }

  public function getPath() {
    return $this->path;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.getmetadata.php )
   *
   * Retrieve archive meta-data. Meta-data can be any PHP variable that can
   * be serialized.
   * No parameters.
   *
   * @return     mixed   any PHP variable that can be serialized and is
   *                     stored as meta-data for the Phar archive, or NULL if
   *                     no meta-data is stored.
   */
  public function getMetadata() {
    return $this->metadata;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.getmodified.php )
   *
   * This method can be used to determine whether a phar has either had an
   * internal file deleted, or contents of a file changed in some way.
   * No parameters.
   *
   * @return     mixed   TRUE if the phar has been modified since opened,
   *                     FALSE if not.
   */
  public function getModified() {
    return false;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.getsignature.php )
   *
   * Returns the verification signature of a phar archive in a hexadecimal
   * string.
   *
   * @return     mixed   Array with the opened archive's signature in hash
   *                     key and MD5, SHA-1, SHA-256, SHA-512, or OpenSSL in
   *                     hash_type. This signature is a hash calculated on
   *                     the entire phar's contents, and may be used to
   *                     verify the integrity of the archive. A valid
   *                     signature is absolutely required of all executable
   *                     phar archives if the phar.require_hash INI variable
   *                     is set to true.
   */
  public function getSignature() {
    return null;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.getstub.php )
   *
   * Phar archives contain a bootstrap loader, or stub written in PHP that
   * is executed when the archive is executed in PHP either via include:
   *
   * or by simple execution: php myphar.phar
   *
   * @return     mixed   Returns a string containing the contents of the
   *                     bootstrap loader (stub) of the current Phar archive.
   */
  public function getStub() {
    return $this->stub;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.getversion.php )
   *
   * Returns the API version of an opened Phar archive.
   *
   * @return     mixed   The opened archive's API version. This is not to be
   *                     confused with the API version that the loaded phar
   *                     extension will use to create new phars. Each Phar
   *                     archive has the API version hard-coded into its
   *                     manifest. See Phar file format documentation for
   *                     more information.
   */
  public function getVersion() {
    return $this->apiVersion;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.hasmetadata.php )
   *
   * Returns whether phar has global meta-data set.
   * No parameters.
   *
   * @return     mixed   Returns TRUE if meta-data has been set, and FALSE if
   *                     not.
   */
  public function hasMetadata() {
    return $this->metadata !== null;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.isbuffering.php )
   *
   * This method can be used to determine whether a Phar will save changes
   * to disk immediately, or whether a call to Phar::stopBuffering() is
   * needed to enable saving changes.
   *
   * Phar write buffering is per-archive, buffering active for the foo.phar
   * Phar archive does not affect changes to the bar.phar Phar archive.
   *
   * @return     mixed   Returns TRUE if the write operations are being
   *                     buffer, FALSE otherwise.
   */
  public function isBuffering() {
    return false;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.iscompressed.php )
   *
   *
   * No parameters.
   *
   * @return     mixed   Phar::GZ, Phar::BZ2 or FALSE
   */
  public function isCompressed() {
    return false;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.isfileformat.php )
   *
   *
   * @fileformat mixed   Either Phar::PHAR, Phar::TAR, or Phar::ZIP to test
   *                     for the format of the archive.
   *
   * @return     mixed   Returns TRUE if the phar archive matches the file
   *                     format requested by the parameter
   */
  public function isFileFormat($fileformat) {
    return $fileformat === self::PHAR;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.iswritable.php )
   *
   * This method returns TRUE if phar.readonly is 0, and the actual phar
   * archive on disk is not read-only.
   * No parameters.
   *
   * @return     mixed   Returns TRUE if the phar archive can be modified
   */
  public function isWritable() {
    return false;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.offsetexists.php )
   *
   * This is an implementation of the ArrayAccess interface allowing direct
   * manipulation of the contents of a Phar archive using array access
   * brackets.
   *
   * offsetExists() is called whenever isset() is called.
   *
   * @entry      mixed   The filename (relative path) to look for in a Phar.
   *
   * @return     mixed   Returns TRUE if the file exists within the phar, or
   *                     FALSE if not.
   */
  public function offsetExists($entry) {
    return isset($this->fileInfo[$entry]);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.offsetget.php )
   *
   * This is an implementation of the ArrayAccess interface allowing direct
   * manipulation of the contents of a Phar archive using array access
   * brackets. Phar::offsetGet() is used for retrieving files from a Phar
   * archive.
   *
   * @entry      mixed   The filename (relative path) to look for in a Phar.
   *
   * @return     mixed   A PharFileInfo object is returned that can be used
   *                     to iterate over a file's contents or to retrieve
   *                     information about the current file.
   */
  public function offsetGet($entry) {
    if (!$this->offsetExists($entry)) {
      return null;
    }
    $fi = $this->fileInfo[$entry];
    return new PharFileInfo(
      $this->iteratorRoot.$entry,
      new __SystemLib\ArchiveEntryStat(
        $fi[3], // crc32
        $fi[0], // size
        $fi[2], // compressed size
        $fi[1], // timestamp
      )
    );
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.offsetset.php )
   *
   *
   * @entry      mixed   The filename (relative path) to modify in a Phar.
   * @value      mixed   Content of the file.
   *
   * @return     mixed   No return values.
   */
  public function offsetSet($entry, $value) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.offsetunset.php )
   *
   *
   * @entry      mixed   The filename (relative path) to modify in a Phar.
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function offsetUnset($entry) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.setalias.php )
   *
   *
   * @alias      mixed   A shorthand string that this archive can be referred
   *                     to in phar stream wrapper access.
   */
  public function setAlias($alias) {
    $this->alias = $alias;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.setdefaultstub.php )
   *
   *
   * @index      mixed   Relative path within the phar archive to run if
   *                     accessed on the command-line
   * @webindex   mixed   Relative path within the phar archive to run if
   *                     accessed through a web browser
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function setDefaultStub($index, $webindex = null) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.setmetadata.php )
   *
   *
   * @metadata   mixed   Any PHP variable containing information to store
   *                     that describes the phar archive
   *
   * @return     mixed   No value is returned.
   */
  public function setMetadata($metadata) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.setsignaturealgorithm.php )
   *
   *
   * @algorithm  mixed   One of Phar::MD5, Phar::SHA1, Phar::SHA256,
   *                     Phar::SHA512, or Phar::OPENSSL
   * @privatekey mixed   The contents of an OpenSSL private key, as extracted
   *                     from a certificate or OpenSSL key file:
   *
   *                     See phar introduction for instructions on naming
   *                     and placement of the public key file.
   *
   * @return     mixed   No value is returned.
   */
  public function setSignatureAlgorithm($algorithm, $privatekey = null) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.setstub.php )
   *
   *
   * @newstub    mixed   A string or an open stream handle to use as the
   *                     executable stub for this phar archive.
   * @maxlen     mixed
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function setStub($newstub, $maxlen = -1) {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.startbuffering.php )
   *
   * Although technically unnecessary, the Phar::startBuffering() method can
   * provide a significant performance boost when creating or modifying a
   * Phar archive with a large number of files. Ordinarily, every time a file
   * within a Phar archive is created or modified in any way, the entire Phar
   * archive will be recreated with the changes. In this way, the archive
   * will be up-to-date with the activity performed on it.
   *
   * However, this can be unnecessary when simply creating a new Phar
   * archive, when it would make more sense to write the entire archive out
   * at once. Similarly, it is often necessary to make a series of changes
   * and to ensure that they all are possible before making any changes on
   * disk, similar to the relational database concept of transactions. the
   * Phar::startBuffering()/ Phar::stopBuffering() pair of methods is
   * provided for this purpose.
   *
   * Phar write buffering is per-archive, buffering active for the foo.phar
   * Phar archive does not affect changes to the bar.phar Phar archive.
   *
   * @return     mixed   No value is returned.
   */
  public function startBuffering() {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.stopbuffering.php )
   *
   * Phar::stopBuffering() is used in conjunction with the
   * Phar::startBuffering() method. Phar::startBuffering() can provide a
   * significant performance boost when creating or modifying a Phar archive
   * with a large number of files. Ordinarily, every time a file within a
   * Phar archive is created or modified in any way, the entire Phar archive
   * will be recreated with the changes. In this way, the archive will be
   * up-to-date with the activity performed on it.
   *
   * However, this can be unnecessary when simply creating a new Phar
   * archive, when it would make more sense to write the entire archive out
   * at once. Similarly, it is often necessary to make a series of changes
   * and to ensure that they all are possible before making any changes on
   * disk, similar to the relational database concept of transactions. The
   * Phar::startBuffering()/ Phar::stopBuffering() pair of methods is
   * provided for this purpose.
   *
   * Phar write buffering is per-archive, buffering active for the foo.phar
   * Phar archive does not affect changes to the bar.phar Phar archive.
   *
   * @return     mixed   No value is returned.
   */
  public function stopBuffering() {
    throw new UnexpectedValueException('phar is read-only');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.canwrite.php )
   *
   * This static method determines whether write access has been disabled in
   * the system php.ini via the phar.readonly ini variable.
   *
   * @return     mixed   TRUE if write access is enabled, FALSE if it is
   *                     disabled.
   */
  public static function canWrite()  {
    return false;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.apiversion.php )
   *
   * Return the API version of the phar file format that will be used when
   * creating phars. The Phar extension supports reading API version 1.0.0 or
   * newer. API version 1.1.0 is required for SHA-256 and SHA-512 hash, and
   * API version 1.1.1 is required to store empty directories.
   *
   * @return     mixed   The API version string as in "1.0.0".
   */
  final public static function apiVersion() {
    return '1.0.0';
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.cancompress.php )
   *
   * This should be used to test whether compression is possible prior to
   * loading a phar archive containing compressed files.
   *
   * @type       mixed   Either Phar::GZ or Phar::BZ2 can be used to test
   *                     whether compression is possible with a specific
   *                     compression algorithm (zlib or bzip2).
   *
   * @return     mixed   TRUE if compression/decompression is available,
   *                     FALSE if not.
   */
  final public static function canCompress($type = 0) {
    return false;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.getsupportedcompression.php
   * )
   *
   *
   * No parameters.
   *
   * @return     mixed   Returns an array containing any of Phar::GZ or
   *                     Phar::BZ2, depending on the availability of the zlib
   *                     extension or the bz2 extension.
   */
  final public static function getSupportedCompression() {
    return array();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.getsupportedsignatures.php
   * )
   *
   * Return array of supported signature types
   * No parameters.
   *
   * @return     mixed   Returns an array containing any of MD5, SHA-1,
   *                     SHA-256, SHA-512, or OpenSSL.
   */
  final public static function getSupportedSignatures () {
    return array();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.loadphar.php )
   *
   * This can be used to read the contents of an external Phar archive. This
   * is most useful for assigning an alias to a phar so that subsequent
   * references to the phar can use the shorter alias, or for loading Phar
   * archives that only contain data and are not intended for
   * execution/inclusion in PHP scripts.
   *
   * @filename   mixed   the full or relative path to the phar archive to
   *                     open
   * @alias      mixed   The alias that may be used to refer to the phar
   *                     archive. Note that many phar archives specify an
   *                     explicit alias inside the phar archive, and a
   *                     PharException will be thrown if a new alias is
   *                     specified in this case.
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  final public static function loadPhar($filename, $alias = null) {
    new self($filename, null, $alias);
    return true;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.mapphar.php )
   *
   * This static method can only be used inside a Phar archive's loader stub
   * in order to initialize the phar when it is directly executed, or when it
   * is included in another script.
   *
   * @alias      mixed   The alias that can be used in phar:// URLs to refer
   *                     to this archive, rather than its full path.
   * @dataoffset mixed   Unused variable, here for compatibility with PEAR's
   *                     PHP_Archive.
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public static function mapPhar($alias = null, $dataoffset = 0) {
    new self(debug_backtrace()[0]['file'], null, $alias);
    return true;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phar.interceptfilefuncs.php )
   *
   * instructs phar to intercept fopen(), readfile(), file_get_contents(),
   * opendir(), and all of the stat-related functions. If any of these
   * functions is called from within a phar archive with a relative path, the
   * call is modified to access a file within the phar archive. Absolute
   * paths are assumed to be attempts to load external files from the
   * filesystem.
   *
   * This function makes it possible to run PHP applications designed to run
   * off of a hard disk as a phar application.
   * No parameters.
   *
   */
  public static function interceptFileFuncs() {
    // Not supported (yet) but most phars call it, so don't throw
  }

  /**
  *
  * ( excerpt from http://docs.hhvm/com/manual/en/phar.running.php )
  * Returns the full path to the running phar archive. This is intended
  * for use much like the __FILE__ magic constant, and only has effect
  * inside an executing phar archive.
  *
  * Inside the stub of an archive, function Phar::running() returns "".
  * Simply use __FILE__ to access the current running phar inside a stub
  *
  * @retphar   boolean if FALSE, the full path on disk to the phar archive
  *                    is returned. If TRUE, a full phar URL is returned
  * @return    string  Returns the filename if valid, empty string otherwise
  */
  final public static function running(bool $retphar = true) {
    $filename = debug_backtrace()[0]['file'];
    $pharScheme = "phar://";
    $pharExt = ".phar";
    if(substr($filename, 0, strlen($pharScheme)) == $pharScheme) {
      $pharExtPos = strrpos($filename, $pharExt);
      if($pharExtPos) {
        $endPos = $pharExtPos + strlen($pharExt);
        if($retphar) {
          return substr($filename, 0, $endPos);
        }
        else {
          return substr($filename, strlen($pharScheme),
            $endPos - strlen($pharScheme));
        }
      }
    }
    return "";
  }

  final public static function webPhar(
      $alias,
      $index = "index.php",
      $f404 = null,
      $mimetypes = null,
      $rewrites = null) {
    // This is in the default stub, but lets ignore it for now
  }

  private static function bytesToInt($str, &$pos, $len) {
    if (strlen($str) < $pos + $len) {
      throw new PharException(
        "Corrupt phar, can't read $len bytes starting at offset $pos"
      );
    }
    $int = 0;
    for ($i = 0; $i < $len; ++$i) {
      $int |= ord($str[$pos++]) << (8*$i);
    }
    return $int;
  }

  private static function substr($str, &$pos, $len) {
    $ret = substr($str, $pos, $len);
    $pos += $len;
    return $ret;
  }

  private function parsePhar($data, &$pos) {
    $start = $pos;
    $len = self::bytesToInt($data, $pos, 4);
    $this->count = self::bytesToInt($data, $pos, 4);
    $this->apiVersion = self::bytesToInt($data, $pos, 2);
    $this->archiveFlags = self::bytesToInt($data, $pos, 4);
    $alias_len = self::bytesToInt($data, $pos, 4);
    $this->alias = self::substr($data, $pos, $alias_len);
    $metadata_len = self::bytesToInt($data, $pos, 4);
    $this->metadata = unserialize(
      self::substr($data, $pos, $metadata_len)
    );
    $this->parseFileInfo($data, $pos);
    if ($pos != $start + $len + 4) {
      throw new PharException(
        "Malformed manifest. Expected $len bytes, got $pos"
      );
    }
    foreach ($this->fileInfo as $key => $info) {
      $this->fileOffsets[$key] = array($pos - $start, $info[2]);
      $pos += $info[2];
    }

    // Try to see if there is a signature
    if (($this->archiveFlags & self::SIGNATURE)) {
      if (strlen($data) < 8 || substr($data, -4) !== "GBMB") {
        // Not even the GBMB and the flags?
        throw new PharException("phar has a broken signature");
      }

      $pos = strlen($data) - 8;
      $this->signatureFlags = self::bytesToInt($data, $pos, 4);
      switch ($this->signatureFlags) {
        case self::MD5:
          $digestSize = 16;
          $digestName = "md5";
          break;
        case self::SHA1:
          $digestSize = 20;
          $digestName = "sha1";
          break;
        case self::SHA256:
          $digestSize = 32;
          $digestName = "sha256";
          break;
        case self::SHA512:
          $digestSize = 64;
          $digestName = "sha512";
          break;
        default:
          throw new PharException("phar has a broken or unsupported signature");
      }

      if (strlen($data) < 8 + $digestSize) {
        throw new PharException("phar has a broken signature");
      }

      $pos -= 4;
      $signatureStart = $pos - $digestSize;
      $this->signature = substr($data, $signatureStart, $digestSize);
      $actualHash = self::verifyHash($data, $digestName, $signatureStart);

      if ($actualHash !== $this->signature) {
        throw new PharException("phar has a broken signature");
      }
    }
  }

  private function parseFileInfo($str, &$pos) {
    for ($i = 0; $i < $this->count; $i++) {
      $filename_len = self::bytesToInt($str, $pos, 4);
      $filename = self::substr($str, $pos, $filename_len);
      $filesize = self::bytesToInt($str, $pos, 4);
      $timestamp = self::bytesToInt($str, $pos, 4);
      $compressed_filesize = self::bytesToInt($str, $pos, 4);
      $crc32 = self::bytesToInt($str, $pos, 4);
      $flags = self::bytesToInt($str, $pos, 4);
      $metadata_len = self::bytesToInt($str, $pos, 4);
      $metadata = self::bytesToInt($str, $pos, $metadata_len);
      $this->fileInfo[$filename] = array(
        $filesize, $timestamp, $compressed_filesize, $crc32, $flags, $metadata
      );
    }
  }

  private static function verifyHash($str, $algorithm, $signatureOffset) {
    return hash($algorithm, substr($str, 0, $signatureOffset), true);
  }

  /**
   * A poor man's FileUtil::canonicalize in PHP
   */
  private static function resolveDotDots($pieces) {
    $starts_with_slash = false;
    if (count($pieces) > 0 && !strlen($pieces[0])) {
      $starts_with_slash = true;
    }

    foreach ($pieces as $i => $piece) {
      if ($piece == '.') {
        $piece[$i] = '';
      } else if ($piece == '..' && $i > 0) {
        $pieces[$i] = '';
        while ($i > 0 && !$pieces[$i-1]) {
          $i--;
        }
        $pieces[$i-1] = '';
      }
    }
    // strlen is used to remove empty strings, but keep values of 0 (zero)
    return ($starts_with_slash ? '/' : '') .
           implode('/', array_filter($pieces, 'strlen'));
  }

  /**
   * BELOW THIS ISN'T PART OF THE ZEND API. THEY ARE FOR THE STREAM WRAPPER.
   */

  /**
   * For the stream wrapper to stat a file. Same response format as stat().
   * Called from C++.
   */
  private static function stat($full_filename) {
    list($phar, $filename) = self::getPharAndFile($full_filename);
    if (!isset($phar->fileInfo[$filename])) {
      $dir = self::opendir($full_filename);
      if (!$dir) {
        return false;
      }

      return array(
        'size' => 0,
        'atime' => 0,
        'mtime' => 0,
        'ctime' => 0,
        'mode' => POSIX_S_IFDIR,
      );
    }

    $info = $phar->fileInfo[$filename];
    return array(
      'size' => $info[0],
      'atime' => $info[1],
      'mtime' => $info[1],
      'ctime' => $info[1],
      'mode' => POSIX_S_IFREG,
    );
  }

  /**
   * Simulates opendir() and readdir() and rewinddir() using an array.
   * Returns any files that start with $prefix.
   * Called from C++.
   */
  private static function opendir($full_prefix) {
    list($phar, $prefix) = self::getPharAndFile($full_prefix);
    $prefix = rtrim($prefix, '/');

    $ret = array();
    foreach ($phar->fileInfo as $filename => $_) {
      if (!$prefix) {
        if (strpos($filename, '/') === false) {
          $ret[$filename] = true;
        }
      } else {
        if (strpos($filename, $prefix) === 0) {
          $entry = substr($filename, strlen($prefix) + 1);
          if (strlen($entry) > 0) {
            if ($filename[strlen($prefix)] != '/') {
              continue;
            }
            $next_slash = strpos($entry, '/');
            if ($next_slash !== false) {
              $entry = substr($entry, 0, $next_slash);
            }
            $ret[$entry] = true;
          }
        }
      }
    }
    return array_keys($ret);
  }

  /**
   * Used by the stream wrapper to open phar:// files.
   * Called from C++.
   */
  private static function openPhar($full_filename) {
    list($phar, $filename) = self::getPharAndFile($full_filename);
    return $phar->getFileData($filename);
  }

  private function getFileData($filename) {
    if (!isset($this->fileOffsets[$filename])) {
      throw new PharException("No $filename in phar");
    }
    $offsets = $this->fileOffsets[$filename];
    return substr($this->contents, $offsets[0], $offsets[1]);
  }

  /**
   * Checks through a phar://path/to/file.phar/other/path.php and returns
   *
   *   array([Phar object for path/to/file.phar], 'other/path.php')
   *
   * or if the first piece is a valid alias, then returns
   *
   *   array([Phar object for alias], 'rest/of/path.php')
   */
  private static function getPharAndFile($filename_or_alias) {
    if (strncmp($filename_or_alias, 'phar://', 7)) {
      throw new PharException("Not a phar: $filename_or_alias");
    }

    $pieces = explode('/', substr($filename_or_alias, 7));

    if (count($pieces) > 0 && isset(self::$aliases[$pieces[0]])) {
      $alias = array_shift($pieces);
      return array(
        self::$aliases[$alias],
        self::resolveDotDots($pieces)
      );
    }

    $filename = '';
    while ($pieces) {
      $filename .= '/'.array_shift($pieces);
      if (is_file($filename)) {

        if (!isset(self::$aliases[$filename])) {
          // We need this hack because the stream wrapper should work
          // even without the __HALT_COMPILER token
          self::$preventHaltTokenCheck = true;
          self::loadPhar($filename);
          self::$preventHaltTokenCheck = false;
        }

        return array(
          self::$aliases[$filename],
          self::resolveDotDots($pieces)
        );
      }
    }

    throw new PharException("Not a phar: $filename_or_alias");
  }

  protected function getIteratorFromList(string $root, array $list) {
    $tree = array();
    foreach ($list as $filename => $info) {
      $dir = dirname($filename);
      $current = &$tree;
      if ($dir !== '') {
        $path = $root;
        foreach (explode('/', $dir) as $part) {
          $path .= $part.'/';
          if (!isset($current[$path])) {
            $current[$path] = array();
          }
          $current = &$current[$path];
        }
      }
      $current[$root.$filename] = $info;
    }
    return new RecursiveArrayIterator(
      $tree,
      RecursiveArrayIterator::CHILD_ARRAYS_ONLY
    );
  }

  protected function getIterator() {
    if ($this->iterator !== null) {
      return $this->iterator;
    }
    $filenames = array_keys($this->fileInfo);
    $info = array();
    foreach ($filenames as $filename) {
      $info[$filename] = $this->offsetGet($filename);
    }
    $this->iterator = $this->getIteratorFromList($this->iteratorRoot, $info);
    return $this->iterator;
  }

  public function key() {
    return $this->getIterator()->key();
  }

  public function current() {
    return $this->getIterator()->current();
  }

  public function next() {
    $this->getIterator()->next();
  }

  public function rewind() {
    $this->getIterator()->rewind();
  }

  public function valid() {
    return $this->getIterator()->valid();
  }

  public function hasChildren() {
    return $this->getIterator()->hasChildren();
  }

  public function getChildren() {
    return $this->getIterator()->getChildren();
  }
}
}

namespace {
// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.pharfileinfo.php )
 *
 * The PharFileInfo class provides a high-level interface to the contents
 * and attributes of a single file within a phar archive.
 *
 */
class PharFileInfo extends SplFileInfo {

  private $name;
  private $stat;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.construct.php )
   *
   * This should not be called directly. Instead, a PharFileInfo object is
   * initialized by calling Phar::offsetGet() through array access.
   *
   * @filename   mixed   The full url to retrieve a file. If you wish to
   *                     retrieve the information for the file my/file.php
   *                     from the phar boo.phar, the entry should be
   *                     phar://boo.phar/my/file.php.
   */
  public function __construct($filename, $data) {
    if (!($data instanceof __SystemLib\ArchiveEntryStat)) {
      throw new UnexpectedValueException(
        "PharFileInfo can only be constructed via Phar::offsetGet()"
      );
    }
    parent::__construct($filename);
    $this->name = $filename;
    $this->stat = $data;
  }

  public function getPathName() {
    return $this->name;
  }

  public function __destruct() {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.chmod.php )
   *
   * PharFileInfo::chmod() allows setting of the executable file permissions
   * bit, as well as read-only bits. Writable bits are ignored, and set at
   * runtime based on the phar.readonly INI variable. As with all
   * functionality that modifies the contents of a phar, the phar.readonly
   * INI variable must be off in order to succeed if the file is within a
   * Phar archive. Files within PharData archives do not have this
   * restriction.
   *
   * @perms      mixed   permissions (see chmod())
   *
   * @return     mixed   No value is returned.
   */
  public function chmod($perms) {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.compress.php )
   *
   * This method compresses the file inside the Phar archive using either
   * bzip2 compression or zlib compression. The bzip2 or zlib extension must
   * be enabled to take advantage of this feature. In addition, if the file
   * is already compressed, the respective extension must be enabled in order
   * to decompress the file. As with all functionality that modifies the
   * contents of a phar, the phar.readonly INI variable must be off in order
   * to succeed if the file is within a Phar archive. Files within PharData
   * archives do not have this restriction.
   *
   * @compression_type
   *             mixed
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function compress($compression_type) {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.decompress.php )
   *
   * This method decompresses the file inside the Phar archive. Depending on
   * how the file is compressed, the bzip2 or zlib extensions must be enabled
   * to take advantage of this feature. As with all functionality that
   * modifies the contents of a phar, the phar.readonly INI variable must be
   * off in order to succeed if the file is within a Phar archive. Files
   * within PharData archives do not have this restriction.
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function decompress() {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.delmetadata.php )
   *
   * Deletes the metadata of the entry, if any.
   * No parameters.
   *
   * @return     mixed   Returns TRUE if successful, FALSE if the entry had
   *                     no metadata. As with all functionality that modifies
   *                     the contents of a phar, the phar.readonly INI
   *                     variable must be off in order to succeed if the file
   *                     is within a Phar archive. Files within PharData
   *                     archives do not have this restriction.
   */
  public function delMetadata() {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/pharfileinfo.getcompressedsize.php )
   *
   * This returns the size of the file within the Phar archive. Uncompressed
   * files will return the same value for getCompressedSize as they will with
   * filesize()
   *
   * @return     mixed   The size in bytes of the file within the Phar
   *                     archive on disk.
   */
  public function getCompressedSize() {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.getcrc32.php )
   *
   * This returns the crc32() checksum of the file within the Phar archive.
   *
   * @return     mixed   The crc32() checksum of the file within the Phar
   *                     archive.
   */
  public function getCRC32() {
  }

  public function getContent() {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.getmetadata.php )
   *
   * Return meta-data that was saved in the Phar archive's manifest for this
   * file.
   *
   * @return     mixed   any PHP variable that can be serialized and is
   *                     stored as meta-data for the file, or NULL if no
   *                     meta-data is stored.
   */
  public function getMetadata() {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.getpharflags.php )
   *
   * This returns the flags set in the manifest for a Phar. This will always
   * return 0 in the current implementation.
   *
   * @return     mixed   The Phar flags (always 0 in the current
   *                     implementation)
   */
  public function getPharFlags() {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.hasmetadata.php )
   *
   * Returns the metadata of a file within a phar archive.
   * No parameters.
   *
   * @return     mixed   Returns FALSE if no metadata is set or is NULL, TRUE
   *                     if metadata is not NULL
   */
  public function hasMetadata() {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.iscompressed.php )
   *
   * This returns whether a file is compressed within a Phar archive with
   * either Gzip or Bzip2 compression.
   *
   * @compression_type
   *             mixed   One of Phar::GZ or Phar::BZ2, defaults to any
   *                     compression.
   *
   * @return     mixed   TRUE if the file is compressed within the Phar
   *                     archive, FALSE if not.
   */
  public function isCompressed($compression_type) {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.iscrcchecked.php )
   *
   * This returns whether a file within a Phar archive has had its CRC
   * verified.
   *
   * @return     mixed   TRUE if the file has had its CRC verified, FALSE if
   *                     not.
   */
  public function isCRCChecked() {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/pharfileinfo.setmetadata.php )
   *
   * PharFileInfo::setMetadata() should only be used to store customized
   * data in a file that cannot be represented with existing information
   * stored with a file. Meta-data can significantly slow down the
   * performance of loading a phar archive if the data is large, or if there
   * are many files containing meta-data. It is important to note that file
   * permissions are natively supported inside a phar; it is possible to set
   * them with the PharFileInfo::chmod() method. As with all functionality
   * that modifies the contents of a phar, the phar.readonly INI variable
   * must be off in order to succeed if the file is within a Phar archive.
   * Files within PharData archives do not have this restriction.
   *
   * Some possible uses for meta-data include passing a user/group that
   * should be set when a file is extracted from the phar to disk. Other uses
   * could include explicitly specifying a MIME type to return. However, any
   * useful data that describes a file, but should not be contained inside of
   * it may be stored.
   *
   * @metadata   mixed   Any PHP variable containing information to store
   *                     alongside a file
   *
   * @return     mixed   No value is returned.
   */
  public function setMetadata($metadata) {
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.phardata.php )
 *
 * The PharData class provides a high-level interface to accessing and
 * creating non-executable tar and zip archives. Because these archives do
 * not contain a stub and cannot be executed by the phar extension, it is
 * possible to create and manipulate regular zip and tar files using the
 * PharData class even if phar.readonly php.ini setting is 1.
 *
 */
class PharData extends Phar {

  private $fname;
  private $iterator;
  private $archiveHandler;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.construct.php )
   *
   *
   * @fname      mixed   Path to an existing tar/zip archive or to-be-created
   *                     archive
   * @flags      mixed   Flags to pass to Phar parent class
   *                     RecursiveDirectoryIterator.
   * @alias      mixed   Alias with which this Phar archive should be
   *                     referred to in calls to stream functionality.
   * @format     mixed   One of the file format constants available within
   *                     the Phar class.
   */
  public function __construct(
    string $fname,
    int $flags = null,
    string $alias = null,
    int $format = Phar::TAR
  ) {
    $this->fname = $fname;
    if (substr($fname, -4) === '.zip' || $format === Phar::ZIP) {
      $this->archiveHandler = new __SystemLib\ZipArchiveHandler($fname);
    } else {
      $this->archiveHandler = new __SystemLib\TarArchiveHandler($fname);
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.addemptydir.php )
   *
   * With this method, an empty directory is created with path dirname. This
   * method is similar to ZipArchive::addEmptyDir().
   *
   * @dirname    mixed   The name of the empty directory to create in the
   *                     phar archive
   *
   * @return     mixed   no return value, exception is thrown on failure.
   */
  public function addEmptyDir(string $dirname) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.addfromstring.php )
   *
   * With this method, any string can be added to the tar/zip archive. The
   * file will be stored in the archive with localname as its path. This
   * method is similar to ZipArchive::addFromString().
   *
   * @localname  mixed   Path that the file will be stored in the archive.
   * @contents   mixed   The file contents to store
   *
   * @return     mixed   no return value, exception is thrown on failure.
   */
  public function addFromString(string $localname, string $contents) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.buildfromiterator.php
   * )
   *
   * Populate a tar or zip archive from an iterator. Two styles of iterators
   * are supported, iterators that map the filename within the tar/zip to the
   * name of a file on disk, and iterators like DirectoryIterator that return
   * SplFileInfo objects. For iterators that return SplFileInfo objects, the
   * second parameter is required.
   *
   * @iter       mixed   Any iterator that either associatively maps tar/zip
   *                     file to location or returns SplFileInfo objects
   * @base_directory
   *             mixed   For iterators that return SplFileInfo objects, the
   *                     portion of each file's full path to remove when
   *                     adding to the tar/zip archive
   *
   * @return     mixed   PharData::buildFromIterator() returns an associative
   *                     array mapping internal path of file to the full path
   *                     of the file on the filesystem.
   */
  public function buildFromIterator(
    Iterator $it,
    string $base_directory = '',
  ): array<string, string> {
    if ($base_directory !== '' && substr($base_directory, -1) !== '/') {
      $base_directory .= '/';
    }
    $ret = array();
    foreach ($it as $dest => $source) {
      if ($source instanceof SplFileInfo) {
        $source = $source->getPathName();
        $dest = str_replace($base_directory, '', $source);
      }
      if ($this->archiveHandler->addFile($source, $dest)) {
        $ret[$dest] = realpath($source);
      }
    }
    $this->archiveHandler->close();
    return $ret;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.compress.php )
   *
   * For tar archives, this method compresses the entire archive using gzip
   * compression or bzip2 compression. The resulting file can be processed
   * with the gunzip command/bunzip command, or accessed directly and
   * transparently with the Phar extension.
   *
   * For zip archives, this method fails with an exception. The zlib
   * extension must be enabled to compress with gzip compression, the bzip2
   * extension must be enabled in order to compress with bzip2 compression.
   *
   * In addition, this method automatically renames the archive, appending
   * .gz, .bz2 or removing the extension if passed Phar::NONE to remove
   * compression. Alternatively, a file extension may be specified with the
   * second parameter.
   *
   * @compression
   *             mixed   Compression must be one of Phar::GZ, Phar::BZ2 to
   *                     add compression, or Phar::NONE to remove
   *                     compression.
   * @extension  mixed   By default, the extension is .tar.gz or .tar.bz2 for
   *                     compressing a tar, and .tar for decompressing.
   *
   * @return     mixed   A PharData object is returned.
   */
  public function compress(int $compression, string $extension) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.compressfiles.php )
   *
   * For tar-based archives, this method throws a BadMethodCallException, as
   * compression of individual files within a tar archive is not supported by
   * the file format. Use PharData::compress() to compress an entire
   * tar-based archive.
   *
   * For Zip-based archives, this method compresses all files in the archive
   * using the specified compression. The zlib or bzip2 extensions must be
   * enabled to take advantage of this feature. In addition, if any files are
   * already compressed using bzip2/zlib compression, the respective
   * extension must be enabled in order to decompress the files prior to
   * re-compressing.
   *
   * @compression
   *             mixed   Compression must be one of Phar::GZ, Phar::BZ2 to
   *                     add compression, or Phar::NONE to remove
   *                     compression.
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function compressFiles(int $compression) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.converttodata.php )
   *
   * This method is used to convert a non-executable tar or zip archive to
   * another non-executable format.
   *
   * If no changes are specified, this method throws a
   * BadMethodCallException. This method should be used to convert a tar
   * archive to zip format or vice-versa. Although it is possible to simply
   * change the compression of a tar archive using this method, it is better
   * to use the PharData::compress() method for logical consistency.
   *
   * If successful, the method creates a new archive on disk and returns a
   * PharData object. The old archive is not removed from disk, and should be
   * done manually after the process has finished.
   *
   * @format     mixed   This should be one of Phar::TAR or Phar::ZIP. If set
   *                     to NULL, the existing file format will be preserved.
   * @compression
   *             mixed   This should be one of Phar::NONE for no
   *                     whole-archive compression, Phar::GZ for zlib-based
   *                     compression, and Phar::BZ2 for bzip-based
   *                     compression.
   * @extension  mixed   This parameter is used to override the default file
   *                     extension for a converted archive. Note that .phar
   *                     cannot be used anywhere in the filename for a
   *                     non-executable tar or zip archive.
   *
   *                     If converting to a tar-based phar archive, the
   *                     default extensions are .tar, .tar.gz, and .tar.bz2
   *                     depending on specified compression. For zip-based
   *                     archives, the default extension is .zip.
   *
   * @return     mixed   The method returns a PharData object on success and
   *                     throws an exception on failure.
   */
  public function convertToData(
    int $format,
    int $compression,
    string $extension
  ) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.converttoexecutable.php
   * )
   *
   *
   * @format     mixed   This should be one of Phar::PHAR, Phar::TAR, or
   *                     Phar::ZIP. If set to NULL, the existing file format
   *                     will be preserved.
   * @compression
   *             mixed   This should be one of Phar::NONE for no
   *                     whole-archive compression, Phar::GZ for zlib-based
   *                     compression, and Phar::BZ2 for bzip-based
   *                     compression.
   * @extension  mixed   This parameter is used to override the default file
   *                     extension for a converted archive. Note that all
   *                     zip- and tar-based phar archives must contain .phar
   *                     in their file extension in order to be processed as
   *                     a phar archive.
   *
   *                     If converting to a phar-based archive, the default
   *                     extensions are .phar, .phar.gz, or .phar.bz2
   *                     depending on the specified compression. For
   *                     tar-based phar archives, the default extensions are
   *                     .phar.tar, .phar.tar.gz, and .phar.tar.bz2. For
   *                     zip-based phar archives, the default extension is
   *                     .phar.zip.
   *
   * @return     mixed   The method returns a Phar object on success and
   *                     throws an exception on failure.
   */
  public function convertToExecutable(
    int $format,
    int $compression,
    string $extension
  ) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.copy.php )
   *
   * Copy a file internal to the tar/zip archive to another new file within
   * the same archive. This is an object-oriented alternative to using copy()
   * with the phar stream wrapper.
   *
   * @oldfile    mixed
   * @newfile    mixed
   *
   * @return     mixed   returns TRUE on success, but it is safer to encase
   *                     method call in a try/catch block and assume success
   *                     if no exception is thrown.
   */
  public function copy(string $oldfile, string $newfile) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.decompress.php )
   *
   * For tar-based archives, this method decompresses the entire archive.
   *
   * For Zip-based archives, this method fails with an exception. The zlib
   * extension must be enabled to decompress an archive compressed with gzip
   * compression, and the bzip2 extension must be enabled in order to
   * decompress an archive compressed with bzip2 compression.
   *
   * In addition, this method automatically renames the file extension of the
   * archive, .tar by default. Alternatively, a file extension may be
   * specified with the second parameter.
   *
   * @extension  mixed   For decompressing, the default file extension is
   *                     .phar.tar. Use this parameter to specify another
   *                     file extension. Be aware that no non-executable
   *                     archives cannot contain .phar in their filename.
   *
   * @return     mixed   A PharData object is returned.
   */
  public function decompress(string $extension = ".phar.tar") {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.decompressfiles.php )
   *
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function decompressFiles() {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.delmetadata.php )
   *
   *
   * @return     mixed   returns TRUE on success, but it is better to check
   *                     for thrown exception, and assume success if none is
   *                     thrown.
   */
  public function delMetadata() {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.delete.php )
   *
   * Delete a file within an archive. This is the functional equivalent of
   * calling unlink() on the stream wrapper equivalent, as shown in the
   * example below.
   *
   * @entry      mixed   Path within an archive to the file to delete.
   *
   * @return     mixed   returns TRUE on success, but it is better to check
   *                     for thrown exception, and assume success if none is
   *                     thrown.
   */
  public function delete(string $entry) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.extractto.php )
   *
   * Extract all files within a tar/zip archive to disk. Extracted files and
   * directories preserve permissions as stored in the archive. The optional
   * parameters allow optional control over which files are extracted, and
   * whether existing files on disk can be overwritten. The second parameter
   * files can be either the name of a file or directory to extract, or an
   * array of names of files and directories to extract. By default, this
   * method will not overwrite existing files, the third parameter can be set
   * to true to enable overwriting of files. This method is similar to
   * ZipArchive::extractTo().
   *
   * @pathto     mixed   Path within an archive to the file to delete.
   * @files      mixed   The name of a file or directory to extract, or an
   *                     array of files/directories to extract
   * @overwrite  mixed   Set to TRUE to enable overwriting existing files
   *
   * @return     mixed   returns TRUE on success, but it is better to check
   *                     for thrown exception, and assume success if none is
   *                     thrown.
   */
  public function extractTo(
      string $pathto,
      mixed $files = null,
      bool $overwrite = false) {

    $fp = fopen($this->fname, 'rb');
    if (!$fp) {
      throw new Exception("Invalid argument, {$this->fname} cannot be found");
    }

    if (!$pathto) {
      throw new Exception(
        "Invalid argument, extraction path must be non-zero length"
      );
    }

    if (is_file($pathto)) {
      throw new Exception(
        "Unable to use path \"$pathto\" for extraction, it is a file, ".
        "must be a directory"
      );
    } else if (!is_dir($pathto)) {
      mkdir($pathto);
    }

    $this->archiveHandler->extractAllTo($pathto);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.iswritable.php )
   *
   * This method returns TRUE if the tar/zip archive on disk is not
   * read-only. Unlike Phar::isWritable(), data-only tar/zip archives can be
   * modified even if phar.readonly is set to 1.
   * No parameters.
   *
   * @return     mixed   Returns TRUE if the tar/zip archive can be modified
   */
  public function isWritable() {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.offsetset.php )
   *
   * This is an implementation of the ArrayAccess interface allowing direct
   * manipulation of the contents of a tar/zip archive using array access
   * brackets. offsetSet is used for modifying an existing file, or adding a
   * new file to a tar/zip archive.
   *
   * @offset     mixed   The filename (relative path) to modify in a tar or
   *                     zip archive.
   * @value      mixed   Content of the file.
   *
   * @return     mixed   No return values.
   */
  public function offsetSet($offset, $value) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.offsetunset.php )
   *
   * This is an implementation of the ArrayAccess interface allowing direct
   * manipulation of the contents of a tar/zip archive using array access
   * brackets. offsetUnset is used for deleting an existing file, and is
   * called by the unset() language construct.
   *
   * @offset     mixed   The filename (relative path) to modify in the
   *                     tar/zip archive.
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function offsetUnset($offset) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.setalias.php )
   *
   * Non-executable tar/zip archives cannot have an alias, so this method
   * simply throws an exception.
   *
   * @alias      mixed   A shorthand string that this archive can be referred
   *                     to in phar stream wrapper access. This parameter is
   *                     ignored.
   */
  public function setAlias(string $alias) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.setdefaultstub.php )
   *
   * Non-executable tar/zip archives cannot have a stub, so this method
   * simply throws an exception.
   *
   * @index      mixed   Relative path within the phar archive to run if
   *                     accessed on the command-line
   * @webindex   mixed   Relative path within the phar archive to run if
   *                     accessed through a web browser
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function setDefaultStub(string $index, string $webindex) {
    throw new Exception('Not implemented yet');
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/phardata.setstub.php )
   *
   * Non-executable tar/zip archives cannot have a stub, so this method
   * simply throws an exception.
   *
   * @stub       mixed   A string or an open stream handle to use as the
   *                     executable stub for this phar archive. This
   *                     parameter is ignored.
   * @len        mixed
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function setStub(string $stub, int $len = -1) {
    throw new Exception('Not implemented yet');
  }

  protected function getIterator() {
    if ($this->iterator !== null) {
      return $this->iterator;
    }

    $contents = $this->archiveHandler->getContentsList();
    $root = 'phar://'.realpath($this->fname).'/';
    $out = array();
    foreach ($contents as $fname => $stat) {
      $out[$fname] = new PharfileInfo(
        $root.$fname,
        $stat
      );
    }
    $this->iterator = $this->getIteratorFromList($root, $out);

    return $this->iterator;
  }
}
}

namespace {

/* Type hints are missing as any classes that implements this interface must
 * specify types, meaning that no classes written in PHP can implement this
 * interface if type hints are included.
 */
interface DateTimeInterface {
  public function diff(
    /* DateTimeInterface */ $datetime2,
    /* bool */ $absolute /*= false */
  );
  public function format(/* string */ $format);
  public function getOffset();
  public function getTimestamp();
  public function getTimezone();
}
}

namespace {

class DateTimeImmutable implements DateTimeInterface {
  public function __construct(
    string $time = "now",
    DateTimeZone $timezone = null
  ) {
    $this->data = new DateTime($time, $timezone);
  }

  public function add(DateInterval $interval): DateTimeImmutable {
    $out = clone $this;
    $out->data->add($interval);
    return $out;
  }

  public function modify(string $modify): DateTimeImmutable {
    $out = clone $this;
    $out->data->modify($modify);
    return $out;
  }

  public function setDate(int $year, int $month, int $day): DateTimeImmutable {
    $out = clone $this;
    $out->data->setDate($year, $month, $day);
    return $out;
  }

  public function setISODate(
    int $year,
    int $week,
    int $day = 1
  ): DateTimeImmutable {
    $out = clone $this;
    $out->data->setISODate($year, $week, $day);
    return $out;
  }

  public function setTime(
    int $hour,
    int $minute,
    int $second = 0
  ): DateTimeImmutable {
    $out = clone $this;
    $out->data->setTime($hour, $minute, $second);
    return $out;
  }
  public function setTimestamp(int $unixtimestamp): DateTimeImmutable {
    $out = clone $this;
    $out->data->setTimestamp($unixtimestamp);
    return $out;
  }

  public function setTimezone(DateTimeZone $timezone): DateTimeImmutable {
    $out = clone $this;
    $out->data->setTimezone($timezone);
    return $out;
  }

  public function sub(DateInterval $interval): DateTimeImmutable {
    $out = clone $this;
    $out->data->sub($interval);
    return $out;
  }

  public function diff(
    $datetime2,
    $absolute = false
  ) {
    return $this->data->diff($datetime2, $absolute);
  }

  public function format($format) {
    return $this->data->format($format);
  }

  public function getOffset() {
    return $this->data->getOffset();
  }

  public function getTimestamp() {
    return $this->data->getTimestamp();
  }

  public function getTimezone() {
    return $this->data->getTimezone();
  }

  public static function createFromFormat(
    string $format,
    string $time,
    DateTimeZone $timezone = null
  ): mixed {
    $out = new DateTimeImmutable();
    $out->data = DateTime::createFromFormat($format, $time, $timezone);
    if ($out->data === false) {
      return false;
    }
    return $out;
  }

  public static function getLastErrors(): array {
    return DateTime::getLastErrors();
  }

  public function __clone() {
    $this->data = clone $this->data;
  }

  private DateTime $data;
}
}


namespace {

interface ConstCollection extends Countable {
  public function isEmpty();
  public function count();
  public function items();
}

interface OutputCollection {
  public function add($e);
  public function addAll($iterable);
}

}

namespace HH {

interface Collection extends \ConstCollection,
                             \OutputCollection {
  public function clear();
}

}

namespace {

interface ConstSetAccess {
  public function contains($m);
}

interface SetAccess extends ConstSetAccess {
  public function remove($m);
}

interface ConstIndexAccess {
  public function at($k);
  public function get($k);
  public function containsKey($k);
}

interface IndexAccess extends ConstIndexAccess {
  public function set($k,$v);
  public function setAll($iterable);
  public function removeKey($k);
}

interface ConstMapAccess extends ConstSetAccess,
                                 ConstIndexAccess {
}

interface MapAccess extends ConstMapAccess,
                            SetAccess,
                            IndexAccess {
}

interface Indexish extends \HH\KeyedContainer {
}

interface ConstVector extends ConstCollection,
                              ConstIndexAccess,
                              \HH\KeyedIterable,
                              Indexish {
}

interface MutableVector extends ConstVector,
                                \HH\Collection,
                                IndexAccess {
}

interface ConstMap extends ConstCollection,
                           ConstMapAccess,
                           \HH\KeyedIterable,
                           Indexish {
}

interface MutableMap extends ConstMap,
                             \HH\Collection,
                             MapAccess {
}

interface ConstSet extends ConstCollection,
                           ConstSetAccess,
                           \HH\KeyedIterable,
                           \HH\Container {
}

interface MutableSet extends ConstSet,
                             \HH\Collection,
                             SetAccess {
}

trait StrictIterable {
  public function toArray() {
    $arr = array();
    foreach ($this as $v) {
      $arr[] = $v;
    }
    return $arr;
  }
  public function toValuesArray() {
    return $this->toArray();
  }
  public function toVector() {
    return new Vector($this);
  }
  public function toImmVector() {
    return new ImmVector($this);
  }
  public function toSet() {
    return new Set($this);
  }
  public function toImmSet() {
    return new ImmSet($this);
  }
  public function lazy() {
    return new LazyIterableView($this);
  }
  public function values() {
    return new Vector($this);
  }
  public function map($callback) {
    $res = Vector {};
    foreach ($this as $v) {
      $res[] = $callback($v);
    }
    return $res;
  }
  public function filter($callback) {
    $res = Vector {};
    foreach ($this as $v) {
      if ($callback($v)) $res[] = $v;
    }
    return $res;
  }
  public function zip($iterable) {
    $res = Vector {};
    $it = $iterable->getIterator();
    foreach ($this as $v) {
      if (!$it->valid()) break;
      $res[] = Pair {$v, $it->current()};
      $it->next();
    }
    return $res;
  }
  public function take($n) {
    $res = Vector {};
    if ($n <= 0) return $res;
    foreach ($this as $v) {
      $res[] = $v;
      if (--$n === 0) break;
    }
    return $res;
  }
  public function takeWhile($fn) {
    $res = Vector {};
    foreach ($this as $v) {
      if (!$fn($v)) break;
      $res[] = $v;
    }
    return $res;
  }
  public function skip($n) {
    $res = Vector {};
    foreach ($this as $v) {
      if ($n <= 0) {
        $res[] = $v;
      } else {
        --$n;
      }
    }
    return $res;
  }
  public function skipWhile($fn) {
    $res = Vector {};
    $skip = true;
    foreach ($this as $v) {
      if ($skip) {
        if ($fn($v)) continue;
        $skip = false;
      }
      $res[] = $v;
    }
    return $res;
  }
  public function slice($start, $len) {
    $res = Vector {};
    if ($len <= 0) return $res;
    foreach ($this as $v) {
      if ($start !== 0) {
        --$start;
        continue;
      }
      $res[] = $v;
      if (--$len === 0) break;
    }
    return $res;
  }
  public function concat($iterable) {
    $res = Vector {};
    foreach ($this as $v) {
      $res[] = $v;
    }
    foreach ($iterable as $v) {
      $res[] = $v;
    }
    return $res;
  }
  public function firstValue() {
    foreach ($this as $v) {
      return $v;
    }
    return null;
  }
  public function lastValue() {
    $v = null;
    foreach ($this as $v) {}
    return $v;
  }
}

trait StrictKeyedIterable {
  public function toArray() {
    $arr = array();
    foreach ($this as $k => $v) {
      $arr[$k] = $v;
    }
    return $arr;
  }
  public function toValuesArray() {
    $arr = array();
    foreach ($this as $v) {
      $arr[] = $v;
    }
    return $arr;
  }
  public function toKeysArray() {
    $arr = array();
    foreach ($this as $k => $_) {
      $arr[] = $k;
    }
    return $arr;
  }
  public function toVector() {
    return new Vector($this);
  }
  public function toImmVector() {
    return new ImmVector($this);
  }
  public function toMap() {
    return new Map($this);
  }
  public function toImmMap() {
    return new ImmMap($this);
  }
  public function toSet() {
    return new Set($this);
  }
  public function toImmSet() {
    return new ImmSet($this);
  }
  public function lazy() {
    return new LazyKeyedIterableView($this);
  }
  public function values() {
    return new Vector($this);
  }
  public function keys() {
    $res = Vector {};
    foreach ($this as $k => $_) {
      $res[] = $k;
    }
    return $res;
  }
  public function map($callback) {
    $res = Map {};
    foreach ($this as $k => $v) {
      $res[$k] = $callback($v);
    }
    return $res;
  }
  public function mapWithKey($callback) {
    $res = Map {};
    foreach ($this as $k => $v) {
      $res[$k] = $callback($k, $v);
    }
    return $res;
  }
  public function filter($callback) {
    $res = Map {};
    foreach ($this as $k => $v) {
      if ($callback($v)) $res[$k] = $v;
    }
    return $res;
  }
  public function filterWithKey($callback) {
    $res = Map {};
    foreach ($this as $k => $v) {
      if ($callback($k, $v)) $res[$k] = $v;
    }
    return $res;
  }
  public function zip($iterable) {
    $res = Map {};
    $it = $iterable->getIterator();
    foreach ($this as $k => $v) {
      if (!$it->valid()) break;
      $res[$k] = Pair {$v, $it->current()};
      $it->next();
    }
    return $res;
  }
  public function take($n) {
    $res = Map {};
    if ($n <= 0) return $res;
    foreach ($this as $k => $v) {
      $res[$k] = $v;
      if (--$n === 0) break;
    }
    return $res;
  }
  public function takeWhile($fn) {
    $res = Map {};
    foreach ($this as $k => $v) {
      if (!$fn($v)) break;
      $res[$k] = $v;
    }
    return $res;
  }
  public function skip($n) {
    $res = Map {};
    foreach ($this as $k => $v) {
      if ($n <= 0) {
        $res[$k] = $v;
      } else {
        --$n;
      }
    }
    return $res;
  }
  public function skipWhile($fn) {
    $res = Map {};
    $skip = true;
    foreach ($this as $k => $v) {
      if ($skip) {
        if ($fn($v)) continue;
        $skip = false;
      }
      $res[$k] = $v;
    }
    return $res;
  }
  public function slice($start, $len) {
    $res = Map {};
    if ($len <= 0) return $res;
    foreach ($this as $k => $v) {
      if ($start !== 0) {
        --$start;
        continue;
      }
      $res[$k] = $v;
      if (--$len === 0) break;
    }
    return $res;
  }
  public function concat($iterable) {
    $res = Vector {};
    foreach ($this as $v) {
      $res[] = $v;
    }
    foreach ($iterable as $v) {
      $res[] = $v;
    }
    return $res;
  }
  public function firstValue() {
    foreach ($this as $v) {
      return $v;
    }
    return null;
  }
  public function firstKey() {
    foreach ($this as $k => $_) {
      return $k;
    }
    return null;
  }
  public function lastValue() {
    $v = null;
    foreach ($this as $v) {}
    return $v;
  }
  public function lastKey() {
    $k = null;
    foreach ($this as $k => $_) {}
    return $k;
  }
}

trait LazyIterable {
  public function toArray() {
    $arr = array();
    foreach ($this as $v) {
      $arr[] = $v;
    }
    return $arr;
  }
  public function toValuesArray() {
    return $this->toArray();
  }
  public function toVector() {
    return new Vector($this);
  }
  public function toImmVector() {
    return new ImmVector($this);
  }
  public function toSet() {
    return new Set($this);
  }
  public function toImmSet() {
    return new ImmSet($this);
  }
  public function lazy() {
    return $this;
  }
  public function values() {
    return new LazyValuesIterable($this);
  }
  public function map($callback) {
    return new LazyMapIterable($this, $callback);
  }
  public function filter($callback) {
    return new LazyFilterIterable($this, $callback);
  }
  public function zip($iterable) {
    if (is_array($iterable)) {
      $iterable = new ImmMap($iterable);
    }
    return new LazyZipIterable($this, $iterable);
  }
  public function take($n) {
    return new LazyTakeIterable($this, $n);
  }
  public function takeWhile($fn) {
    return new LazyTakeWhileIterable($this, $fn);
  }
  public function skip($n) {
    return new LazySkipIterable($this, $n);
  }
  public function skipWhile($fn) {
    return new LazySkipWhileIterable($this, $fn);
  }
  public function slice($start, $len) {
    return new LazySliceIterable($this, $start, $len);
  }
  public function concat($iterable) {
    if (is_array($iterable)) {
      $iterable = new ImmMap($iterable);
    }
    return new LazyConcatIterable($this, $iterable);
  }
  public function firstValue() {
    foreach ($this as $v) {
      return $v;
    }
    return null;
  }
  public function lastValue() {
    $v = null;
    foreach ($this as $v) {}
    return $v;
  }
}

trait LazyKeyedIterable {
  public function toArray() {
    $arr = array();
    foreach ($this as $k => $v) {
      $arr[$k] = $v;
    }
    return $arr;
  }
  public function toValuesArray() {
    $arr = array();
    foreach ($this as $v) {
      $arr[] = $v;
    }
    return $arr;
  }
  public function toKeysArray() {
    $arr = array();
    foreach ($this as $k => $_) {
      $arr[] = $k;
    }
    return $arr;
  }
  public function toVector() {
    return new Vector($this);
  }
  public function toImmVector() {
    return new ImmVector($this);
  }
  public function toMap() {
    return new Map($this);
  }
  public function toImmMap() {
    return new ImmMap($this);
  }
  public function toSet() {
    return new Set($this);
  }
  public function toImmSet() {
    return new ImmSet($this);
  }
  public function lazy() {
    return $this;
  }
  public function values() {
    return new LazyValuesIterable($this);
  }
  public function keys() {
    return new LazyKeysIterable($this);
  }
  public function map($callback) {
    return new LazyMapKeyedIterable($this, $callback);
  }
  public function mapWithKey($callback) {
    return new LazyMapWithKeyIterable($this, $callback);
  }
  public function filter($callback) {
    return new LazyFilterKeyedIterable($this, $callback);
  }
  public function filterWithKey($callback) {
    return new LazyFilterWithKeyIterable($this, $callback);
  }
  public function zip($iterable) {
    if (is_array($iterable)) {
      $iterable = new ImmMap($iterable);
    }
    return new LazyZipKeyedIterable($this, $iterable);
  }
  public function take($n) {
    return new LazyTakeKeyedIterable($this, $n);
  }
  public function takeWhile($fn) {
    return new LazyTakeWhileKeyedIterable($this, $fn);
  }
  public function skip($n) {
    return new LazySkipKeyedIterable($this, $n);
  }
  public function skipWhile($fn) {
    return new LazySkipWhileKeyedIterable($this, $fn);
  }
  public function slice($start, $len) {
    return new LazySliceKeyedIterable($this, $start, $len);
  }
  public function concat($iterable) {
    if (is_array($iterable)) {
      $iterable = new ImmMap($iterable);
    }
    return new LazyConcatIterable($this, $iterable);
  }
  public function firstValue() {
    foreach ($this as $v) {
      return $v;
    }
    return null;
  }
  public function firstKey() {
    foreach ($this as $k => $_) {
      return $k;
    }
    return null;
  }
  public function lastValue() {
    $v = null;
    foreach ($this as $v) {}
    return $v;
  }
  public function lastKey() {
    $k = null;
    foreach ($this as $k => $_) {}
    return $k;
  }
}

class LazyMapIterator implements \HH\Iterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return ($this->fn)($this->it->current());
  }
}

class LazyMapIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new LazyMapIterator($this->iterable->getIterator(), $this->fn);
  }
}

class LazyMapKeyedIterator implements \HH\KeyedIterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return ($this->fn)($this->it->current());
  }
}

class LazyMapKeyedIterable implements \HH\KeyedIterable {
  use LazyKeyedIterable;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new LazyMapKeyedIterator($this->iterable->getIterator(), $this->fn);
  }
}

class LazyMapWithKeyIterator implements \HH\KeyedIterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return ($this->fn)($this->it->key(), $this->it->current());
  }
}

class LazyMapWithKeyIterable implements \HH\KeyedIterable {
  use LazyKeyedIterable;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new LazyMapWithKeyIterator($this->iterable->getIterator(),
                                      $this->fn);
  }
}

class LazyFilterIterator implements \HH\Iterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $it = $this->it;
    $fn = $this->fn;
    $it->rewind();
    while ($it->valid() && !$fn($it->current())) {
      $it->next();
    }
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $it = $this->it;
    $fn = $this->fn;
    $it->next();
    while ($it->valid() && !$fn($it->current())) {
      $it->next();
    }
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazyFilterIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new LazyFilterIterator($this->iterable->getIterator(), $this->fn);
  }
}

class LazyFilterKeyedIterator implements \HH\KeyedIterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $it = $this->it;
    $fn = $this->fn;
    $it->rewind();
    while ($it->valid() && !$fn($it->current())) {
      $it->next();
    }
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $it = $this->it;
    $fn = $this->fn;
    $it->next();
    while ($it->valid() && !$fn($it->current())) {
      $it->next();
    }
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazyFilterKeyedIterable implements \HH\KeyedIterable {
  use LazyKeyedIterable;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return
      new LazyFilterKeyedIterator($this->iterable->getIterator(), $this->fn);
  }
}

class LazyFilterWithKeyIterator implements \HH\KeyedIterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $it = $this->it;
    $fn = $this->fn;
    $it->rewind();
    while ($it->valid() && !$fn($it->key(), $it->current())) {
      $it->next();
    }
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $it = $this->it;
    $fn = $this->fn;
    $it->next();
    while ($it->valid() && !$fn($it->key(), $it->current())) {
      $it->next();
    }
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazyFilterWithKeyIterable implements \HH\KeyedIterable {
  use LazyKeyedIterable;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return
      new LazyFilterWithKeyIterator($this->iterable->getIterator(), $this->fn);
  }
}

class LazyZipIterator implements \HH\Iterator {
  private $it1;
  private $it2;

  public function __construct($it1, $it2) {
    $this->it1 = $it1;
    $this->it2 = $it2;
  }
  public function __clone() {
    $this->it1 = clone $this->it1;
    $this->it2 = clone $this->it2;
  }
  public function rewind() {
    $this->it1->rewind();
    $this->it2->rewind();
  }
  public function valid() {
    return ($this->it1->valid() && $this->it2->valid());
  }
  public function next() {
    $this->it1->next();
    $this->it2->next();
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return Pair {$this->it1->current(), $this->it2->current()};
  }
}

class LazyZipIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable1;
  private $iterable2;

  public function __construct($iterable1, $iterable2) {
    $this->iterable1 = $iterable1;
    $this->iterable2 = $iterable2;
  }
  public function getIterator() {
    return new LazyZipIterator($this->iterable1->getIterator(),
                               $this->iterable2->getIterator());
  }
}

class LazyZipKeyedIterator implements \HH\KeyedIterator {
  private $it1;
  private $it2;

  public function __construct($it1, $it2) {
    $this->it1 = $it1;
    $this->it2 = $it2;
  }
  public function __clone() {
    $this->it1 = clone $this->it1;
    $this->it2 = clone $this->it2;
  }
  public function rewind() {
    $this->it1->rewind();
    $this->it2->rewind();
  }
  public function valid() {
    return ($this->it1->valid() && $this->it2->valid());
  }
  public function next() {
    $this->it1->next();
    $this->it2->next();
  }
  public function key() {
    return $this->it1->key();
  }
  public function current() {
    return Pair {$this->it1->current(), $this->it2->current()};
  }
}

class LazyZipKeyedIterable implements \HH\KeyedIterable {
  use LazyKeyedIterable;

  private $iterable1;
  private $iterable2;

  public function __construct($iterable1, $iterable2) {
    $this->iterable1 = $iterable1;
    $this->iterable2 = $iterable2;
  }
  public function getIterator() {
    return new LazyZipKeyedIterator($this->iterable1->getIterator(),
                                    $this->iterable2->getIterator());
  }
}

class LazyTakeIterator implements \HH\Iterator {
  private $it;
  private $n;
  private $numLeft;

  public function __construct($it, $n) {
    $this->it = $it;
    $this->n = $n;
    $this->numLeft = $n;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
    $this->numLeft = $this->n;
  }
  public function valid() {
    return ($this->numLeft > 0 && $this->it->valid());
  }
  public function next() {
    $this->it->next();
    --$this->numLeft;
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazyTakeIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;
  private $n;

  public function __construct($iterable, $n) {
    $this->iterable = $iterable;
    $this->n = $n;
  }
  public function getIterator() {
    return new LazyTakeIterator($this->iterable->getIterator(),
                                $this->n);
  }
}

class LazyTakeKeyedIterator implements \HH\KeyedIterator {
  private $it;
  private $n;
  private $numLeft;

  public function __construct($it, $n) {
    $this->it = $it;
    $this->n = $n;
    $this->numLeft = $n;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
    $this->numLeft = $this->n;
  }
  public function valid() {
    return ($this->numLeft > 0 && $this->it->valid());
  }
  public function next() {
    $this->it->next();
    --$this->numLeft;
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazyTakeKeyedIterable implements \HH\KeyedIterable {
  use LazyKeyedIterable;

  private $iterable;
  private $n;

  public function __construct($iterable, $n) {
    $this->iterable = $iterable;
    $this->n = $n;
  }
  public function getIterator() {
    return new LazyTakeKeyedIterator($this->iterable->getIterator(),
                                     $this->n);
  }
}

class LazyTakeWhileIterator implements \HH\Iterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
    while ($it->valid() && $fn($it->current())) {
      $it->next();
    }
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    $it = $this->it;
    return ($it->valid() && ($this->fn)($it->current()));
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazyTakeWhileIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new LazyTakeWhileIterator($this->iterable->getIterator(),
                                     $this->fn);
  }
}

class LazyTakeWhileKeyedIterator implements \HH\Iterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    $it = $this->it;
    return ($it->valid() && ($this->fn)($it->current()));
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazyTakeWhileKeyedIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new LazyTakeWhileKeyedIterator($this->iterable->getIterator(),
                                          $this->fn);
  }
}

class LazySkipIterator implements \HH\Iterator {
  private $it;
  private $n;

  public function __construct($it, $n) {
    $this->it = $it;
    $this->n = $n;
    while ($n > 0 && $it->valid()) {
      $it->next();
      --$n;
    }
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $it = $this->it;
    $n = $this->n;
    $it->rewind();
    while ($n > 0 && $it->valid()) {
      $it->next();
      --$n;
    }
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazySkipIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;
  private $n;

  public function __construct($iterable, $n) {
    $this->iterable = $iterable;
    $this->n = $n;
  }
  public function getIterator() {
    return new LazySkipIterator($this->iterable->getIterator(),
                                $this->n);
  }
}

class LazySkipKeyedIterator implements \HH\KeyedIterator {
  private $it;
  private $n;

  public function __construct($it, $n) {
    $this->it = $it;
    $this->n = $n;
    while ($n > 0 && $it->valid()) {
      $it->next();
      --$n;
    }
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $it = $this->it;
    $n = $this->n;
    $it->rewind();
    while ($n > 0 && $it->valid()) {
      $it->next();
      --$n;
    }
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazySkipKeyedIterable implements \HH\KeyedIterable {
  use LazyKeyedIterable;

  private $iterable;
  private $n;

  public function __construct($iterable, $n) {
    $this->iterable = $iterable;
    $this->n = $n;
  }
  public function getIterator() {
    return new LazySkipKeyedIterator($this->iterable->getIterator(),
                                     $this->n);
  }
}

class LazySkipWhileIterator implements \HH\Iterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
    while ($it->valid() && $fn($it->current())) {
      $it->next();
    }
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $it = $this->it;
    $fn = $this->fn;
    $it->rewind();
    while ($it->valid() && $fn($it->current())) {
      $it->next();
    }
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazySkipWhileIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new LazySkipWhileIterator($this->iterable->getIterator(),
                                     $this->fn);
  }
}

class LazySkipWhileKeyedIterator implements \HH\Iterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
    while ($it->valid() && $fn($it->current())) {
      $it->next();
    }
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $it = $this->it;
    $fn = $this->fn;
    $it->rewind();
    while ($it->valid() && $fn($it->current())) {
      $it->next();
    }
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazySkipWhileKeyedIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new LazySkipWhileKeyedIterator($this->iterable->getIterator(),
                                          $this->fn);
  }
}

class LazySliceIterator implements \HH\Iterator {
  private $it;
  private $start;
  private $len;
  private $currentLen;

  public function __construct($it, $start, $len) {
    $this->it = $it;
    $this->start = $start;
    $this->len = $len;
    $this->currentLen = $len;
    while ($start !== 0 && $it->valid()) {
      $it->next();
      --$start;
    }
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $it = $this->it;
    $start = $this->start;
    $len = $this->len;
    $it->rewind();
    $this->currentLen = $len;
    while ($start !== 0 && $it->valid()) {
      $it->next();
      --$start;
    }
  }
  public function valid() {
    return $this->it->valid() && $this->currentLen !== 0;
  }
  public function next() {
    $this->it->next();
    if ($this->currentLen !== 0) {
      --$this->currentLen;
    }
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazySliceIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;
  private $start;
  private $len;

  public function __construct($iterable, $start, $len) {
    $this->iterable = $iterable;
    $this->start = $start;
    $this->len = $len;
  }
  public function getIterator() {
    return new LazySliceIterator($this->iterable->getIterator(),
                                 $this->start,
                                 $this->len);
  }
}

class LazySliceKeyedIterator implements \HH\KeyedIterator {
  private $it;
  private $start;
  private $len;
  private $currentLen;

  public function __construct($it, $start, $len) {
    $this->it = $it;
    $this->start = $start;
    $this->len = $len;
    $this->currentLen = $len;
    while ($start !== 0 && $it->valid()) {
      $it->next();
      --$start;
    }
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $it = $this->it;
    $start = $this->start;
    $len = $this->len;
    $it->rewind();
    $this->currentLen = $len;
    while ($start !== 0 && $it->valid()) {
      $it->next();
      --$start;
    }
  }
  public function valid() {
    return $this->it->valid() && $this->currentLen !== 0;
  }
  public function next() {
    $this->it->next();
    if ($this->currentLen !== 0) {
      --$this->currentLen;
    }
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class LazySliceKeyedIterable implements \HH\KeyedIterable {
  use LazyKeyedIterable;

  private $iterable;
  private $start;
  private $len;

  public function __construct($iterable, $start, $len) {
    $this->iterable = $iterable;
    $this->start = $start;
    $this->len = $len;
  }
  public function getIterator() {
    return new LazySliceKeyedIterator($this->iterable->getIterator(),
                                      $this->start,
                                      $this->len);
  }
}

class LazyKeysIterator implements \HH\Iterator {
  private $it;

  public function __construct($it) {
    $this->it = $it;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return null;
  }
  public function current() {
    return $this->it->key();
  }
}

class LazyKeysIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;

  public function __construct($iterable) {
    $this->iterable = $iterable;
  }
  public function getIterator() {
    return new LazyKeysIterator($this->iterable->getIterator());
  }
}

class LazyValuesIterator implements \HH\Iterator {
  private $it;

  public function __construct($it) {
    $this->it = $it;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return null;
  }
  public function current() {
    return $this->it->current();
  }
}

class LazyValuesIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;

  public function __construct($iterable) {
    $this->iterable = $iterable;
  }
  public function getIterator() {
    return new LazyValuesIterator($this->iterable->getIterator());
  }
}

class LazyKVZipIterator implements \HH\Iterator {
  private $it;

  public function __construct($it) {
    $this->it = $it;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return null;
  }
  public function current() {
    return Pair {$this->it->key(), $this->it->current()};
  }
}

class LazyKVZipIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable;

  public function __construct($iterable) {
    $this->iterable = $iterable;
  }
  public function getIterator() {
    return new LazyKVZipIterator($this->iterable->getIterator());
  }
}

class LazyConcatIterator implements \HH\Iterator {
  private $it1;
  private $it2;
  private $currentIt;
  private $state;

  public function __construct($it1, $it2) {
    $this->it1 = $it1;
    $this->it2 = $it2;
    $this->currentIt = $it1;
    $this->state = 1;
    if (!$this->currentIt->valid()) {
      $this->currentIt = $this->it2;
      $this->state = 2;
    }
  }
  public function __clone() {
    $this->it1 = clone $this->it1;
    $this->it2 = clone $this->it2;
    $this->currentIt = ($this->state === 1) ? $this->it1 : $this->it2;
  }
  public function rewind() {
    $this->it1->rewind();
    $this->it2->rewind();
    $this->currentIt = $this->it1;
    $this->state = 1;
    if (!$this->currentIt->valid()) {
      $this->currentIt = $this->it2;
      $this->state = 2;
    }
  }
  public function valid() {
    return $this->currentIt->valid();
  }
  public function next() {
    $this->currentIt->next();
    if ($this->state === 1 && !$this->currentIt->valid()) {
      $this->currentIt = $this->it2;
      $this->state = 2;
    }
  }
  public function key() {
    return $this->currentIt->key();
  }
  public function current() {
    return $this->currentIt->current();
  }
}

class LazyConcatIterable implements \HH\Iterable {
  use LazyIterable;

  private $iterable1;
  private $iterable2;

  public function __construct($iterable1, $iterable2) {
    $this->iterable1 = $iterable1;
    $this->iterable2 = $iterable2;
  }
  public function getIterator() {
    return new LazyConcatIterator($this->iterable1->getIterator(),
                                  $this->iterable2->getIterator());
  }
}

class LazyIterableView implements \HH\Iterable {
  public $iterable;

  public function __construct($iterable) { $this->iterable = $iterable; }
  public function getIterator() { return $this->iterable->getIterator(); }
  public function toArray() {
    $arr = array();
    foreach ($this->iterable as $v) {
      $arr[] = $v;
    }
    return $arr;
  }
  public function toValuesArray() {
    return $this->toArray();
  }
  public function toVector() {
    return $this->iterable->toVector();
  }
  public function toImmVector() {
    return $this->iterable->toImmVector();
  }
  public function toSet() {
    return $this->iterable->toSet();
  }
  public function toImmSet() {
    return $this->iterable->toImmSet();
  }
  public function lazy() {
    return $this;
  }
  public function values() {
    return new LazyValuesIterable($this->iterable);
  }
  public function map($callback) {
    return new LazyMapIterable($this->iterable, $callback);
  }
  public function filter($callback) {
    return new LazyFilterIterable($this->iterable, $callback);
  }
  public function zip($iterable) {
    if (is_array($iterable)) {
      $iterable = new ImmMap($iterable);
    }
    return new LazyZipIterable($this->iterable, $iterable);
  }
  public function take($n) {
    return new LazyTakeIterable($this->iterable, $n);
  }
  public function takeWhile($fn) {
    return new LazyTakeWhileIterable($this->iterable, $fn);
  }
  public function skip($n) {
    return new LazySkipIterable($this->iterable, $n);
  }
  public function skipWhile($fn) {
    return new LazySkipWhileIterable($this->iterable, $fn);
  }
  public function slice($start, $len) {
    return new LazySliceIterable($this->iterable, $start, $len);
  }
  public function concat($iterable) {
    if (is_array($iterable)) {
      $iterable = new ImmMap($iterable);
    }
    return new LazyConcatIterable($this->iterable, $iterable);
  }
  public function firstValue() {
    foreach ($this->iterable as $v) {
      return $v;
    }
    return null;
  }
  public function lastValue() {
    $v = null;
    foreach ($this->iterable as $v) {}
    return $v;
  }
}

class LazyKeyedIterableView implements \HH\KeyedIterable {
  public $iterable;

  public function __construct($iterable) { $this->iterable = $iterable; }
  public function getIterator() { return $this->iterable->getIterator(); }
  public function toArray() {
    $arr = array();
    foreach ($this->iterable as $k => $v) {
      $arr[$k] = $v;
    }
    return $arr;
  }
  public function toValuesArray() {
    $arr = array();
    foreach ($this->iterable as $v) {
      $arr[] = $v;
    }
    return $arr;
  }
  public function toKeysArray() {
    $arr = array();
    foreach ($this->iterable as $k => $_) {
      $arr[] = $k;
    }
    return $arr;
  }
  public function toVector() {
    return $this->iterable->toVector();
  }
  public function toImmVector() {
    return $this->iterable->toImmVector();
  }
  public function toMap() {
    return $this->iterable->toMap();
  }
  public function toImmMap() {
    return $this->iterable->toImmMap();
  }
  public function toSet() {
    return $this->iterable->toSet();
  }
  public function toImmSet() {
    return $this->iterable->toImmSet();
  }
  public function lazy() {
    return $this;
  }
  public function values() {
    return new LazyValuesIterable($this->iterable);
  }
  public function keys() {
    return new LazyKeysIterable($this->iterable);
  }
  public function map($callback) {
    return new LazyMapKeyedIterable($this->iterable, $callback);
  }
  public function mapWithKey($callback) {
    return new LazyMapWithKeyIterable($this->iterable, $callback);
  }
  public function filter($callback) {
    return new LazyFilterKeyedIterable($this->iterable, $callback);
  }
  public function filterWithKey($callback) {
    return new LazyFilterWithKeyIterable($this->iterable, $callback);
  }
  public function zip($iterable) {
    if (is_array($iterable)) {
      $iterable = new ImmMap($iterable);
    }
    return new LazyZipKeyedIterable($this->iterable, $iterable);
  }
  public function take($n) {
    return new LazyTakeKeyedIterable($this->iterable, $n);
  }
  public function takeWhile($fn) {
    return new LazyTakeWhileKeyedIterable($this->iterable, $fn);
  }
  public function skip($n) {
    return new LazySkipKeyedIterable($this->iterable, $n);
  }
  public function skipWhile($fn) {
    return new LazySkipWhileKeyedIterable($this->iterable, $fn);
  }
  public function slice($start, $len) {
    return new LazySliceKeyedIterable($this->iterable, $start, $len);
  }
  public function concat($iterable) {
    if (is_array($iterable)) {
      $iterable = new ImmMap($iterable);
    }
    return new LazyConcatIterable($this->iterable, $iterable);
  }
  public function firstValue() {
    foreach ($this->iterable as $v) {
      return $v;
    }
    return null;
  }
  public function firstKey() {
    foreach ($this->iterable as $k => $_) {
      return $k;
    }
    return null;
  }
  public function lastValue() {
    $v = null;
    foreach ($this->iterable as $v) {}
    return $v;
  }
  public function lastKey() {
    $k = null;
    foreach ($this->iterable as $k => $_) {}
    return $k;
  }
}

}


namespace HH\Asio {

/**
 * Represents a result of operation that may have failed.
 */
interface ResultOrExceptionWrapper<T> {
  /**
   * Return true iff the operation succeeded.
   */
  public function isSucceeded(): bool;

  /**
   * Return true iff the operation failed.
   */
  public function isFailed(): bool;

  /**
   * Return the result of the operation, or throw underlying exception.
   *
   * - if the operation succeeded: return its result
   * - if the operation failed: throw the exception incating failure
   */
  public function getResult(): T;

  /**
   * Return the underlying exception, or fail with invariant violation.
   *
   * - if the operation succeeded: fails with invariant violation
   * - if the operation failed: returns the exception indicating failure
   */
  public function getException(): \Exception;
}

} // namespace HH\Asio


namespace HH\Asio {

/**
 * Represents a result of failed operation.
 */
final class WrappedException<Te as \Exception,Tr>
  implements ResultOrExceptionWrapper<Tr> {
  public function __construct(private Te $exception) {}

  public function isSucceeded(): bool {
    return false;
  }

  public function isFailed(): bool {
    return true;
  }

  public function getResult(): Tr {
    throw $this->exception;
  }

  public function getException(): Te {
    return $this->exception;
  }
}

} // namespace HH\Asio


namespace HH\Asio {

/**
 * Represents a result of succeeded operation.
 */
final class WrappedResult<T> implements ResultOrExceptionWrapper<T> {
  public function __construct(private T $result) {}

  public function isSucceeded(): bool {
    return true;
  }

  public function isFailed(): bool {
    return false;
  }

  public function getResult(): T {
    return $this->result;
  }

  public function getException(): \Exception {
    invariant_violation('Unable to get exception from WrappedResult');
  }
}

} // namespace HH\Asio


namespace HH\Asio {

/**
 * Wrap an Awaitable into a ResultOrExceptionWrapper.
 */
async function wrap<Tv>(
  Awaitable<Tv> $awaitable,
): Awaitable<ResultOrExceptionWrapper<Tv>> {
  try {
    $result = await $awaitable;
    return new WrappedResult($result);
  } catch (\Exception $e) {
    return new WrappedException($e);
  }
}

/**
 * Wait until some later time in the future.
 */
async function later(): Awaitable<void> {
  // reschedule to the lowest priority
  return await RescheduleWaitHandle::create(
    RescheduleWaitHandle::QUEUE_DEFAULT,
    0,
  );
}

/**
 * Convenience wrapper for SleepWaitHandle
 */
async function usleep(
  int $usecs,
): Awaitable<void> {
  return await SleepWaitHandle::create($usecs);
}

} // namespace HH\Asio


// These are in a separate file so they can be loaded before the things that
// use them

namespace HH\Asio {

/**
 * Translate a map of awaitables into a single awaitable of map.
 */
async function m<Tk, Tv>(
  KeyedTraversable<Tk, Awaitable<Tv>> $awaitables,
): Awaitable<Map<Tk, Tv>> {
  $wait_handles = Map {};
  foreach ($awaitables as $index => $awaitable) {
    $wait_handles[$index] = $awaitable->getWaitHandle();
  }
  await AwaitAllWaitHandle::fromMap($wait_handles);
  // TODO: When systemlib supports closures
  // return $wait_handles->map($o ==> $o->result());
  $ret = Map {};
  foreach($wait_handles as $key => $value) {
    $ret[$key] = $value->result();
  }
  return $ret;
}

/**
 * Translate a vector of awaitables into a single awaitable of vector.
 */
async function v<Tv>(
  Traversable<Awaitable<Tv>> $awaitables,
): Awaitable<Vector<Tv>> {
  $wait_handles = Vector {};
  $wait_handles->reserve(count($awaitables));
  foreach ($awaitables as $awaitable) {
    $wait_handles[] = $awaitable->getWaitHandle();
  }
  await AwaitAllWaitHandle::fromVector($wait_handles);
  // TODO: When systemlib supports closures
  // return $wait_handles->map($o ==> $o->result());
  $ret = Vector {};
  foreach($wait_handles as $value) {
    $ret[] = $value->result();
  }
  return $ret;
}

} // namespace HH\Asio


namespace HH\Asio {

///// Mapped /////

/**
 * Similar to Map::map, but maps the values using awaitables
 */
async function mm<Tk, Tv, Tr>(
  KeyedTraversable<Tk, Tv> $inputs,
  (function (Tv): Awaitable<Tr>) $callable,
): Awaitable<Map<Tk, Tr>> {
  $awaitables = Map { };
  foreach ($inputs as $k => $v) {
    $awaitables[$k] = $callable($v);
  }
  return await m($awaitables);
}

/**
 * Similar to mm(), but passes element keys as well
 */
async function mmk<Tk, Tv, Tr>(
  KeyedTraversable<Tk, Tv> $inputs,
  (function (Tk, Tv): Awaitable<Tr>) $callable,
): Awaitable<Map<Tk, Tr>> {
  $awaitables = Map { };
  foreach ($inputs as $k => $v) {
    $awaitables[$k] = $callable($k, $v);
  }
  return await m($awaitables);
}

///// Filtered /////

/**
 * Filter a Map with an Awaitable callback
 */
async function mf<Tk, Tv>(
  KeyedTraversable<Tk, Tv> $inputs,
  (function (Tv): Awaitable<bool>) $callable,
): Awaitable<Map<Tk, Tv>> {
  $tests = await mm($inputs, $callable);
  $results = Map {};
  foreach ($inputs as $key => $value) {
    if ($tests[$key]) {
      // array_filter preserves keys, so we do the same.
      $results[$key] = $value;
    }
  }
  return $results;
}

/**
 * Similar to mfk(), but passes element keys as well
 */
async function mfk<Tk, Tv>(
  KeyedTraversable<Tk, Tv> $inputs,
  (function (Tk, Tv): Awaitable<bool>) $callable,
): Awaitable<Map<Tk, Tv>> {
  $tests = await mmk($inputs, $callable);
  $results = Map {};
  foreach ($inputs as $key => $value) {
    if ($tests[$key]) {
      // array_filter preserves keys, so we do the same.
      $results[$key] = $value;
    }
  }
  return $results;
}

////////////////////
////// Wrapped /////
////////////////////

/**
 * Same as m(), but wrap results into ResultOrExceptionWrappers.
 */
async function mw<Tk, Tv>(
  KeyedTraversable<Tk, Awaitable<Tv>> $awaitables,
): Awaitable<Map<Tk, ResultOrExceptionWrapper<Tv>>> {
  $wrapped = Map { };
  foreach ($awaitables as $k => $a) {
    $wrapped[$k] = wrap($a);
  }
  return await m($wrapped);
}

///// Mapped /////

/**
 * Like mm(), except using a ResultOrExceptionWrapper.
 */
async function mmw<Tk, Tv, Tr>(
  KeyedTraversable<Tk, Tv> $inputs,
  (function (Tv): Awaitable<Tr>) $callable,
): Awaitable<Map<Tk, ResultOrExceptionWrapper<Tr>>> {
  $wrapped = Map { };
  foreach ($inputs as $k => $input) {
    $wrapped[$k] = wrap($callable($input));
  }
  return await m($wrapped);
}

/**
 * Like mmk(), except using a ResultOrExceptionWrapper.
 */
async function mmkw<Tk, Tv, Tr>(
  KeyedTraversable<Tk, Tv> $inputs,
  (function (Tk, Tv): Awaitable<Tr>) $callable,
): Awaitable<Map<Tk, ResultOrExceptionWrapper<Tr>>> {
  $wrapped = Map { };
  foreach ($inputs as $k => $input) {
    $wrapped[$k] = wrap($callable($k, $input));
  }
  return await m($wrapped);
}

///// Filtered /////

/**
 * Like mf(), except using a ResultOrExceptionWrapper.
 */
async function mfw<Tk,T>(
  KeyedTraversable<Tk, T> $inputs,
  (function (T): Awaitable<bool>) $callable,
): Awaitable<Map<Tk, ResultOrExceptionWrapper<T>>> {
  $handles = Map { };
  foreach ($inputs as $k => $input) {
    $handles[$k] = wrap($callable($input));
  }
  $tests = await m($handles);

  $results = Map {};
  foreach ($inputs as $key => $value) {
    $test = $tests[$key];
    if ($test->isFailed()) {
      $results[$key] = new WrappedException($test->getException());
    } else if ($test->getResult() === true) {
      $results[$key] = new WrappedResult($value);
    }
  }
  return $results;
}

/**
 * Like mfk(), except using a ResultOrExceptionWrapper.
 */
async function mfkw<Tk, T>(
  KeyedTraversable<Tk, T> $inputs,
  (function (Tk, T): Awaitable<bool>) $callable,
): Awaitable<Map<Tk, ResultOrExceptionWrapper<T>>> {
  $handles = Map { };
  foreach ($inputs as $k => $v) {
    $handles[$k] = wrap($callable($k, $v));
  }
  $tests = await m($handles);

  $results = Map {};
  foreach ($inputs as $key => $value) {
    $test = $tests[$key];
    if ($test->isFailed()) {
      $results[$key] = new WrappedException($test->getException());
    } else if ($test->getResult() === true) {
      $results[$key] = new WrappedResult($value);
    }
  }
  return $results;
}

} // namespace HH\Asio


namespace HH\Asio {

///// Mapped /////

/**
 * Similar to Vector::map, but maps the values using awaitables
 */
async function vm<Tv, Tr>(
  Traversable<Tv> $inputs,
  (function (Tv): Awaitable<Tr>) $callable,
): Awaitable<Vector<Tr>> {
  $awaitables = Vector { };
  foreach ($inputs as $input) {
    $awaitables[] = $callable($input);
  }
  return await v($awaitables);
}

/**
 * Similar to vm(), but passes element keys as well
 */
async function vmk<Tk, Tv, Tr>(
  KeyedTraversable<Tk, Tv> $inputs,
  (function (Tk, Tv): Awaitable<Tr>) $callable,
): Awaitable<Vector<Tr>> {
  $awaitables = Vector { };
  foreach ($inputs as $k => $v) {
    $awaitables[] = $callable($k, $v);
  }
  return await v($awaitables);
}

///// Filtered /////

/**
 * Apply an async filtering function, and return a Vector of outputs.
 */
async function vf<Tk, T>(
  KeyedTraversable<Tk, T> $inputs,
  (function (T): Awaitable<bool>) $callable,
): Awaitable<Vector<T>> {
  $tests = await mm($inputs, $callable);
  $results = Vector {};
  foreach ($inputs as $key => $value) {
    if ($tests[$key]) {
      $results[] = $value;
    }
  }
  return $results;
}

/**
 * Similar to vf(), but passes element keys as well
 */
async function vfk<Tk, T>(
  KeyedTraversable<Tk, T> $inputs,
  (function (Tk, T): Awaitable<bool>) $callable,
): Awaitable<Vector<T>> {
  $tests = await mmk($inputs, $callable);
  $results = Vector {};
  foreach ($inputs as $key => $value) {
    if ($tests[$key]) {
      $results[] = $value;
    }
  }
  return $results;
}

////////////////////
////// Wrapped /////
////////////////////

/**
 * Same as v(), but wrap results into ResultOrExceptionWrappers.
 */
async function vw<Tv>(
  Traversable<Awaitable<Tv>> $awaitables,
): Awaitable<Vector<ResultOrExceptionWrapper<Tv>>> {
  $wrapped = Vector { };
  foreach ($awaitables as $input) {
    $wrapped[] = wrap($input);
  }
  return await v($wrapped);
}

///// Mapped /////

/**
 * Like vm(), except using a ResultOrExceptionWrapper.
 */
async function vmw<Tv, Tr>(
  Traversable<Tv> $inputs,
  (function (Tv): Awaitable<Tr>) $callable,
): Awaitable<Vector<ResultOrExceptionWrapper<Tr>>> {
  $mapped = Vector {};
  foreach ($inputs as $input) {
    $mapped[] = wrap($callable($input));
  }
  return await v($mapped);
}

/**
 * Like vmk(), except using a ResultOrExceptionWrapper.
 */
async function vmkw<Tk, Tv, Tr>(
  KeyedTraversable<Tk, Tv> $inputs,
  (function (Tk, Tv): Awaitable<Tr>) $callable,
): Awaitable<Vector<ResultOrExceptionWrapper<Tr>>> {
  $mapped = Vector { };
  foreach ($inputs as $k => $v) {
    $mapped[] = wrap($callable($k, $v));
  }
  return await v($mapped);
}

///// Filtered /////

/**
 * Like vf(), except using a ResultOrExceptionWrapper.
 */
async function vfw<Tk,T>(
  KeyedTraversable<Tk, T> $inputs,
  (function (T): Awaitable<bool>) $callable,
): Awaitable<Vector<ResultOrExceptionWrapper<T>>> {
  $mapped = Map { };
  foreach ($inputs as $k => $v) {
    $mapped[$k] = wrap($callable($v));
  }
  $tests = await m($mapped);
  $results = Vector {};
  foreach ($inputs as $key => $value) {
    $test = $tests[$key];
    if ($test->isFailed()) {
      $results[] = new WrappedException($test->getException());
    } else if ($test->getResult() === true) {
      $results[] = new WrappedResult($value);
    }
  }
  return $results;
}

/**
 * Like vfk(), except using a ResultOrExceptionWrapper.
 */
async function vfkw<Tk, T>(
  KeyedTraversable<Tk, T> $inputs,
  (function (Tk, T): Awaitable<bool>) $callable,
): Awaitable<Vector<ResultOrExceptionWrapper<T>>> {
  $mapped = Map { };
  foreach ($inputs as $k => $v) {
    $mapped[$k] = wrap($callable($k, $v));
  }
  $tests = await m($mapped);

  $results = Vector {};
  foreach ($inputs as $key => $value) {
    $test = $tests[$key];
    if ($test->isFailed()) {
      $results[] = new WrappedException($test->getException());
    } else if ($test->getResult() === true) {
      $results[] = new WrappedResult($value);
    }
  }
  return $results;
}

} // namespace HH\Asio

namespace {

/**
 * Helps application inserting an artificial frame in xhprof's reporting.
 */
class XhprofFrame {
  public function __construct($name) {
    xhprof_frame_begin($name);
  }
  public function __destruct() {
    xhprof_frame_end();
  }
}
}

namespace {

class APCIterator implements Iterator{

  private $initialized = false;
  private $constructed = false;
  private $index = -1; // Gets increased when inited
  private $totals = null;
  private $format;
  private $search;
  private $info;


  // Only formats available: type, key, value, memsize, ttl
  // throws notice on different flags
  //
  // $chunk_size and $list doesn't do anything
  // I don't feel the need of chunks, since I don't save entries anyway.
  // I'm not quite sure what $list does, however
  // I believe it isn't implemented yet
  public function __construct($cache, $search = null, $format = APC_ITER_ALL,
                              $chunk_size = 100, $list = APC_LIST_ACTIVE) {

    if(!function_exists('apc_add')) {
      trigger_error("APC must be enabled to use APCIterator", E_ERROR);
    }

    if ($chunk_size < 0) {
      trigger_error("APCIterator chunk size must be 0 or greater.",
                    E_ERROR);
    }
    if ($format > APC_ITER_ALL) {
      trigger_error("APCIterator format is invalid.", E_ERROR);
    }

    if ($format & (
      APC_ITER_FILENAME |
      APC_ITER_DEVICE |
      APC_ITER_INODE |
      APC_ITER_MD5 |
      APC_ITER_NUM_HITS |
      APC_ITER_MTIME |
      APC_ITER_CTIME |
      APC_ITER_DTIME |
      APC_ITER_ATIME |
      APC_ITER_REFCOUNT
    )) {
      trigger_error(
        "Format values FILENAME, DEVICE, INODE, MD5, NUM_HITS, MTIME,".
        " CTIME, DTIME, ATIME, REFCOUNT not supported yet.",
        E_NOTICE
      );
    }

    if ($list != APC_LIST_ACTIVE && $list != APC_LIST_DELETED) {
        trigger_error("APCIterator invalid list type.", E_WARNING);
        return;
    }
    if (strcasecmp($cache, 'user') === 0) {
      // Only user implemented
    } else {
      throw new Exception(
        "Filehits cache not implemented."
      );
    }

    $this->search = $search;
    $this->format = $format;
    $this->initialized = false;  // will be initialized upon first access
    $this->constructed = true;
  }


  public function valid() {
    if (!$this->constructed) {
      return false;
    }
    return count($this->getInfo()) > $this->index;
  }

  public function next() {
    if (!$this->valid()) {
      return false;
    }
    ++$this->index;
    if ($this->search !== null) {
      if (is_array($this->search)) {
        while ($this->valid() &&
               !$this->preg_match_recursive($this->search, $this->key())) {
          ++$this->index;
        }
      } else {
        while ($this->valid() && !preg_match($this->search, $this->key())) {
          ++$this->index;
        }
      }
    }
    return true;
  }

  public function rewind() {
    if (!$this->constructed) {
      return false;
    }
    $this->init();
  }

  public function key() {
    if (!$this->valid()) {
      return false;
    }
    return $this->getInfo()[$this->index]['entry_name'];
  }

  public function current() {
    if (!$this->valid()) return false;
    $info = $this->getInfo()[$this->index];
    $ret = array();
    if ($this->format & APC_ITER_TYPE) {
      $ret['type'] = ($info['type'] == 0) ? 'user' : 'file';
    }
    if ($this->format & APC_ITER_KEY) {
      $ret['key'] = $info['entry_name'];
    }
    if ($this->format & APC_ITER_VALUE) {
      $ret['value'] = apc_fetch($info['entry_name']);
    }
    if ($this->format & APC_ITER_MEM_SIZE) {
      $ret['mem_size'] = $info['mem_size'];
    }
    if ($this->format & APC_ITER_TTL) {
      $ret['ttl'] = $info['ttl'];
    }
    return $ret;
  }

  public function getTotalCount() {
    if (!$this->constructed) {
      return false;
    }
    if (!$this->initialized) {
      $this->init();
    }
    if (!$this->totals) {
      $this->getTotals();
    }
    return $this->totals['count'];
  }

  public function getTotalHits() {
    if (!$this->constructed) {
      return false;
    }
    if (!$this->initialized) {
      $this->init();
    }
    if (!$this->totals) {
      $this->getTotals();
    }
    return $this->totals['hits'];
  }

  public function getTotalSize() {
    if (!$this->constructed) {
      return false;
    }
    if (!$this->initialized) {
      $this->init();
    }
    if (!$this->totals) {
      $this->getTotals();
    }
    return $this->totals['size'];
  }

  private function preg_match_recursive(array $patterns, $string) {
    foreach ($patterns as $pattern) {
      if (preg_match($pattern, $string)) {
        return true;
      }
    }
    return false;
  }

  private function getTotals() {
    $info = $this->getInfo();
    foreach ($info as $list) {
      if ($this->search !== null) {
        if (is_array($this->search)) {
          while (!$this->preg_match_recursive($this->search,
                                              $list['entry_name'])) {
            continue;
          }
        } else {
          if (!preg_match($this->search, $list['entry_name'])) {
            continue;
          }
        }
      }
      $this->totals['size'] += $list['mem_size'];
      $this->totals['hits'] += $list['num_hits'];
    }
    $this->totals['count'] = count($info);
  }

  private function init() {
    $this->info = apc_cache_info()['cache_list'];
    // Order defined by ksort
    ksort($this->info);
    $this->initialized = true;
    $this->index = -1;
    $this->next();
  }

  private function getInfo() {
    if (!$this->initialized) {
      $this->init();
    }
    return $this->info;
  }

  // Used for apc_delete(APCIterator);
  private function delete() {
    if (!$this->constructed) {
      return false;
    }
    if (!$this->initialized) {
      $this->init();
    }
    foreach ($this->info as $key) {
      if ($this->search !== null) {
        if (is_array($this->search)) {
          while (!$this->preg_match_recursive($this->search,
                                              $key['entry_name'])) {
            continue;
          }
        } else {
          if (!preg_match($this->search, $key['entry_name'])) {
            continue;
          }
        }
      }
      apc_delete($key['entry_name']);
    }
    return true;
  }

}
}

namespace {

namespace HH {

interface Awaitable {
  public function getWaitHandle();
}

}
}

namespace {

class InvalidOperationException extends RuntimeException {}
}

namespace {

/**
 * CURLFile can be used to upload a file with CURLOPT_POSTFIELDS.
 */
class CURLFile {
  public string $name = '';
  public string $mime = '';
  public string $postname = '';

  public function __construct(
    string $name,
    string $mime = '',
    string $postname = '',
  ) {
    $this->name = $name;
    $this->mime = $mime;
    $this->postname = $postname;
  }

  public function getFilename(): string {
    return $this->name;
  }

  public function getMimeType(): string {
    return $this->mime;
  }

  public function getPostFilename(): string {
    return $this->postname;
  }

  public function setMimeType(string $mime): void {
    $this->mime = $mime;
  }

  public function setPostFilename(string $postname): void {
    $this->postname = $postname;
  }
}

function curl_file_create(
  string $name,
  string $mime = '',
  string $postname = '',
): CURLFile {
  return new CURLFile($name, $mime, $postname);
}
}

namespace {

class DatePeriod implements Iterator {

  const EXCLUDE_START_DATE = 1;

  private
    $start = null,
    $interval = null,
    $end = null,
    $options = null,
    $current = null,
    $recurrances = null,
    $iterKey = 0;

  public function __construct(
    DateTimeInterface $start,
    DateInterval $interval = null,
    mixed $end = null,
    int $options = null) {

    $this->start = clone $start;
    $this->interval = clone $interval;

    if (is_int($end)) {
      // $end is really $recurrances
      $this->recurrances = $end;
      $end_date = clone $start;
      for ($i = 0; $i <= $this->recurrances; $i++) {
        // add the interval to the start date 'n' times
        $end_date->add($interval);
      }
      $this->end = $end_date;
    } else {
      $this->end = $end;
    }

    $this->options = $options;
    $this->current = clone $start;
  }

  function current() {
    return $this->current;
  }

  function rewind() {
    $this->current = clone $this->start;

    if ($this->options === DatePeriod::EXCLUDE_START_DATE) {
      $this->next();
    }

    $this->iterKey = 0;
  }

  function key() {
    return $this->iterKey;
  }

  function next() {
    if ($this->valid()) {
      // Assign in case it's a DateTimeImmutable
      $this->current = $this->current->add($this->interval);
      $this->iterKey++;
    }
  }

  function valid() {
    return ($this->current >= $this->start && $this->current < $this->end);
  }
}
}

namespace {

function date_diff(
  DateTimeInterface $datetime,
  DateTimeInterface $datetime2,
  bool $absolute = false
) {
  return $datetime->diff($datetime2, $absolute);
}

function date_timezone_get(DateTimeInterface $datetime) {
  return $datetime->getTimezone();
}

function date_offset_get(DateTimeInterface $datetime) {
  return $datetime->getOffset();
}

function date_timestamp_get(DateTimeInterface $datetime) {
  return $datetime->getTimestamp();
}

function date_create_immutable(
  string $time = 'now',
  DateTimeZone $timezone = NULL
) {
  try {
    return new DateTimeImmutable($time, $timezone);
  } catch (Exception $ex) {
    // DateTime and DateTimeImmutable both throw exceptions when they fail but
    // date_create and date_create_immutable should both simply return false
    return false;
  }
}

function timezone_offset_get(
  DateTimeZone $object,
  DateTime $datetime
) {
  return $object->getOffset($datetime);
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.domexception.php )
 *
 * DOM operations raise exceptions under particular circumstances, i.e.,
 * when an operation is impossible to perform for logical reasons.
 *
 * See also Exceptions.
 *
 */
class DOMException extends Exception {
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.directory.php )
 *
 * Instances of Directory are created by calling the dir() function, not
 * by the new operator.
 *
 */
class Directory {
  public $path;
  public $handle;

  public function __construct($path) {
    $this->path = $path;
    $this->handle = opendir($path);
  }

  public function read() {
    return readdir($this->handle);
  }

  public function rewind() {
    rewinddir($this->handle);
  }

  public function close() {
    closedir($this->handle);
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.errorexception.php )
 *
 * An Error Exception.
 *
 */
class ErrorException extends Exception {
  protected $severity;
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/errorexception.construct.php )
   *
   * Constructs the Exception.
   *
   * @message    mixed   The Exception message to throw.
   * @code       mixed   The Exception code.
   * @severity   mixed   The severity level of the exception.
   * @filename   mixed   The filename where the exception is thrown.
   * @lineno     mixed   The line number where the exception is thrown.
   * @previous   mixed   The previous exception used for the exception
   *                     chaining.
   */
  public function __construct($message = "", $code = 0, $severity = 0,
                              $filename = null, $lineno = null, Exception $previous = null) {
    parent::__construct($message, $code, $previous);
    $this->severity = $severity;
    if ($filename !== null) {
      $this->file = $filename;
    }
    if ($lineno !== null) {
      $this->line = $lineno;
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/errorexception.getseverity.php )
   *
   * Returns the severity of the exception.
   *
   * @return     mixed   Returns the severity level of the exception.
   */
  final public function getSeverity() { return $this->severity; }
}

}


namespace __SystemLib {
  // systemlib can't have closures, so we get this...
  final class MethCallerHelper {
    private ?string $class;
    private ?string $method;
    public function __construct(string $class, string $method) {
      $this->class = $class;
      $this->method = $method;
    }
    public function __invoke($x, ...$args) {
      invariant(
        $x instanceof $this->class,
        'object must be an instance of ('.$this->class.'), instead it is ('.
        (\is_object($x) ? \get_class($x) : \gettype($x)).')'
      );
      return $x->{$this->method}(...$args);
    }
    public function getClassName(): string {
      return $this->class;
    }
    public function getMethodName(): string {
      return $this->method;
    }
  };
}

namespace HH {

/**
 * fun is a special function used to create a "pointer" to a function in a
 * typeable way.
 *
 * The argument of fun() must always be a constant string.
 */
<<__IsFoldable>>
function fun(string $s) /* interpreted by the type checker as
                           (function(<hack figures this>): <and this>) */ {
  return $s;
}

/**
 * Like fun, but with the purpose of calling methods. With fun you'd pass in
 * something like 'count' and it'd call count($x) on whatever you pass in.
 * This, rather, will call $x->count() for whatever _object_ $x you pass in,
 * which must be of type $class.
 *
 * For example:
 * $v = Vector {
 *   Vector {1, 2, 3},
 *   Vector {1, 2}
 * };
 * $v->map(meth_caller('Vector', 'count'))  // returns Vector {3, 2}
 * ...calls the 'count' method on the inner vectors, and return a vector
 * of the results of that.
 *
 * Both arguments must be constant strings.
 */
function meth_caller(string $class, string $method) {
  return new \__SystemLib\MethCallerHelper($class, $method);
}

/**
 * Similar to fun, creates a "pointer" to a callable that calls a
 * static method of a class in a typeable way.
 *
 * Both arguments must be constant strings.
 *
 * Example:
 *   class C {
 *     public static function isOdd(int $i): bool { return $i % 2 == 1;}
 *   }
 *   $data = Vector { 1, 2, 3 };
 *   $data->filter(class_meth('C', 'isOdd'));
 */
<<__IsFoldable>>
function class_meth(string $class, string $method)
  /* : (function(<hack figures this>): <and this>) */ {
  return array($class, $method);
}

/**
 * Similar to fun, creates a "pointer" to the invocation of a method on an
 * instance in a typeable way.
 *
 * Both arguments of inst_meth must be be a constant strings.
 *
 * Example:
 *   class C {
 *     private function isOdd(int $i): bool { return $i % 2 == 1; }
 *     private function filter(Vector<int> $data): Vector<int> {
 *       $callback = inst_meth($this, 'isOdd');
 *       return $data->filter($callback);
 *     }
 *   }
 */
function inst_meth($instance, string $method)
  /* : (function(<hack figures this>): <and this>) */ {
  invariant(\is_object($instance), 'expecting an object');
  return array($instance, $method);
}

}


namespace __SystemLib {

abstract final class InvariantCallback {
  public static $cb = null;
}

/**
 * Sometimes people pass objects without a __toString() defined as an arg,
 * which causes a fatal. Handle them gracefully by displaying the class
 * name.
 */
function invariant_violation_helper($arg) {
  if (!\is_object($arg) || \method_exists($arg, '__toString')) {
    return $arg;
  }
  return 'Object of type '.\get_class($arg);
}

}

namespace HH {

class InvariantException extends \Exception {}

/**
 * Pass a function that will be called if any invariant fails. The callback
 * will be called with all the invariant parameters after the condition.
 */
function invariant_callback_register(callable $callback) {
  invariant(!\__SystemLib\InvariantCallback::$cb,
            'Callback already registered: %s',
            \__SystemLib\InvariantCallback::$cb);
  \__SystemLib\InvariantCallback::$cb = $callback;
}

/**
 * Ensure that an invariant is satisfied. If it fails, it calls
 * invariant_violation
 */
function invariant(mixed $test, ...$args): void {
  if (!$test) {
    \HH\invariant_violation(...$args);
  }
}

/**
 * Call this when one of your invariants has been violated. It calls the
 * function you registered with invariant_callback_register and then throws an
 * InvariantException
 */
function invariant_violation(string $format_str, ...$args): void {
  if ($cb = \__SystemLib\InvariantCallback::$cb) {
    $cb($format_str, ...$args);
  }

  $args = \array_map('\__SystemLib\invariant_violation_helper', $args);
  $message = \vsprintf($format_str, $args);

  throw new InvariantException($message);
}

}


namespace __SystemLib {

/* Special function used by FPushCuf* when its argument
 * is not callable.
 */
function __86null() {}

}

namespace {

function fb_autoload_map(mixed $map, string $root): bool {
  trigger_error(
    __FUNCTION__.'(): Use HH\autoload_set_paths() instead.',
    E_DEPRECATED
  );
  return HH\autoload_set_paths($map, $root);
}
}

namespace {

function show_source($filename, $return = false) {
  return highlight_file($filename, $return);
}

function highlight_file($filename, $return = false) {
  $data = file_get_contents($filename);
  if ($data === false) {
    return '';
  }

  return highlight_string($data, $return);
}

function highlight_string($data, $return = false) {
  $colors = [
    'html' => ini_get('highlight.html'),
    'comment' => ini_get('highlight.comment'),
    'default' => ini_get('highlight.default'),
    'string' => ini_get('highlight.string'),
    'keyword' => ini_get('highlight.keyword'),
  ];

  $output = '';
  $last_color = $colors['html'];
  $next_color = null;

  $output .= '<code><span style="color: '.$last_color."\">\n";

  foreach (token_get_all($data) as $token) {
    if (is_array($token)) {
      list($type, $string, $_) = $token;

      if ($type === T_WHITESPACE) {
        $output .= __HPHP_highlight_html_puts($string);
        continue;
      }

      $next_color = __HPHP_highlight_get_color($colors, $type);
    } else {
      $string = $token;

      $next_color = ($string === "\"") ?
                    $colors['string'] : $colors['keyword'];
    }

    if ($last_color != $next_color) {
      if ($last_color != $colors['html']) {
        $output .= '</span>';
      }
      $last_color = $next_color;
      if ($last_color != $colors['html']) {
        $output .= '<span style="color: '.$last_color.'">';
      }
    }

    $output .= __HPHP_highlight_html_puts($string);
  }

  if ($last_color != $colors['html']) {
    $output .= "</span>\n";
  }
  $output .= "</span>\n</code>";

  if ($return) {
    return $output;
  } else {
    echo $output;
  }
}

function __HPHP_highlight_get_color($colors, $type) {
  switch ($type) {
    case T_INLINE_HTML:
      return $colors['html'];

    case T_COMMENT:
    case T_DOC_COMMENT:
      return $colors['comment'];

    case T_OPEN_TAG:
    case T_OPEN_TAG_WITH_ECHO:
      return $colors['default'];

    case T_CLOSE_TAG:
      return $colors['default'];

    case T_ENCAPSED_AND_WHITESPACE:
    case T_CONSTANT_ENCAPSED_STRING:
      return $colors['string'];

    case T_FILE:
    case T_STRING:
    case T_VARIABLE:
    case T_DNUMBER:
    case T_ONUMBER:
    case T_LNUMBER:
      return $colors['default'];

    default:
      return $colors['keyword'];
  }
}

function __HPHP_highlight_html_puts($s) {
  $len = strlen($s);
  $out = '';
  for ($i = 0; $i < $len; $i++) {
    switch ($s[$i]) {
      case "\n":
        $out .= '<br />';
        break;
      case '<':
        $out .= '&lt;';
        break;
      case '>':
        $out .= '&gt;';
        break;
      case '&':
        $out .= '&amp;';
        break;
      case ' ':
        $out .= '&nbsp;';
        break;
      case "\t":
        $out .= '&nbsp;&nbsp;&nbsp;&nbsp;';
        break;
      default:
        $out .= $s[$i];
        break;
    }
  }
  return $out;
}

}

namespace {

namespace HH {

/**
 * Returns the value at an index of an array. This function simplifies the
 * common pattern of checking for an index in an array and selecting a default
 * value if it does not exist. You should NOT use idx() as a general replacement
 * for accessing array indices.
 *
 * idx() is used to look for an index in an array, and return either the value
 * at that index (if it exists) or some default (if it does not). Without
 * idx(), you need to do this:
 *
 *   array_key_exists('index', $arr) ? $arr['index'] : $default
 *
 * This is verbose, and duplicates the variable name and index name, which can
 * lead to errors. With idx(), you can simplify the expression:
 *
 *   idx($arr, 'index', $default);
 *
 * The value $default is optional, and defaults to null if unspecified.
 *
 * The array $arr is permitted to be null; if it is null, idx() guarantees
 * it will return $default.
 *
 * You should NOT use idx() as a general replacement for accessing array
 * indices. If you expect 'index' to always exist, DON'T use idx()!
 *
 *   COUNTEREXAMPLE
 *   idx($arr, 'index'); // If you expect 'index' to exist, this is WRONG!
 *
 * Instead, just access it normally like a sensible human being:
 *
 *   $arr['index']
 *
 * This will give you a helpful warning if the index doesn't exist, allowing
 * you to identify a bug in your program and fix it. In contrast, idx() will
 * fail silently if the index doesn't exist, which won't help you out at all.
 *
 * idx() is for default selection, not a blanket replacement for array access.
  *
 * Finally, you should NOT fix errors about array indexes in parts of the code
 * you don't understand by just replacing an array access with a call to idx().
 * This is sweeping the problem under the rug. Instead, you need to actually
 * understand the problem and determine the most appropriate solution. It is
 * possible that this really is idx(), but you can only make that determination
 * after understanding the context of the error.
 *
 * @param    array   Array to look for an index in.
 * @param    scalar  Index to check for. No longer accepts negative integers for
 *                   accessing elements from the end of the array.
 * @param    mixed   Default value to return if index is not found. By default,
 *                   this is null.
 * @return   mixed   Value at array index if it exists, or the default value
 *                   if not.
 */
function idx($arr, $idx, $default=null) {
  if (\is_array($arr)) {
    return \hphp_array_idx($arr, $idx, $default);
  }

  if ($idx !== null) {
    if (\is_object($arr)) {
      if ($arr instanceof \ConstIndexAccess) {
        if ($arr->containsKey($idx)) {
          return $arr[$idx];
        }
      } else if ($arr instanceof \ConstSet) {
        if ($arr->contains($idx)) {
          return $idx;
        }
      } else if ($arr instanceof \ArrayAccess) {
        if ($arr->offsetExists($idx)) {
          return $arr->offsetGet($idx);
        }
      }
    } else if (\is_string($arr)) {
      if (isset($arr[$idx])) {
        return $arr[$idx];
      }
    }
  }

  return $default;
}

}
}

namespace {

function php_strip_whitespace($file) {
  $data = file_get_contents($file);
  if ($data === false) {
    return "";
  }

  $tokens = token_get_all($data);
  $output = '';
  $prev_space = false;

  for ($i = 0; $i < count($tokens); $i++) {
    $token = $tokens[$i];

    if (!is_array($token)) {
      $output .= $token;
      $prev_space = false;
      continue;
    }

    list($type, $string, $line) = $token;
    switch ($type) {
      case T_WHITESPACE:
        if (!$prev_space) {
          $output .= ' ';
          $prev_space = true;
        }
        break;

      case T_COMMENT:
      case T_DOC_COMMENT:
        // don't reset $prev_space since we didn't output anything
        break;

      case T_END_HEREDOC:
        $output .= $string;
        $next_token = $tokens[++$i];
        if (!is_array($next_token)) {
          $output .= $next_token;
        } else if ($next_token[0] != T_WHITESPACE) {
          $output .= $next_token[1];
        }
        $output .= "\n";
        $prev_space = true;
        break;

      default:
        $output .= $string;
        $prev_space = false;
    }
  }

  return $output;
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.pdoexception.php )
 *
 * Represents an error raised by PDO. You should not throw a PDOException
 * from your own code. See Exceptions for more information about Exceptions
 * in PHP.
 *
 */
class PDOException extends RuntimeException {
  public $errorInfo;
}
}

namespace {

class Redis {
  /* Redis servers run here by default */
  const DEFAULT_PORT = 6379;

  /* Return values from Redis::type() */
  const REDIS_NOT_FOUND = 0;
  const REDIS_STRING    = 1;
  const REDIS_SET       = 2;
  const REDIS_LIST      = 3;
  const REDIS_ZSET      = 4;
  const REDIS_HASH      = 5;

  /* Operational modes
   *
   * In ATOMIC mode, we wait for the server to
   *   respond to each request and return the value
   *   directly.
   *
   * In MULTI mode (activated by calling Redis::multi())
   *   we send commands immediately. but they are held in
   *   a transaction by the server.  Only upon calling
   *   Redis::exec() is the transaction committed, and the
   *   results returned.
   *
   * In PIPELINE mode (activated by calling Redis::pipeline())
   *   we queue all commands locally until invoking Redis::exec()
   *   at which point they are sent to the server in a single batch.
   *   And all results are packaged back in a single batch.
   *
   * In both MULTI and PIPELINE modes, pending commands may be
   *   discarded by calling Redis::discard()
   * The return value for both MULTI and PIPELINE for most commands
   *   is the object itself, meaning fluent calling may be used.
   */
  const ATOMIC   = 0;
  const MULTI    = 1;
  const PIPELINE = 2;

  /* Options to Redis::setOption() and Redis::getOption() */
  const OPT_SERIALIZER   = 1;
  const OPT_PREFIX       = 2;
  const OPT_READ_TIMEOUT = 3;

  /* Type of serialization to use with values stored in redis */
  const SERIALIZER_NONE     = 0;
  const SERIALIZER_PHP      = 1;

  /* Options used by lInsert and similar methods */
  const AFTER  = 'after';
  const BEFORE = 'before';

  /* Connection ---------------------------------------------------------- */

  public function connect($host,
                          $port = -1,
                          $timeout = 0.0,
                          $persistent_id = '',
                          $retry_interval = 0) {
    return $this->doConnect($host, $port, $timeout, $persistent_id,
                            $retry_interval, false);
  }

  public function pconnect($host,
                           $port = -1,
                           $timeout = 0.0,
                           $persistent_id = '',
                           $retry_interval = 0) {
    return $this->doConnect($host, $port, $timeout, $persistent_id,
                            $retry_interval, true);
  }

  public function auth($password) {
    $this->password = $password;
    $this->processCommand('AUTH', $password);
    return $this->processBooleanResponse();
  }

  public function close() {
    $this->processCommand('QUIT');
    fclose($this->connection);
    $this->connection = null;
  }

  public function select($dbNumber) {
    $this->dbNumber = (int)$dbNumber;
    $this->processCommand("SELECT", (int)$dbNumber);
    return $this->processBooleanResponse();
  }

  public function setOption($opt, $value) {
    switch ($opt) {
      case self::OPT_PREFIX:
        $this->prefix = $value;
        return true;

      case self::OPT_SERIALIZER:
        if (($value !== self::SERIALIZER_NONE) &&
            ($value !== self::SERIALIZER_PHP)) {
          throw new RedisException("Invalid serializer option: $value");
        }
        $this->serializer = (int)$value;
        return true;

      case self::OPT_READ_TIMEOUT:
        $this->timeout_seconds  = (int)floor($value);
        $this->timeout_useconds =
          (int)(($value - $this->timeout_seconds) * 1000000);
        return stream_set_timeout($this->connection, $this->timeout_seconds,
                                                     $this->timeout_useconds);

      default:
        return false;
    }
  }

  public function getOption($opt) {
    switch ($opt) {
      case self::OPT_PREFIX:     return $this->prefix;
      case self::OPT_SERIALIZER: return $this->serializer;
      case self::OPT_READ_TIMEOUT:
        return $this->timeout_seconds + ($this->timeout_useconds / 1000000);
    }
    return false;
  }

  /* Server -------------------------------------------------------------- */

  public function config($op, $key, $val = '') {
    if ($op == 'GET') {
      $this->processCommand('CONFIG', 'GET', $key);
      return $this->processMapResponse(false, false);
    }
    if ($op == 'SET') {
      $this->processCommand('CONFIG', 'SET', $key, $val);
      return $this->processBooleanResponse();
    }
    throw new RedisException('First arg must be GET or SET');
  }

  public function info($option = '') {
    if ($option) {
      $this->processCommand('INFO', $option);
    } else {
      $this->processCommand('INFO');
    }
    return $this->processInfoResponse();
  }

  public function resetStat() {
    $this->processCommand('CONFIG', 'RESETSTAT');
    return $this->processBooleanResponse();
  }

  public function slaveOf($host = '', $port = -1) {
    if ($host) {
      if ($port <= 0) {
        $port = self::DEFAULT_PORT;
      }
      $this->processCommand('SLAVEOF', $host, (int)$port);
    } else {
      $this->processCommand('SLAVEOF', 'NO', 'ONE');
    }
    return $this->processBooleanResponse();
  }

  public function client($cmd, $arg = '') {
    $cmd = strtolower($cmd);
    if (func_num_args() == 2) {
      $this->processCommand('CLIENT', $cmd, $arg);
    } else {
      $this->processCommand('CLIENT', $cmd);
    }
    if ($cmd == 'list') {
      return $this->processClientListResponse();
    }
    return $this->processVariantResponse();
  }

  /* Strings ------------------------------------------------------------- */

  public function decr($key, $by = 1) {
    if ($by !== 1) {
      return $this->decrBy($key, $by);
    }
    $this->processCommand("DECR", $this->_prefix($key));
    return $this->processLongResponse();
  }

  public function decrBy($key, $by) {
    if ($by === 1) {
      return $this->decr($key);
    }
    $this->processCommand("DECRBY", $this->_prefix($key), (int)$by);
    return $this->processLongResponse();
  }

  public function incr($key, $by = 1) {
    if ($by !== 1) {
      return $this->incrBy($key, $by);
    }
    $this->processCommand("INCR", $this->_prefix($key));
    return $this->processLongResponse();
  }

  public function incrBy($key, $by) {
    if ($by === 1) {
      return $this->incr($key);
    }
    $this->processCommand("INCRBY", $this->_prefix($key), (int)$by);
    return $this->processLongResponse();
  }

  public function incrByFloat($key, $by) {
    $this->processCommand("INCRBYFLOAT", $this->_prefix($key),
                                               (float)$by);
    return $this->processDoubleResponse();
  }

  public function set($key, $value, $optionArrayOrExpiration = -1) {
    $key = $this->_prefix($key);
    $value = $this->_serialize($value);
    if (is_array($optionArrayOrExpiration) &&
        count($optionArrayOrExpiration) > 0) {
      $ex = array_key_exists('ex', $optionArrayOrExpiration);
      $px = array_key_exists('px', $optionArrayOrExpiration);
      $nx = in_array('nx', $optionArrayOrExpiration, true);
      $xx = in_array('xx', $optionArrayOrExpiration, true);
      if ($nx && $xx) {
        throw new RedisException(
          "Invalid set options: nx and xx may not be specified at the same time"
        );
      }
      $args = [
        $key,
        $value
      ];
      if ($px) {
        $args[] = "px";
        $args[] = $optionArrayOrExpiration['px'];
      } else if($ex) {
        $args[] = "ex";
        $args[] = $optionArrayOrExpiration['ex'];
      }
      if ($nx) {
        $args[] = "nx";
      } else if ($xx) {
        $args[] = "xx";
      }
      $this->processArrayCommand("SET", $args);
    } else if (is_numeric($optionArrayOrExpiration) &&
               (int)$optionArrayOrExpiration > 0) {
      $this->processCommand("SETEX", $key, $optionArrayOrExpiration, $value);
    } else {
      $this->processCommand("SET", $key, $value);
    }
    return $this->processBooleanResponse();
  }

  /* Keys ---------------------------------------------------------------- */

  public function sort($key, array $arr = null) {
    $args = $this->sortClause($arr, $using_store);
    array_unshift($args, $key);
    $this->processArrayCommand('SORT', $args);
    if ($using_store) {
      return $this->processVectorResponse(true);
    }
    return $this->processLongResponse();
  }

  public function sortAsc($key,
                          $pattern = null,
                          $get = null,
                          $start = -1,
                          $count = -1,
                          $store = null) {
    $limit = (($start > 0) AND ($count > 0)) ? [$start, $count] : null;
    return $this->sort($key, [
      'by' => $pattern,
      'get' => $get,
      'limit' => $limit,
      'store' => $store,
      'dir' => 'ASC',
    ]);
  }

  public function sortAscAlpha($key,
                               $pattern = null,
                               $get = null,
                               $start = -1,
                               $count = -1,
                               $store = null) {
    $limit = (($start > 0) AND ($count > 0)) ? [$start, $count] : null;
    return $this->sort($key, [
      'by' => $pattern,
      'get' => $get,
      'limit' => $limit,
      'store' => $store,
      'dir' => 'ASC',
      'alpha' => true,
    ]);
  }

  public function sortDesc($key,
                           $pattern = null,
                           $get = null,
                           $start = -1,
                           $count = -1,
                           $store = null) {
    $limit = (($start > 0) AND ($count > 0)) ? [$start, $count] : null;
    return $this->sort($key, [
      'by' => $pattern,
      'get' => $get,
      'limit' => $limit,
      'store' => $store,
      'dir' => 'DESC',
    ]);
  }

  public function sortDescAlpha($key,
                                $pattern = null,
                                $get = null,
                                $start = -1,
                                $count = -1,
                                $store = null) {
    $limit = (($start > 0) AND ($count > 0)) ? [$start, $count] : null;
    return $this->sort($key, [
      'by' => $pattern,
      'get' => $get,
      'limit' => $limit,
      'store' => $store,
      'dir' => 'DESC',
      'alpha' => true,
    ]);
  }

  public function object($info, $key) {
    $this->processCommand('OBJECT', $info, $this->_prefix($key));
    switch ($info) {
      case 'refcount': return $this->processLongResponse();
      case 'encoding': return $this->processStringResponse();
      default:         return $this->processBooleanResponse();
    }
  }

  /* Hashes -------------------------------------------------------------- */

  public function hMGet($key, array $members) {
    $members = array_values($members);
    $args = array_merge([$this->_prefix($key)], $members);
    $this->processArrayCommand('HMGET', $args);
    return $this->processAssocResponse($members);
  }

  public function hMSet($key, array $pairs) {
    $args = [$this->_prefix($key)];
    foreach ($pairs as $k => $v) {
      $args[] = $k;
      $args[] = $this->_serialize($v);
    }
    $this->processArrayCommand('HMSET', $args);
    return $this->processBooleanResponse();
  }

  /* Sets ---------------------------------------------------------------- */

  public function sRandMember($key, $count = null) {
    $args = [$this->_prefix($key)];
    if ($count !== null) {
       $args[] = $count;
    }
    $this->processArrayCommand('SRANDMEMBER', $args);
    if ($count !== null) {
       return $this->processVectorResponse(true);
    }
    return $this->processStringResponse();
  }

  /* zSets --------------------------------------------------------------- */

  public function zAdd($key, $score, $value/*, $scoreN, $valueN */) {
    $args = func_get_args();
    $count = count($args);
    if (($count - 1) % 2) {
      return false;
    }
    $args[0] = $this->_prefix($args[0]);
    for ($i = 1; $i < $count; $i += 2) {
      $args[$i  ] = (double)$args[$i];
      $args[$i+1] = $this->_serialize($args[$i+1]);
    }
    $this->processArrayCommand('ZADD', $args);
    return $this->processLongResponse();
  }

  protected function zInterUnionStore($cmd,
                                      $key,
                                      array $keys,
                                      array $weights = null,
                                      $op = '') {
    $args = [ $this->_prefix($key), count($keys) ];
    foreach ($keys as $k) {
      $args[] = $this->_prefix($k);
    }

    if ($weights) {
      $args[] = 'WEIGHTS';
      foreach ($weights as $weight) {
        if (is_int($weight) OR
            is_float($weight) OR
            ($weight ===  'inf') OR
            ($weight === '-inf') OR
            ($weight === '+inf')) {
          $args[] = $weight;
        }
      }
    }

    if ($op) {
      $args[] = 'AGGREGATE';
      $args[] = $op;
    }

    $this->processArrayCommand($cmd, $args);
    return $this->processLongResponse();
  }

  public function zInterStore($key,
                              array $keys,
                              array $weights = null,
                              $op = '') {
    return $this->zInterUnionStore('ZINTERSTORE', $key, $keys, $weights, $op);
  }

  public function zUnionStore($key,
                              array $keys,
                              array $weights = null,
                              $op = '') {
    return $this->zInterUnionStore('ZUNIONSTORE', $key, $keys, $weights, $op);
  }

  public function zRange($key, $start, $end, $withscores = false) {
    $args = [
      $this->_prefix($key),
      (int)$start,
      (int)$end,
    ];
    if ($withscores) {
      $args[] = 'WITHSCORES';
    }
    $this->processArrayCommand('ZRANGE', $args);
    if ($withscores) {
      return $this->processMapResponse(true, false);
    }
    return $this->processVectorResponse(true);
  }

  protected function zRangeByScoreImpl($cmd,
                                       $key,
                                       $start,
                                       $end,
                                       array $opts = null) {
    $args = [$this->_prefix($key), $start, $end];
    if (isset($opts['limit']) AND
        is_array($opts['limit']) AND
        (count($opts['limit']) == 2)) {
      list($limit_start, $limit_end) = $opts['limit'];
      $args[] = 'LIMIT';
      $args[] = $limit_start;
      $args[] = $limit_end;
    }
    if (!empty($opts['withscores'])) {
      $args[] = 'WITHSCORES';
    }
    $this->processArrayCommand($cmd, $args);
    if (!empty($opts['withscores'])) {
      return $this->processMapResponse(true, false);
    }
    return $this->processVectorResponse(true);
  }

  public function zRangeByScore($key, $start, $end, array $opts = null) {
    return $this->zRangeByScoreImpl('ZRANGEBYSCORE',
                                    $key, $start, $end, $opts);
  }

  public function zRevRangeByScore($key, $start, $end, array $opts = null) {
    return $this->zRangeByScoreImpl('ZREVRANGEBYSCORE',
                                    $key, $start, $end, $opts);
  }

  public function zRevRange($key, $start, $end, $withscores = false) {
    $args = [
      $this->_prefix($key),
      (int)$start,
      (int)$end,
    ];
    if ($withscores) {
      $args[] = 'WITHSCORES';
    }
    $this->processArrayCommand('ZREVRANGE', $args);
    if ($withscores) {
      return $this->processMapResponse(true, false);
    }
    return $this->processVectorResponse(true);
  }

  /* Scan --------------------------------------------------------------- */

  protected function scanImpl($cmd, $key, $cursor, $pattern, $count) {
    $args = [];
    if ($key !== null) {
      $args[] = $this->_prefix($key);
    }
    $args[] = (int)$cursor;
    if ($pattern !== null) {
      $args[] = 'MATCH';
      if ($cmd === 'SCAN') {
        $args[] = (string)$this->_prefix($pattern);
      }
      else {
        $args[] = (string)$pattern;
      }
    }
    if ($count !== null) {
      $args[] = 'COUNT';
      $args[] = (int)$count;
    }
    $this->processArrayCommand($cmd, $args);
    return $this->processVariantResponse();
  }

  public function scan($cursor, $pattern = null, $count = null) {
    return $this->scanImpl('SCAN', null, $cursor, $pattern, $count);
}

  public function sScan($key, $cursor, $pattern = null, $count = null) {
    return $this->scanImpl('SSCAN', $key, $cursor, $pattern, $count);
  }

  /* Multi --------------------------------------------------------------- */

  protected function flushCallbacks($multibulk = true) {
    if ($multibulk) $this->sockReadData($type); // Response Count
    $ret = [];
    foreach ($this->multiHandler as $callback) {
      $args = isset($callback['args']) ? $callback['args'] : [];
      $ret[] = call_user_func_array($callback['cb'], $args);
    }
    $this->multiHandler = [];
    return $ret;
  }

  public function multi($mode = self::MULTI) {
    if ($mode === self::PIPELINE) {
      return $this->pipeline();
    }
    if ($mode !== self::MULTI) {
      return false;
    }
    $this->discard();
    $this->processCommand('MULTI');
    $resp = $this->sockReadData($type);
    if (($type === self::TYPE_LINE) AND ($resp === 'OK')) {
      $this->mode = self::MULTI;
      return $this;
    }
    return false;
  }

  public function exec() {
    if ($this->mode === self::MULTI) {
      $this->mode = self::ATOMIC;
      $this->processCommand('EXEC');
      return $this->flushCallbacks();
    }
    if ($this->mode === self::PIPELINE) {
      $this->mode = self::ATOMIC;
      foreach ($this->commands as $cmd) {
        $this->processArrayCommand($cmd['cmd'], $cmd['args']);
      }
      $this->commands = [];
      return $this->flushCallbacks(false);
    }
  }

  public function discard() {
    $discard = ($this->mode === self::MULTI);
    $this->mode = self::ATOMIC;
    $this->commands = [];
    $this->multiHandler = [];
    if ($discard) {
       $this->processCommand('DISCARD');
       return $this->process1Response();
    }
    return true;
  }

  public function pipeline() {
    $this->discard();
    $this->mode = self::PIPELINE;
    return $this;
  }

  public function watch($key/* ... */) {
    $args = array_map([$this, '_prefix'], func_get_args());
    $this->processArrayCommand("WATCH", $args);
    return $this->processBooleanResponse();
  }

  public function unwatch() {
    $this->processCommand("UNWATCH");
    return $this->processBooleanResponse();
  }

  /* Batch --------------------------------------------------------------- */

  protected function processMSetCommand($cmd, array $data) {
    $args = [];
    foreach ($data as $key => $val) {
      $args[] = $this->_prefix($key);
      $args[] = $this->_serialize($val);
    }
    $this->processArrayCommand($cmd, $args);
  }

  public function mSet(array $data) {
    $this->processMSetCommand('MSET', $data);
    return $this->processBooleanResponse();
  }

  public function mSetNx(array $data) {
    $this->processMSetCommand('MSETNX', $data);
    return $this->process1Response();
  }

  /* Scripting ----------------------------------------------------------- */

  protected function doEval($cmd, $script, array $args, $numKeys) {
    $keyCount = $numKeys;
    foreach($args as &$arg) {
      if ($keyCount-- <= 0) break;
      $arg = $this->_prefix($arg);
    }
    array_unshift($args, $numKeys);
    array_unshift($args, $script);
    $this->processArrayCommand($cmd, $args);
    $response = $this->processVariantResponse();
    return ($response !== NULL) ? $response : false;
  }

  public function evaluate($script, array $args = [], $numKeys = 0) {
    return $this->doEval('EVAL', $script, $args, $numKeys);
  }

  public function eval($script, array $args = [], $numKeys = 0) {
    return $this->doEval('EVAL', $script, $args, $numKeys);
  }

  public function evaluateSha($sha, array $args = [], $numKeys = 0) {
    return $this->doEval('EVALSHA', $sha, $args, $numKeys);
  }

  public function evalSha($sha, array $args = [], $numKeys = 0) {
    return $this->doEval('EVALSHA', $sha, $args, $numKeys);
  }

  public function script($subcmd/* ... */) {
    switch (strtolower($subcmd)) {
      case 'flush':
      case 'kill':
        $this->processCommand('SCRIPT', $subcmd);
        $response = $this->processVariantResponse();
        return ($response !== NULL) ? true : false;
      case 'load':
        if (func_num_args() < 2) {
          return false;
        }
        $script = func_get_arg(1);
        if (!is_string($script) OR empty($script)) {
          return false;
        }
        $this->processCommand('SCRIPT', 'load', $script);
        $response = $this->processVariantResponse();
        return ($response !== NULL) ? $response : false;
      case 'exists':
        $args = func_get_args();
        $args[0] = 'EXISTS';
        $this->processArrayCommand('SCRIPT', $args);
        return $this->processVariantResponse();
      default:
        return false;
    }
  }

  /* Introspection ------------------------------------------------------- */

  public function isConnected() {
    return $this->checkConnection(false);
  }

  public function getHost() {
    return $this->host;
  }

  public function getPort() {
    return $this->port;
  }

  public function getDBNum() {
    return $this->dbNumber;
  }

  public function getTimeout() {
    return $this->timeout_connect;
  }

  public function getReadTimeout() {
    return $this->getOption(self::OPT_READ_TIMEOUT);
  }

  public function getPersistentId() {
    throw new RedisException('Named persistent connections are '.
                             'not supported.');
  }

  public function getPassword() {
    return $this->password;
  }

  public function getLastError() {
    return $this->lastError;
  }

  public function clearLastError() {
    $this->lastError = null;
    return true;
  }

  /* Standard Function Map ----------------------------------------------- */

  /**
   * The majority of the Redis API is implemented by __call
   * which references this list for how the individual command
   * should be handled.
   *
   * By default the name of the method (key in this array)
   * is uppercased to become the actual command sent to the redis server.
   *
   * Example: 'get' becomes the Redis command `GET`
   *
   * This mapping may be overridden by adding a 'cmd' element such as:
   *   'myget' => [ 'cmd' => 'GET' ],
   *
   * The argument spec is defined by the 'format' subparameter with each
   *   position in the string specifying what type of param it is.
   *  's' => Ordinary string to be passed trough to the server unmodified
   *  'k' => The name of a key.  Prefixed with $this->prefix.
   *  'v' => A piece of user data.  Serialized according to $this->serialize.
   *  'l' => An integer(long).  Explicitly cast from whatever is passed.
   *  'd' => A float(double).  Explicitly cast from whatever is passed.
   *  'b' => A boolean.  Explicitly cast from whatever is passed.
   *  'p' => Pivot point (self::BEFORE or self::AFTER).  Validated.
   *
   * In lieu of 'format', a mapping may specify 'vararg' for variadic methods.
   *   The value must be a bitmask of the VAR_* constants.
   *   See Redis::translateVarArgs()
   *
   * The method (on this class) called to handle the response is named by the
   *   'handler' field.  A shortcut for this is the 'return' field which will
   *   be mapped into 'handler' as: 'process{$return}Response'
   *   To pass arguments to the handler, use 'retargs'.
   *
   * Lastly, the 'alias' field (given by itself), will map calls from one
   *   function directly to another.  If the target method actually exists,
   *   the fcall will be proxied through call_user_func_array().  If the target
   *   is elsewhere in the map, __call's state will be reset to use the new
   *   map element.
   */
  protected static $map = [
    // Connection
    'open' => [ 'alias' => 'connect' ],
    'popen' => [ 'alias' => 'pconnect' ],
    'ping' => [ 'return' => 'Raw' ],
    'echo' => [ 'format' => 's', 'return' => 'String' ],

    // Server
    'bgrewriteaof' => [ 'return' => 'Boolean' ],
    'bgsave' => [ 'return' => 'Boolean' ],
    'dbsize' => [ 'return' => 'Long' ],
    'flushall' => [ 'return' => 'Boolean' ],
    'flushdb' => [ 'return' => 'Boolean' ],
    'lastsave' => [ 'return' => 'Long' ],
    'save' => [ 'return' => 'Boolean' ],
    'time' => [ 'return' => 'Vector' ],

    // Strings
    'append' => [ 'format' => 'kv', 'return' => 'Long' ],
    'bitcount' => [ 'format' => 'kll', 'return' => 'Long' ],
    'bitop' => [ 'vararg' => self::VAR_KEY_NOT_FIRST, 'return' => 'Long' ],
    'get' => [ 'format' => 'k', 'return' => 'Serialized' ],
    'getbit' => [ 'format' => 'kl', 'return' => 'Long' ],
    'getrange' => [ 'format' => 'kll', 'return' => 'String', 'cmd' => 'RANGE' ],
    'getset' => [ 'format' => 'kv', 'return' => 'Serialized' ],
    'setbit' => [ 'format' => 'klv', 'return' => 'Long' ],
    'setex' => [ 'format' => 'klv', 'return' => 'Boolean' ],
    'psetex' => [ 'format' => 'klv', 'return' => 'Boolean' ],
    'setnx' => [ 'format' => 'kv', 'return' => '1' ],
    'setrange' => [ 'format' => 'klv', 'return' => 'Long' ],
    'strlen' => [ 'format' => 'k', 'return' => 'Long' ],

    // Keys
    'del' => [ 'vararg' => self::VAR_KEY_ALL, 'return' => 'Long' ],
    'delete' => [ 'alias' => 'del' ],
    'dump' => [ 'format' => 'k', 'return' => 'Raw' ],
    'exists' => [ 'format' => 'k', 'return' => '1' ],
    'expire' => [ 'format' => 'kl', 'return' => '1' ],
    'settimeout' => [ 'alias' => 'expire' ],
    'pexpire' => [ 'format' => 'kl', 'return' => '1' ],
    'expireat' => [ 'format' => 'kl', 'return' => '1' ],
    'pexpireat' => [ 'format' => 'kl', 'return' => '1' ],
    'keys' => [ 'format' => 's', 'return' => 'Vector' ],
    'getkeys' => [ 'alias' => 'keys' ],
    'migrate' => [ 'format' => 'slkll', 'return' => 'Boolean' ],
    'move' => [ 'format' => 'kl', 'return' => '1' ],
    'persist' => [ 'format' => 'k', 'return' => '1' ],
    'randomkey' => [ 'return' => 'String' ],
    'rename' => [ 'format' => 'kk', 'return' => 'Boolean' ],
    'renamekey' => [ 'alias' => 'rename' ],
    'renamenx' => [ 'format' => 'kk', 'return' => '1' ],
    'type' => [ 'format' => 'k', 'return' => 'Type' ],
    'ttl' => [ 'format' => 'k', 'return' => 'Long' ],
    'pttl' => [ 'format' => 'k', 'return' => 'Long' ],
    'restore' => [ 'format' => 'kls', 'return' => 'Boolean' ],

    // Hashes
    'hdel' => [ 'vararg' => self::VAR_KEY_FIRST, 'return' => 'Long' ],
    'hexists' => [ 'format' => 'ks', 'return' => '1' ],
    'hget' => [ 'format' => 'ks', 'return' => 'Serialized' ],
    'hgetall' => [ 'format' => 'k', 'return' => 'Map',
                                    'retargs' => [false,true] ],
    'hincrby' => [ 'format' => 'ksl', 'return' => 'Long' ],
    'hincrbyfloat' => [ 'format' => 'ksd', 'return' => 'Double' ],
    'hkeys' => [ 'format' => 'k', 'return' => 'Vector' ],
    'hlen' => [ 'format' => 'k', 'return' => 'Long' ],
    'hset' => [ 'format' => 'ksv', 'return' => 'Long' ],
    'hsetnx' => [ 'format' => 'ksv', 'return' => '1' ],
    'hvals' => [ 'format' => 'k', 'return' => 'Vector', 'retargs' => [1] ],

    // Lists
    'blpop' => [ 'vararg' => self::VAR_KEY_ALL_AND_TIMEOUT,
                 'return' => 'Vector', 'retargs' => [1] ],
    'brpop' => [ 'vararg' => self::VAR_KEY_ALL_AND_TIMEOUT,
                 'return' => 'Vector', 'retargs' => [1] ],
    'brpoplpush' => [ 'format' => 'kkl', 'return' => 'Serialized' ],
    'lindex' => [ 'format' => 'kl', 'return' => 'Serialized' ],
    'lget' => [ 'alias' => 'lindex' ],
    'linsert' => [ 'format' => 'kpkv', 'return' => 'Long' ],
    'llen' => [ 'format' => 'k', 'return' => 'Long', 'cmd' => 'LLEN' ],
    'lsize' => [ 'alias' => 'llen' ],
    'lpop' => [ 'format' => 'k', 'return' => 'Serialized' ],
    'lpush' => [ 'vararg' => self::VAR_KEY_FIRST_AND_SERIALIZE,
                 'return' => 'Long' ],
    'lpushx' => [ 'format' => 'kl', 'return' => 'Long' ],
    'lrange' => [ 'format' => 'kll', 'return' => 'Vector', 'retargs' => [1] ],
    'lgetrange' => [ 'alias' => 'lrange' ],
    'lrem' => [ 'format' => 'kvs', 'return' => 'Long' ],
    'lremove' => [ 'alias' => 'lrem' ],
    'lset' => [ 'format' => 'klv', 'return' => 'Boolean' ],
    'ltrim' => [ 'format' => 'kll', 'return' => 'Boolean' ],
    'listtrim' => [ 'alias' => 'ltrim' ],
    'rpop' => [ 'format' => 'k', 'return' => 'Serialized' ],
    'rpoplpush' => [ 'format' => 'kk', 'return' => 'Serialized' ],
    'rpush' => [ 'vararg' => self::VAR_KEY_FIRST_AND_SERIALIZE,
                 'return' => 'Long' ],
    'rpushx' => [ 'format' => 'kl', 'return' => 'Long' ],

    // Sets
    'sadd' => [ 'vararg' => self::VAR_KEY_FIRST_AND_SERIALIZE,
                'return' => 'Long' ],
    'scard' => [ 'format' => 'k', 'return' => 'Long' ],
    'ssize' => [ 'alias' => 'scard' ],
    'sdiff' => [ 'vararg' => self::VAR_KEY_ALL, 'return' => 'Vector' ],
    'sdiffstore' => [ 'vararg' => self::VAR_KEY_ALL, 'return' => 'Long' ],
    'sinter' => [ 'vararg' => self::VAR_KEY_ALL, 'return' => 'Vector' ],
    'sinterstore' => [ 'vararg' => self::VAR_KEY_ALL, 'return' => 'Long' ],
    'sismember' => [ 'format' => 'kv', 'return' => '1' ],
    'scontains' => [ 'alias' => 'sismember' ],
    'smembers' => [ 'format' => 'k', 'return' => 'Vector' ],
    'sgetmembers' => [ 'alias' => 'smembers' ],
    'smove' => [ 'format' => 'kkv', 'return' => '1' ],
    'spop' => [ 'format' => 'k', 'return' => 'Serialized' ],
    'srem' => [ 'vararg' => self::VAR_KEY_FIRST_AND_SERIALIZE,
                'return' => 'Long' ],
    'sremove' => [ 'alias' => 'srem' ],
    'sunion' => [ 'vararg' => self::VAR_KEY_ALL, 'return' => 'Vector' ],
    'sunionstore' => [ 'vararg' => self::VAR_KEY_ALL, 'return' => 'Long' ],

    // zSets
    'zcard' => [ 'format' => 'k', 'return' => 'Long' ],
    'zsize' => [ 'alias' => 'zcard' ],
    'zcount' => [ 'format' => 'kss', 'return' => 'Long' ],
    'zincrby' => [ 'format' => 'kdv', 'return' => 'Double' ],
    'zinter' => [ 'alias' => 'zinterstore' ],
    'zunion' => [ 'alias' => 'zunionstore' ],
    'zrank' => [ 'format' => 'kv', 'return' => 'Long' ],
    'zrevrank' => [ 'format' => 'kv', 'return' => 'Long' ],
    'zrem' => [ 'vararg' => self::VAR_KEY_FIRST_AND_SERIALIZE,
                'return' => 'Long' ],
    'zremove' => [ 'alias' => 'zrem' ],
    'zdelete' => [ 'alias' => 'zrem' ],
    'zremrangebyrank' => [ 'format' => 'kll', 'return' => 'Long' ],
    'zdeleterangebyrank' => [ 'alias' => 'zremrangebyrank' ],
    'zremrangebyscore' => [ 'format' => 'kll', 'return' => 'Long' ],
    'zdeleterangebyscore' => [ 'alias' => 'zremrangebyscore' ],
    'zreverserange' => [ 'alias' => 'zrevrange' ],
    'zscore' => [ 'format' => 'kv', 'return' => 'Double' ],

    // Publish
    'publish' => [ 'format' => 'kv', 'return' => 'Long' ],
    /* These APIs are listed as "subject to change", avoid for now */
    'subscribe' => false,
    'psubscribe' => false,
    'unsubscribe' => false,
    'punsubscribe' => false,

    // Batch Ops
    'mget' => [ 'vararg' => self::VAR_KEY_ALL,
                'return' => 'Vector', 'retargs' => [1] ],
    'getmultiple' => [ 'alias' => 'mget' ],
  ];


  /* Internal Use Only beyond this point --------------------------------- */

  protected $host = '';
  protected $port = -1;
  protected $password = '';
  protected $dbNumber = 0;
  protected $last_connect = -1;
  protected $retry_interval = 0;
  protected $persistent = false;
  protected $connection = null;
  protected $lastError = null;

  protected $timeout_connect = 0;
  protected $timeout_seconds = 0;
  protected $timeout_useconds = 0;

  protected $mode = self::ATOMIC;
  protected $multiHandler = [];
  protected $commands = [];
  protected $prefix = '';
  protected $serializer = self::SERIALIZER_NONE;

  /* protocol ------------------------------------------------------------ */

  /* Internal use constants for var arg parsing */
  const VAR_KEY_NONE      = 0;
  const VAR_KEY_FIRST     = 1;
  const VAR_KEY_NOT_FIRST = 2;
  const VAR_KEY_ALL       = 3;
  const VAR_KEY_MASK      = 0x000F;

  const VAR_SERIALIZE     = 0x0010;
  const VAR_TIMEOUT       = 0x0020;

  const VAR_KEY_FIRST_AND_SERIALIZE = 0x0011;
  const VAR_KEY_ALL_AND_TIMEOUT     = 0x0023;

  /* Returned by reference from Redis::sockReadData()
   * Depending on the type of data returned by the server
   */
  const TYPE_LINE      = '+';
  const TYPE_INT       = ':';
  const TYPE_ERR       = '-';
  const TYPE_BULK      = '$';
  const TYPE_MULTIBULK = '*';

  protected function checkConnection($auto_reconnect = true) {
    if (!$this->connection) {
        return false;
    }

    // Check if we have hit the stream timeout
    if (stream_get_meta_data($this->connection)['timed_out']) {
      throw new RedisException("read error on connection");
    }
    if (!feof($this->connection)) {
      // Connection seems fine
      return true;
    }

    if ((time() - $this->last_connect) < $this->retry_interval) {
      // We've tried connecting too recently, don't retry
      return false;
    }

    if ($auto_reconnect AND
        $this->doConnect($this->host, $this->port,
                         $this->timeout_connect,
                         null, $this->retry_interval,
                         $this->persistent)) {
      if ($this->password) {
        $this->auth($this->password);
      }
      if ($this->dbNumber) {
        $this->select($this->dbNumber);
      }
      return true;
    }

    // Reconnect failed, give up
    return false;
  }

  protected function sockReadLine() {
    $line = '';
    do {
      if (!$this->checkConnection()) {
        return false;
      }
      $line .= fgets($this->connection);
    } while (substr($line, -2) !== "\r\n");

    return substr($line, 0, -2);
  }

  protected function sockReadData(&$type) {
    $line = $this->sockReadLine();
    if (strlen($line)) {
      $type = $line[0];
      $line = substr($line, 1);
      switch ($type) {
        case self::TYPE_ERR:
          if (!strncmp($line, '-ERR SYNC ', 10)) {
            throw new RedisException("Sync with master in progress");
          }
          return $line;
        case self::TYPE_INT:
        case self::TYPE_LINE:
        case self::TYPE_MULTIBULK: // Count of elements to follow
          return $line;

        case self::TYPE_BULK:
          $bytes = (int)$line;
          if ($bytes < 0) return null;
          $buf = '';
          while (strlen($buf) < ($bytes + 2)) {
            $buf .= fread($this->connection, ($bytes + 2) - strlen($buf));
            if (!$this->checkConnection()) {
              return null;
            }
          }
          return substr($buf, 0, -2);

        default:
          throw new RedisException("protocol error, got '{$type}' ".
                                   "as reply type byte");
      }
    }
    return null;
  }

  /**
   * Process arguments for variadic functions based on $flags
   *
   * Redis::VAR_TIMEOUT indicates that the last argument
   *   in the list should be treated as an integer timeout
   *   for the operation
   * Redis::VAR_KEY_* indicates which (NONE, FIRST, NOT_FIRST, ALL)
   *   of the arguments (excluding TIMEOUT, as application)
   *   should be treated as keys, and thus prefixed with Redis::$prefix
   * Redis::VAR_SERIALIZE indicates that all non-timeout/non-key
   *   fields are data values, and should be serialzed
   *   (if a serialzied is specified)
   */
  protected function translateVarArgs(array $args, $flags) {
    // Check alternate vararg schemes first
    if (($flags & self::VAR_TIMEOUT) AND
        (count($args) == 2) AND
        (is_array($args[0])) AND
        (is_int($args[1]))) {
      $args = $args[0] + [$args[1]];
    }
    if ((!($flags & self::VAR_TIMEOUT)) AND
        (count($args) == 1) AND
        (is_array($args[0]))) {
      $args = $args[0];
    }

    // Then prefix, serialie, and cast as needed
    if ($flags & self::VAR_TIMEOUT) {
      $timeout = array_pop($args);
    }
    if (($this->prefix AND ($flags & self::VAR_KEY_MASK)) OR
        ($flags & self::VAR_SERIALIZE)) {
      $first = true;
      $varkey = $flags & self::VAR_KEY_MASK;
      foreach($args as &$arg) {
        if (( $first AND ($varkey == self::VAR_KEY_FIRST)) OR
            (!$first AND ($varkey == self::VAR_KEY_NOT_FIRST)) OR
                         ($varkey == self::VAR_KEY_ALL)) {
          $arg = $this->_prefix($arg);
        } else if ($flags & self::VAR_SERIALIZE) {
          $arg = $this->_serialize($arg);
        }
        $first = false;
      }
    }
    if ($flags & self::VAR_TIMEOUT) {
      $args[] = (int)$timeout;
    }

    return $args;
  }

  /**
   * Actually send a command to the server.
   * assumes all appropriate prefixing and serialization
   * has been preformed by the caller and constructs
   * a Redis Protocol packet in the form:
   *
   * *N\r\n
   *
   * Folled by N instances of:
   *
   * $L\r\nA
   *
   * Where L is the length in bytes of argument A.
   *
   * So for the command `GET somekey` we'd serialize as:
   *
   * "*2\r\n$3\r\nGET\r\n$7\r\nsomekey\r\n"
   */
  protected function processArrayCommand($cmd, array $args) {
    if ($this->mode == self::PIPELINE) {
      $this->commands[] = [ 'cmd' => $cmd, 'args' => $args ];
      return true;
    }

    $clen = strlen($cmd);
    $count = count($args) + 1;
    $cmd = "*{$count}\r\n\${$clen}\r\n{$cmd}\r\n";

    while (count($args)) {
      $arg = (string)array_shift($args);
      $alen = strlen($arg);
      $cmd .= "\${$alen}\r\n{$arg}\r\n";
    }

    if (!$this->checkConnection()) {
      return false;
    }
    return (bool)fwrite($this->connection, $cmd);
  }

  protected function processCommand($cmd/* ... */) {
    $args = func_get_args();
    array_shift($args);
    return $this->processArrayCommand($cmd, $args);
  }

  public function _serialize($str) {
    switch ($this->serializer) {
      case self::SERIALIZER_NONE:
        return $str;
      case self::SERIALIZER_PHP:
        return serialize($str);
      default:
        throw new RedisException("Not Implemented");
    }
  }

  public function _unserialize($str) {
    switch ($this->serializer) {
      case self::SERIALIZER_NONE:
        return $str;
      case self::SERIALIZER_PHP:
        return unserialize($str);
      default:
        throw new RedisException("Not Implemented");
    }
  }

  protected function processClientListResponse() {
    if ($this->mode !== self::ATOMIC) {
      $this->multiHandler[] = [ 'cb' => [$this,'processClientListResponse'] ];
      if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
        return false;
      }
      return $this;
    }
    $resp = $this->sockReadData($type);
    if (($type !== self::TYPE_LINE) AND ($type !== self::TYPE_BULK)) {
      return null;
    }
    $ret = [];
    $pairs = explode(' ', trim($resp));
    foreach ($pairs as $pair) {
      $kv = explode('=', $pair, 2);
      if (count($kv) == 1) {
        $ret[] = $pair;
      } else {
        list($k, $v) = $kv;
        $ret[$k] = $v;
      }
    }
    return $ret;
  }

  protected function processVariantResponse() {
    if ($this->mode !== self::ATOMIC) {
      $this->multiHandler[] = [ 'cb' => [$this,'processVariantResponse'] ];
      if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
        return false;
      }
      return $this;
    }

    return $this->doProcessVariantResponse();
  }

  private function doProcessVariantResponse() {
    $resp = $this->sockReadData($type);

    if ($type === self::TYPE_INT) {
      return (int) $resp;
    }

    if ($type === self::TYPE_MULTIBULK) {
      $ret = [];
      $lineNo = 0;
      $count = (int) $resp;
      while($count--) {
        $lineNo++;
        $ret[] = $this->doProcessVariantResponse();
      }
      return $ret;
    }

    if ($type === self::TYPE_ERR) {
      $this->lastError = $resp;
      return null;
    }

    return $resp;
  }

  protected function processSerializedResponse() {
    if ($this->mode === self::ATOMIC) {
      $resp = $this->sockReadData($type);
      if ($resp === null) {
        return false;
      }
      return (($type === self::TYPE_LINE) OR ($type === self::TYPE_BULK))
             ? $this->_unserialize($resp) : false;
    }
    $this->multiHandler[] = [ 'cb' => [$this,'processSerializedResponse'] ];
    if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
      return false;
    }
    return $this;
  }

  protected function processBooleanResponse() {
    if ($this->mode === self::ATOMIC) {
      $resp = $this->sockReadData($type);
      return ($type === self::TYPE_LINE) AND ($resp === 'OK');
    }
    $this->multiHandler[] = [ 'cb' => [$this,'processBooleanResponse'] ];
    if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
      return false;
    }
    return $this;
  }

  protected function processLongResponse() {
    if ($this->mode === self::ATOMIC) {
      $resp = $this->sockReadData($type);
      return ($type === self::TYPE_INT) ? ((int)$resp) : null;
    }
    $this->multiHandler[] = [ 'cb' => [$this,'processLongResponse'] ];
    if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
      return false;
    }
    return $this;
  }

  protected function processDoubleResponse() {
    if ($this->mode === self::ATOMIC) {
      $resp = $this->sockReadData($type);
      if (($type === self::TYPE_INT) ||
          ($type === self::TYPE_BULK && is_numeric($resp))) {
        return (float)$resp;
      }
      return false;
    }
    $this->multiHandler[] = [ 'cb' => [$this,'processDoubleResponse'] ];
    if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
      return false;
    }
    return $this;
  }

  protected function processStringResponse() {
    if ($this->mode === self::ATOMIC) {
      $resp = $this->sockReadData($type);
      return (($type === self::TYPE_LINE) OR ($type === self::TYPE_BULK))
             ? ((string)$resp) : null;
    }
    $this->multiHandler[] = [ 'cb' => [$this,'processStringResponse'] ];
    if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
      return false;
    }
    return $this;
  }

  protected function processVectorResponse($unser = 0) {
    if ($this->mode !== self::ATOMIC) {
      $this->multiHandler[] = [ 'cb' => [$this, 'processVectorResponse'],
                                'args' => [$unser]
                           ];
      if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
        return false;
      }
      return $this;
    }

    $count = $this->sockReadData($type);
    if ($type !== self::TYPE_MULTIBULK) {
      return null;
    }

    $ret = [];
    $lineNo = 0;
    while($count--) {
      $lineNo++;
      $val = $this->sockReadData($type);
      if ($unser AND (($lineNo % $unser) == 0)) {
        $val = $this->_unserialize($val);
      }
      $ret[] = $val !== null ? $val : false;
    }
    return $ret;
  }

  protected function processMapResponse($unser_key, $unser_val = true) {
    if ($this->mode !== self::ATOMIC) {
      $this->multiHandler[] = [ 'cb' => [$this, 'processMapResponse'],
                                'args' => [$unser_key,$unser_val]
                              ];
      if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
        return false;
      }
      return $this;
    }

    $count = $this->sockReadData($type);
    if ($type !== self::TYPE_MULTIBULK) {
      return null;
    }

    $ret = [];
    while($count > 1) {
      $key = $this->sockReadData($type);
      if ($unser_key) {
        $key = $this->_unserialize($key);
      }
      $val = $this->sockReadData($type);
      if ($unser_val) {
        $val = $this->_unserialize($val);
      }
      $ret[$key] = $val;
      $count -= 2;
    }
    if ($count > 1) {
      $ret[$this->sockReadData($type)] = null;
    }
    return $ret;
  }

  protected function processAssocResponse(array $keys, $unser_val = true) {
    if ($this->mode !== self::ATOMIC) {
      $this->multiHandler[] = [ 'cb' => [$this, 'processAssocResponse'],
                                'args' => [$keys, $unser_val]
                              ];
      if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
        return false;
      }
      return $this;
    }

    $count = $this->sockReadData($type);
    if ($type !== self::TYPE_MULTIBULK) {
      return null;
    }

    $ret = [];
    while($count--) {
      $key = array_shift($keys);
      $val = $this->sockReadData($type);
      if ($unser_val) {
        $val = $this->_unserialize($val);
      }
      $ret[$key] = $val !== null ? $val : false;
    }
    return $ret;
  }

  protected function process1Response() {
    if ($this->mode === self::ATOMIC) {
      $resp = $this->sockReadData($type);
      return ($type === self::TYPE_INT) && ($resp === '1');
    }
    $this->multiHandler[] = [ 'cb' => [$this,'process1Response'] ];
    if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
      return false;
    }
    return $this;
  }

  protected function processTypeResponse() {
    if ($this->mode === self::ATOMIC) {
      $resp = $this->sockReadData($type);
      if ($type !== self::TYPE_LINE) {
        return self::REDIS_NOT_FOUND;
      }
      switch($resp) {
        case 'string':  return self::REDIS_STRING;
        case 'set':     return self::REDIS_SET;
        case 'list':    return self::REDIS_LIST;
        case 'zset':    return self::REDIS_ZSET;
        case 'hash':    return self::REDIS_HASH;
        default:        return self::REDIS_NOT_FOUND;
      }
    }
    $this->multiHandler[] = [ 'cb' => 'processTypeResponse' ];
    if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
      return false;
    }
    return $this;
  }

  protected function processRawResponse() {
    if ($this->mode === self::ATOMIC) {
      return $this->sockReadLine();
    }
    $this->multiHandler[] = [ 'cb' => 'processRawResponse' ];
    if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
      return false;
    }
    return $this;
  }

  protected function processInfoResponse() {
    if ($this->mode !== self::ATOMIC) {
      $this->multiHandler[] = [ 'cb' => 'processInfoResponse' ];
      if (($this->mode === self::MULTI) && !$this->processQueuedResponse()) {
        return false;
      }
      return $this;
    }
    $resp = $this->sockReadData($type);
    if (($type !== self::TYPE_LINE) AND ($type !== self::TYPE_BULK)) {
      return false;
    }

    $ret = [];
    $lines = preg_split('/[\r\n]+/', $resp);
    foreach ($lines as $line) {
      if ((substr($line, 0, 1) == '#') OR
          !trim($line)) {
        continue;
      }
      $colon = strpos($line, ':');
      if ($colon === false) {
        break;
      }
      list($key, $val) = explode(':', $line, 2);
      $ret[$key] = $val;
    }
    return $ret;
  }

  protected function processQueuedResponse() {
    $resp = $this->sockReadData($type);
    return ($type === self::TYPE_LINE) AND ($resp === 'QUEUED');
  }

  public function _prefix($key) {
    return $this->prefix . $key;
  }

  /**
   * Dispatches all commands in the Redis::$map list
   *
   * All other commands are handled by explicit implementations
   */
  public function __call($fname, $args) {
    $fname = strtolower($fname);
    if (!isset(self::$map[$fname])) {
      trigger_error("Call to undefined function Redis::$fname()", E_ERROR);
      return null;
    }
    $func = self::$map[$fname];
    if ($func === false) {
      throw new RedisException("Redis::$fname() is currently unimplemented");
    }

    // Normalize record
    if (!empty($func['alias'])) {
      if (isset(self::$map[$func['alias']])) {
        $fname = $func['alias'];
        $func = self::$map[$fname];
      } else {
        return call_user_func_array([$this,$func['alias']],$args);
      }
    }
    if (empty($func['format'])) {
      $func['format'] = isset($func['vararg']) ? '...' : '';
    }
    if (empty($func['cmd'])) {
      $func['cmd'] = strtoupper($fname);
    }
    if (empty($func['handler'])) {
      $func['handler'] = empty($func['return'])
                       ? null : "process{$func['return']}Response";
    }
    if (empty($func['retargs'])) {
      $func['retargs'] = [];
    }

    $format = $func['format'];
    $argc = count($args);

    if ($format == '...') {
      $args = $this->translateVarArgs($args, $func['vararg']);
      $this->processArrayCommand($func['cmd'], $args);
      if (empty($func['handler'])) {
        return null;
      }
      return call_user_func_array([$this, $func['handler']], $func['retargs']);
    }

    $flen = strlen($format);
    for ($i = 0; $i < $flen; $i++) {
      if (!array_key_exists($i, $args)) {
        if (isset($func['defaults']) AND
            array_key_exists($func['defaults'], $i)) {
          $args[$i] = $func['defaults'][$i];
        } else {
          trigger_error(
            "Redis::$fname requires at least $flen parameters $argc given",
            E_ERROR);
          return null;
        }
      }
      switch ($format[$i]) {
        case 'k': $args[$i] = $this->_prefix($args[$i]); break;
        case 'v': $args[$i] = $this->_serialize($args[$i]); break;
        case 's': $args[$i] = (string)$args[$i]; break;
        case 'l': $args[$i] = (int)$args[$i]; break;
        case 'd': $args[$i] = (float)$args[$i]; break;
        case 'b': $args[$i] = (bool)$args[$i]; break;
        case 'p':
          if (($args[$i] !== self::BEFORE) AND ($args[$i] !== self::AFTER)) {
            trigger_error(
              "Argument $i to Redis::$fname must be 'before' or 'after'",
              E_ERROR);
            return null;
          } break;
      }
    }
    if ($func['cmd'] == "LREM") {
      //
      // The PHP interface has arguments in one order:
      //   https://github.com/nicolasff/phpredis#lrem-lremove
      // But the server wants them in another:
      //   http://redis.io/commands/lrem
      // So just swap them prior to marshalling them out.
      //
      $tmp = $args[1];
      $args[1] = $args[2];
      $args[2] = $tmp;
    }
    $this->processArrayCommand($func['cmd'], $args);
    if (empty($func['handler'])) {
      return null;
    }
    return call_user_func_array([$this, $func['handler']], $func['retargs']);
  }

  /* --------------------------------------------------------------------- */

  protected function doConnect($host,
                               $port,
                               $timeout,
                               $persistent_id,
                               $retry_interval,
                               $persistent = false) {


    if ($port <= 0) {
      if ((strlen($host) > 0) && ($host[0] == '/')) {
        // Turn file path into unix:///path/to/sock
        $host = 'unix://' . $host;
        $port = 0;
      } elseif ((strlen($host) > 7) && !strncmp($host, 'unix://', 7)) {
        // Leave explicit unix:// socket as is
        $port = 0;
      } else {
        // Default port for TCP connections
        $port = self::DEFAULT_PORT;
      }
    }

    if ($persistent) {
      if (!empty($persistent_id)) {
        $pid     = array('id' => array('persistent_id' => $persistent_id));
        $context = stream_context_create($pid);
        $sok     = $host;
        if ($port > 0) $sok .= ':' . $port;
        $conn    = stream_socket_client(
          $sok, $errno, $errstr, $timeout, 2, $context);
      } else {
        $conn = pfsockopen($host, $port, $errno, $errstr, $timeout);
      }
    } else {
        $conn = fsockopen($host, $port, $errno, $errstr, $timeout);
    }
    $this->last_connect = time();
    $this->host = $host;
    $this->port = $port;
    $this->retry_interval = $retry_interval;
    $this->timeout_connect = $timeout;
    $this->persistent = $persistent;
    $this->persistent_id = $persistent_id;
    $this->connection = $conn;
    $this->dbNumber = 0;
    $this->commands = [];
    $this->multiHandler = [];
    $this->mode = self::ATOMIC;

    if (!$this->connection) {
      trigger_error(
        "Failed connecting to redis server at {$host}: {$errstr}",
        E_WARNING);
      return false;
    }
    stream_set_blocking($this->connection, true);
    $this->setOption(Redis::OPT_READ_TIMEOUT, $timeout);

    return true;
  }

  protected function sortClause(array $arr, &$using_store) {
    $using_store = false;
    if (!$arr) {
      return [];
    }

    $ret = [];
    foreach(['by','sort','store','get','alpha','limit','dir'] as $k) {
      if (isset($arr[$k])) {
        $v = $arr[$k];
      } else if (isset($arr[strtoupper($k)])) {
        $v = $arr[strtoupper($k)];
      } else {
        continue;
      }

      if (($k == 'get') AND is_array($v)) {
        foreach ($v as $val) {
          $ret[] = 'GET';
          $ret[] = $val;
        }
        continue;
      }

      if ($k == 'alpha') {
        if ($v === true) {
          $ret[] = 'ALPHA';
        }
        continue;
      }

      if ($k == 'limit') {
        if (is_array($val) AND (count($val) == 2)) {
          list($off, $cnt) = $val;
          $ret[] = 'LIMIT';
          $ret[] = $off;
          $ret[] = $cnt;
        }
        continue;
      }

      if ($k == 'store') {
        $using_store = true;
      }
      if ($k == 'dir') {
        $ret[] = strtoupper($v);
        continue;
      }

      $ret[] = strtoupper($k);
      $ret[] = $v;
    }

    return $ret;
  }

  public function __destruct() {

  }
}
}

namespace {

class RedisSessionModule implements SessionHandlerInterface {
  /**
   * Total of all connection weights, used as divisor in key distribution
   */
  protected $weight = 0;

  /**
   * Map of redis backend servers to use
   *
   * Comes from session.save_path which is a comma delimted list of URIs
   * in the form of:
   *
   *   proto://hostOrPath:optionalPort?key=val&key=val...
   *
   * Where proto is one of: tcp | unix
   *
   * When proto is 'tcp' and no port is given, Redis::DEFAULT_PORT is assumed
   *
   * Key/Value pairs are as follows:
   *  weight(int) - Likelihood of using this backend will be $weight/$total
   *  timeout(int) - Connection timeout in seconds
   *  persistent(int) - 0 or 1 for non-persistent or persistent connections
   *  prefix(string) - String prefix to apply to all session keys in the DB
   *  auth(string) - Password used to authenticate to the DB
   *  database(int) - Database shard to use
   *
   * Defaults can be found in the code below
   */
  protected $paths = [];

  public function open($save_path, $session_name) {
    $this->weight = 0;
    $this->paths  = [];

    $paths = preg_split('/[\s,]+/', $save_path, -1, PREG_SPLIT_NO_EMPTY);
    foreach ($paths as $path) {
      if (!strncmp($path, "unix:", 5)) {
        $path = 'file:' . substr($path, 5);
      }
      $url = parse_url($path);
      $args = [
        'weight' => 1,
        'timeout' => 86400,
        'persistent' => 0,
        'prefix' => 'PHPREDIS_SESSION:',
        'auth' => '',
        'database' => 0
      ];
      if (isset($url['query'])) {
        parse_str($url['query'], $query);
        foreach ($args as $key => &$val) {
          if (!isset($query[$key])) continue;
          if (is_string($val)) {
            $val = $query[$key];
          } else {
            $val = (int)$query[$key];
          }
        }
      }

      if ($args['weight'] === 0) {
        // Disabled target, skip
        continue;
      }
      if ($args['weight'] < 1) {
        error_log("Invalid weight specified for session.save_path(redis), ".
                  "assuming 1");
        $args['weight'] = 1;
      }

      if (isset($url['scheme']) && ($url['scheme'] == 'file')) {
        $args['host'] = "unix://{$url['path']}";
        $args['port'] = null;
      } else {
        $args['host'] = $url['host'];
        $args['port'] = !empty($url['port'])
                      ? $url['port'] : Redis::DEFAULT_PORT;
      }

      $args['connection'] = null;

      $this->weight += $args['weight'];
      $this->paths[] = $args;
    }

    return true;
  }

  protected function &selectWeight($key) {
    if (count($this->paths) === 1) {
      return $this->paths[0];
    }
    $pos  = abs(unpack("I", $key));
    $pos %= $this->weight;
    foreach ($this->paths as $path) {
      $pos -= $path['weight'];
      if ($pos <= 0) {
        return $path;
      }
    }

    throw new RedisException("Ran out of weights selecting redis host ".
                             "for session: $key");
  }

  protected function connect($key) {
    $r =& $this->selectWeight($key);
    if (!empty($r['connection'])) {
      return $r['connection'];
    }

    $redis = new Redis;
    $func = ($r['persistent']) ? 'pconnect' : 'connect';
    if (!$redis->{$func}($r['host'], $r['port'], $r['timeout'])) {
      return false;
    }
    if (($r['auth'] !== '') &&
        !$redis->auth($r['auth'])) {
      return false;
    }
    if (($r['database'] !== 0) &&
        !$redis->select($r['database'])) {
      return false;
    }
    if (!$redis->setOption(Redis::OPT_PREFIX, $r['prefix'])) {
      return false;
    }

    $r['connection'] = $redis;
    return $redis;
  }

  public function close() {
    foreach ($this->paths as &$path) {
      $path['connection'] = null;
    }

    return true;
  }

  public function read($key) {
    $redis = $this->connect($key);
    return (string)$redis->get($key);
  }

  public function write($key, $value) {
    $redis = $this->connect($key);
    return $redis->set($key, $value, ini_get('session.gc_maxlifetime'));
  }

  public function destroy($key) {
    $redis = $this->connect($key);
    if ($redis === false) {
        return false;
    } else {
        $redis->del($key);
        return true;
    }
  }

  public function gc($maxlifetime) {
    // Handled by $redis->set(..., ini_get('session.gc_maxlifetime'))
    return 0;
  }
}
}

namespace {

namespace HH {
  abstract final class Shapes {

    public static function idx(
      array $shape,
      arraykey $index,
      $default = null,
    ) {
      return \hphp_array_idx($shape, $index, $default);
    }

    public static function keyExists(
      array $shape,
      arraykey $index,
    ): bool {
      return \array_key_exists($index, $shape);
    }

    public static function removeKey(
      array &$shape,
      arraykey $index,
    ): void {
      unset($shape[$index]);
    }

    public static function toArray(
      array $shape,
    ): array {
      return $shape;
    }
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.soapfault.php )
 *
 * Represents a SOAP fault.
 *
 */
class SoapFault extends Exception {
  public $faultcode;
  public $faultcodens;
  public $faultstring;
  public $faultactor;
  public $detail;
  public $_name;
  public $headerfault;

  public function __construct($code, $message, $actor = null, $detail = null,
                              $name = null, $header = null) {
    $fault_ns = null;
    $fault_code = null;
    if (is_string($code)) {
      $fault_code = $code;
    } else if (is_array($code) && count($code) == 2) {
      $code = array_values($code);
      $fault_ns = $code[0];
      $fault_code = $code[1];
      if (!is_string($fault_ns) || !is_string($fault_code)) {
        hphp_throw_fatal_error("Invalid fault code"); 
        return;
      }
    } else  {
      hphp_throw_fatal_error("Invalid fault code"); 
      return;
    }
    $this->faultcodens = $fault_ns;
    $this->faultcode = $fault_code;
    if (empty($this->faultcode)) {
      hphp_throw_fatal_error("Invalid fault code"); 
      return;
    }

    $this->faultstring = $this->message = $message;
    $this->faultactor = $actor;
    $this->detail = $detail;
    $this->_name = $name;
    $this->headerfault = $header;

    $SOAP_1_1 = 1;
    $SOAP_1_2 = 2;
    $SOAP_1_1_ENV_NAMESPACE = 'http://schemas.xmlsoap.org/soap/envelope/';
    $SOAP_1_2_ENV_NAMESPACE = 'http://www.w3.org/2003/05/soap-envelope';

    $soap_version = _soap_active_version();
    if (empty($this->faultcodens)) {
      if ($soap_version == $SOAP_1_1) {
        if ($this->faultcode == "Client" ||
            $this->faultcode == "Server" ||
            $this->faultcode == "VersionMismatch" ||
            $this->faultcode == "MustUnderstand") {
          $this->faultcodens = $SOAP_1_1_ENV_NAMESPACE;
        }
      } else if ($soap_version == $SOAP_1_2) {
        if ($this->faultcode == "Client") {
          $this->faultcode = "Sender";
          $this->faultcodens = $SOAP_1_2_ENV_NAMESPACE;
        } else if ($this->faultcode == "Server") {
          $this->faultcode = "Receiver";
          $this->faultcodens = $SOAP_1_2_ENV_NAMESPACE;
        } else if ($this->faultcode == "VersionMismatch" ||
                   $this->faultcode == "MustUnderstand" ||
                   $this->faultcode == "DataEncodingUnknown") {
          $this->faultcodens = $SOAP_1_2_ENV_NAMESPACE;
        }
      }
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/soapfault.tostring.php )
   *
   * Returns a string representation of the SoapFault.
   *
   * @return     mixed   A string describing the SoapFault.
   */
  public function __toString() {
    return "SoapFault exception: [" . $this->faultcode . "] " .
           $this->faultstring;
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.splfixedarray.php )
 *
 * The SplFixedArray class provides the main functionalities of array. The
 * main differences between a SplFixedArray and a normal PHP array is that
 * the SplFixedArray is of fixed length and allows only integers within the
 * range as indexes. The advantage is that it allows a faster array
 * implementation.
 *
 */
class SplFixedArray implements \HH\Iterator, ArrayAccess, Countable {

  protected $data = array();

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.construct.php )
   *
   * Initializes a fixed array with a number of NULL values equal to size.
   *
   * @size       mixed   The size of the fixed array. This expects a number
   *                     between 0 and PHP_INT_MAX.
   *
   * @return     mixed   No value is returned.
   */
  public function __construct($size = 0) {
    $this->setSize($size);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.current.php )
   *
   * Get the current array element.
   *
   * @return     mixed   The current element value.
   */
  public function current() {
    return current($this->data);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.key.php )
   *
   * Returns the current array index.
   *
   * @return     mixed   The current array index.
   */
  public function key() {
    return key($this->data);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.next.php )
   *
   * Move the iterator to the next array entry.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    next($this->data);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.rewind.php )
   *
   * Rewinds the iterator to the beginning.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    reset($this->data);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.valid.php )
   *
   * Checks if the array contains any more elements.
   *
   * @return     mixed   Returns TRUE if the array contains any more
   *                     elements, FALSE otherwise.
   */
  public function valid() {
    return key($this->data) !== NULL;
  }


  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.offsetexists.php )
   *
   * Checks whether the requested index index exists.
   *
   * @index      mixed   The index being checked.
   *
   * @return     mixed   TRUE if the requested index exists, otherwise FALSE
   */
  public function offsetExists($index) {
    if (!is_numeric($index)) {
      throw new RuntimeException("Index invalid or out of range");
    }
    if ($index < 0) {
      return false;
    }
    return $index < count($this->data);
  }

  private function validateIndex($index) {
    if (!is_numeric($index) ||
        $index >= count($this->data) || $index < 0) {
      throw new RuntimeException("Index invalid or out of range");
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.offsetget.php )
   *
   * Returns the value at the index index.
   *
   * @index      mixed   The index with the value.
   *
   * @return     mixed   The value at the specified index.
   */
  public function offsetGet($index) {
    $this->validateIndex($index);
    return $this->data[$index];
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.offsetset.php )
   *
   * Sets the value at the specified index to newval.
   *
   * @index      mixed   The index being set.
   * @newval     mixed   The new value for the index.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetSet($index, $newval) {
    $this->validateIndex($index);
    $this->data[$index] = $newval;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.offsetunset.php )
   *
   * Unsets the value at the specified index.
   *
   * @index      mixed   The index being unset.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetUnset($index) {
    $this->offsetSet($index, null);
  }


  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.count.php )
   *
   * Returns the size of the array.
   *
   * @return     mixed   Returns the size of the array.
   */
  public function count() {
    return count($this->data);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.setsize.php )
   *
   * Change the size of an array to the new size of size. If size is less
   * than the current array size, any values after the new size will be
   * discarded. If size is greater than the current array size, the array
   * will be padded with NULL values.
   *
   * @size       mixed   The new array size. This should be a value between 0
   *                     and PHP_INT_MAX.
   *
   * @return     mixed   No value is returned.
   */
  public function setSize($size) {
    if (is_bool($size) || is_float($size) || $size === null) {
      $size = (int) $size;
    }
    if (!is_numeric($size)) {
      trigger_error(
        sprintf("SplFixedArray::setSize() expects parameter 1 to be long,".
                " %s given", gettype($size)
               ),
        E_WARNING);
      return;
    }
    if ($size < 0) {
      throw new Exception('array size cannot be less than zero');
    }
    if ($size < count($this->data)) {
      $this->data = array_slice($this->data, 0, $size);
    } else if ($size > count($this->data)) {
      $this->data = array_pad($this->data, $size, null);
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.getsize.php )
   *
   * Gets the size of the array.
   *
   * @return     mixed   Returns the size of the array, as an integer.
   */
  public function getSize() {
    return count($this->data);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.toarray.php )
   *
   * Returns a PHP array from the fixed array.
   *
   * @return     mixed   Returns a PHP array, similar to the fixed array.
   */
  public function toArray() {
    return $this->data;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splfixedarray.fromarray.php )
   *
   * Import the PHP array array in a new SplFixedArray instance
   *
   * @array      mixed   The array to import.
   * @save_indexes
   *             mixed   Try to save the numeric indexes used in the original
   *                     array.
   *
   * @return     mixed   Returns an instance of SplFixedArray containing the
   *                     array content.
   */
  public static function fromArray($array, $save_indexes = true) {
    $fixed_array = new self;
    if (!is_array($array)) {
      trigger_error(
        sprintf("SplFixedArray::fromArray() expects parameter 1 to be array,".
                " %s given", gettype($array)),
        E_WARNING);
      return $fixed_array;
    }
    if ($save_indexes) {
      $fixed_array->setSize(max(array_keys($array)) + 1);
      foreach ($array as $key => $value) {
        if (!is_numeric($key) || $key < 0) {
          throw new InvalidArgumentException(
            'array must contain only positive integer keys'
          );
        }
        $fixed_array[$key] = $value;
      }
    } else {
      $fixed_array->data = array_values($array);
    }
    return $fixed_array;
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.splobjectstorage.php )
 *
 * The SplObjectStorage class provides a map from objects to data or, by
 * ignoring data, an object set. This dual purpose can be useful in many
 * cases involving the need to uniquely identify objects.
 *
 */
class SplObjectStorage
  implements \HH\Iterator, Countable, Serializable, ArrayAccess {

  private $__storage = array();
  private $__key = 0;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.rewind.php )
   *
   * Rewind the iterator to the first storage element.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    reset($this->__storage);
    $this->__key = 0;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.valid.php )
   *
   * Returns if the current iterator entry is valid.
   *
   * @return     mixed   Returns TRUE if the iterator entry is valid, FALSE
   *                     otherwise.
   */
  public function valid() {
    return key($this->__storage) !== NULL;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.key.php )
   *
   * Returns the index at which the iterator currently is.
   *
   * @return     mixed   The index corresponding to the position of the
   *                     iterator.
   */
  public function key() {
    return $this->__key;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.current.php )
   *
   * Returns the current storage entry.
   *
   * @return     mixed   The object at the current iterator position.
   */
  public function current() {
    return current($this->__storage)['obj'];
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.next.php )
   *
   * Moves the iterator to the next object in the storage.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    next($this->__storage);
    $this->__key++;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.count.php )
   *
   * Counts the number of objects in the storage.
   *
   * @return     mixed   The number of objects in the storage.
   */
  public function count() {
    return count($this->__storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.contains.php )
   *
   * Checks if the storage contains the object provided.
   *
   * @obj        mixed   The object to look for.
   *
   * @return     mixed   Returns TRUE if the object is in the storage, FALSE
   *                     otherwise.
   */
  public function contains($obj) {
    if (gettype($obj) === 'object') {
      return isset($this->__storage[$this->getHashAndValidate($obj)]);
    }
    return false;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.attach.php )
   *
   * Adds an object inside the storage, and optionally associate it to some
   * data.
   *
   * @obj        mixed   The object to add.
   * @data       mixed   The data to associate with the object.
   *
   * @return     mixed   No value is returned.
   */
  public function attach($obj, $data = null) {
    if (gettype($obj) === 'object') {
      $this->__storage[$this->getHashAndValidate($obj)] = array(
        'obj' => $obj, 'inf' => $data
      );
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.detach.php )
   *
   * Removes the object from the storage.
   *
   * @obj        mixed   The object to remove.
   *
   * @return     mixed   No value is returned.
   */
  public function detach($obj) {
    if (gettype($obj) === 'object') {
      unset($this->__storage[$this->getHashAndValidate($obj)]);
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/splobjectstorage.offsetexists.php )
   *
   * Checks whether an object exists in the storage.
   *
   * SplObjectStorage::offsetExists() is an alias of
   * SplObjectStorage::contains().
   *
   * @object     mixed   The object to look for.
   *
   * @return     mixed   Returns TRUE if the object exists in the storage,
   *                     and FALSE otherwise.
   */
  public function offsetExists($object) {
    return $this->contains($object);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.offsetget.php )
   *
   * Returns the data associated with an object in the storage.
   *
   * @object     mixed   The object to look for.
   *
   * @return     mixed   The data previously associated with the object in
   *                     the storage.
   */
  public function offsetGet($object) {
    if (gettype($object) === 'object') {
      if (!$this->contains($object)) {
        throw new UnexpectedValueException('Object not found');
      }
      return $this->__storage[$this->getHashAndValidate($object)]['inf'];
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.offsetset.php )
   *
   * Associate data to an object in the storage.
   *
   * SplObjectStorage::offsetSet() is an alias of
   * SplObjectStorage::attach().
   *
   * @object     mixed   The object to associate data with.
   * @data       mixed   The data to associate with the object.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetSet($object, $data = null) {
    return $this->attach($object, $data);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.offsetunset.php
   * )
   *
   * Removes an object from the storage.
   *
   * SplObjectStorage::offsetUnset() is an alias of
   * SplObjectStorage::detach().
   *
   * @object     mixed   The object to remove.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetUnset($object) {
    return $this->detach($object);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.removeall.php )
   *
   * Removes objects contained in another storage from the current storage.
   *
   * @storage    mixed   The storage containing the elements to remove.
   *
   * @return     mixed   No value is returned.
   */
  public function removeAll($storage) {
    $cache = array();
    foreach ($storage as $obj) {
      $cache[] = $obj;
    }
    foreach ($cache as $obj) {
      $this->detach($obj);
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/splobjectstorage.removeallexcept.php )
   *
   * Removes all objects except for those contained in another storage from
   * the current storage.
   *
   * @storage    mixed   The storage containing the elements to retain in the
   *                     current storage.
   *
   * @return     mixed   No value is returned.
   */
  public function removeAllExcept($storage) {
    $cache = array();
    foreach ($this->__storage as $object) {
      if (!$storage->contains($object['obj'])) {
        $cache[] = $object['obj'];
      }
    }
    foreach ($cache as $object) {
      $this->detach($object);
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.addall.php )
   *
   * Adds all objects-data pairs from a different storage in the current
   * storage.
   *
   * @storage    mixed   The storage you want to import.
   *
   * @return     mixed   No value is returned.
   */
  public function addAll($storage) {
    foreach ($storage as $object) {
      $this->attach($object);
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.gethash.php )
   *
   * This method calculates an identifier for the objects added to an
   * SplObjectStorage object.
   *
   * The implementation in SplObjectStorage returns the same value as
   * spl_object_hash().
   *
   * The storage object will never contain more than one object with the
   * same identifier. As such, it can be used to implement a set (a
   * collection of unique values) where the quality of an object being unique
   * is determined by the value returned by this function being unique.
   *
   * @object     mixed   The object whose identifier is to be calculated.
   *
   * @return     mixed   A string with the calculated identifier.
   */
  public function getHash($object) {
    return spl_object_hash($object);
  }

  private function getHashAndValidate($object) {
    $hash = $this->getHash($object);
    if (!is_string($hash)) {
      throw new RuntimeException('Hash needs to be a string');
    }
    return $hash;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.serialize.php )
   *
   * Returns a string representation of the storage.
   *
   * @return     mixed   A string representing the storage.
   */
  public function serialize() {
    return serialize($this->__storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.unserialize.php
   * )
   *
   * Unserializes storage entries and attach them to the current storage.
   *
   * @serialized mixed   The serialized representation of a storage.
   *
   * @return     mixed   No value is returned.
   */
  public function unserialize($serialized) {
    $arr = @unserialize($serialized);

    // check for error while unserializing.
    // we need to differentiate serialized(false) and false returned because of
    // a bad string
    if ($arr === false && serialize(false) !== $serialized) {
        throw new UnexpectedValueException('Error while unserializing');
    }

    if (is_array($arr)) {
      $this->__storage = $arr;
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.setinfo.php )
   *
   * Associates data, or info, with the object currently pointed to by the
   * iterator.
   *
   * @data       mixed   The data to associate with the current iterator
   *                     entry.
   *
   * @return     mixed   No value is returned.
   */
  public function setInfo($data) {
    current($this->__storage)['inf'] = $data;;
  }


  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobjectstorage.getinfo.php )
   *
   * Returns the data associated with the current iterator entry.
   *
   * @return     mixed   Returns the data, or info, associated with the
   *                     object pointed by the current iterator position.
   */
  public function getInfo() {
    return current($this->__storage)['inf'];
  }
}
}

namespace {

class _SplPriorityQueueHeap extends SplMaxHeap {

  private $priorityQueue;

  public function __construct(SplPriorityQueue $priority_queue) {
    $this->priorityQueue = $priority_queue;
  }

  public function copy(SplPriorityQueue $priority_queue) {
    $clonedHeap = clone $this;
    $clonedHeap->priorityQueue = $priority_queue;
    return $clonedHeap;
  }

  public function compare($a, $b) {
    return $this->priorityQueue->compare($a['priority'], $b['priority']);
  }

  public function top() {
    // I know that the parent routes all requests through top()
    // so this is the only method I need to change.
    $result = parent::top();
    $flags = $this->priorityQueue->getExtractFlags();
    if (($flags & SplPriorityQueue::EXTR_BOTH) == SplPriorityQueue::EXTR_BOTH) {
      return $result;
    } else if ($flags & SplPriorityQueue::EXTR_DATA) {
      return $result['data'];
    } else if ($flags & SplPriorityQueue::EXTR_PRIORITY) {
      return $result['priority'];
    }
    // really zend? NULL?
    return null;
  }
}

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.splpriorityqueue.php )
 *
 * The SplPriorityQueue class provides the main functionalities of an
 * prioritized queue, implemented using a max heap.
 *
 */
class SplPriorityQueue implements \HH\Iterator, Countable {

  const EXTR_DATA = 1;
  const EXTR_PRIORITY = 2;
  const EXTR_BOTH = 3;

  private $flags = self::EXTR_DATA;
  private $heap;

  final private function getHeap() {
    if ($this->heap === null) {
      $this->heap = new _SplPriorityQueueHeap($this);
    }
    return $this->heap;
  }


  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splpriorityqueue.compare.php )
   *
   * Compare priority1 with priority2.
   *
   * @priority1  mixed   The priority of the first node being compared.
   * @priority2  mixed   The priority of the second node being compared.
   *
   * @return     mixed   Result of the comparison, positive integer if
   *                     priority1 is greater than priority2, 0 if they are
   *                     equal, negative integer otherwise.
   *
   *                     Multiple elements with the same priority will get
   *                     dequeued in no particular order.
   */
  public function compare($priority1, $priority2) {
    if ($priority1 > $priority2) {
      return 1;
    } else if ($priority1 < $priority2) {
      return -1;
    }
    return 0;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splpriorityqueue.extract.php )
   *
   *
   * @return     mixed   The value or priority (or both) of the extracted
   *                     node, depending on the extract flag.
   */
  public function extract() {
    return $this->getHeap()->extract();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splpriorityqueue.insert.php )
   *
   * Insert value with the priority priority in the queue.
   *
   * @value      mixed   The value to insert.
   * @priority   mixed   The associated priority.
   *
   * @return     mixed   No value is returned.
   */
  public function insert($value, $priority) {
    $data = array('data' => $value, 'priority' => $priority);
    return $this->getHeap()->insert($data);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splpriorityqueue.isempty.php )
   *
   *
   * @return     mixed   Returns whether the queue is empty.
   */
  public function isEmpty() {
    return $this->getHeap()->isEmpty();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/splpriorityqueue.recoverfromcorruption.php )
   *
   *
   * @return     mixed   No value is returned.
   */
  public function recoverFromCorruption() {
    return $this->getHeap()->recoverFromCorruption();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splpriorityqueue.count.php )
   *
   *
   * @return     mixed   Returns the number of elements in the queue.
   */
  public function count() {
    return $this->getHeap()->count();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splpriorityqueue.current.php )
   *
   * Get the current datastructure node.
   *
   * @return     mixed   The value or priority (or both) of the current node,
   *                     depending on the extract flag.
   */
  public function current() {
    return $this->getHeap()->current();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splpriorityqueue.key.php )
   *
   * This function returns the current node index
   *
   * @return     mixed   The current node index.
   */
  public function key() {
    return $this->getHeap()->key();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splpriorityqueue.next.php )
   *
   * Extracts the top node from the queue.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    return $this->getHeap()->next();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splpriorityqueue.rewind.php )
   *
   * This rewinds the iterator to the beginning. This is a no-op for heaps
   * as the iterator is virtual and in fact never moves from the top of the
   * heap.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    return $this->getHeap()->rewind();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splpriorityqueue.top.php )
   *
   *
   * @return     mixed   The value or priority (or both) of the top node,
   *                     depending on the extract flag.
   */
  public function top() {
    return $this->getHeap()->top();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splpriorityqueue.valid.php )
   *
   * Checks if the queue contains any more nodes.
   *
   * @return     mixed   Returns TRUE if the queue contains any more nodes,
   *                     FALSE otherwise.
   */
  public function valid() {
    return $this->getHeap()->valid();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/splpriorityqueue.setextractflags.php )
   *
   *
   * @flags      mixed   Defines what is extracted by
   *                     SplPriorityQueue::current(), SplPriorityQueue::top()
   *                     and SplPriorityQueue::extract().
   *                     SplPriorityQueue::EXTR_DATA (0x00000001): Extract
   *                     the data SplPriorityQueue::EXTR_PRIORITY
   *                     (0x00000002): Extract the priority
   *                     SplPriorityQueue::EXTR_BOTH (0x00000003): Extract an
   *                     array containing both
   *
   *                     The default mode is SplPriorityQueue::EXTR_DATA.
   *
   * @return     mixed   No value is returned.
   */
  public function setExtractFlags($flags) {
     $this->flags = $flags;
  }

  public function getExtractFlags() {
     return $this->flags;
  }

  public function __clone() {
    $this->heap = $this->heap ? $this->heap->copy($this) : null;
  }

}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.splobserver.php )
 *
 * The SplObserver interface is used alongside SplSubject to implement the
 * Observer Design Pattern.
 *
 */
interface SplObserver {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splobserver.update.php )
   *
   * This method is called when any SplSubject to which the observer is
   * attached calls SplSubject::notify(). Warning: This function is currently
   * not documented; only its argument list is available.
   *
   * @subject    mixed   The SplSubject notifying the observer of an update.
   *
   * @return     mixed   No value is returned.
   */
  public function update ( SplSubject $subject );
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.splsubject.php )
 *
 * The SplSubject interface is used alongside SplObserver to implement the
 * Observer Design Pattern.
 *
 */
interface SplSubject {
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splsubject.attach.php )
   *
   * Attaches an SplObserver so that it can be notified of updates. Warning:
   * This function is currently not documented; only its argument list is
   * available.
   *
   * @observer   mixed   The SplObserver to attach.
   *
   * @return     mixed   No value is returned.
   */
  public function attach(SplObserver $observer);
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splsubject.detach.php )
   *
   * Detaches an observer from the subject to no longer notify it of
   * updates. Warning: This function is currently not documented; only its
   * argument list is available.
   *
   * @observer   mixed   The SplObserver to detach.
   *
   * @return     mixed   No value is returned.
   */
  public function detach(SplObserver $observer);
  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/splsubject.notify.php )
   *
   * Notifies all attached observers. Warning: This function is currently
   * not documented; only its argument list is available.
   *
   * @return     mixed   No value is returned.
   */
  public function notify();
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.emptyiterator.php )
 *
 * The EmptyIterator class for an empty iterator.
 *
 */
class EmptyIterator implements \HH\Iterator {

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/emptyiterator.current.php )
   *
   * This function must not be called. It throws an exception upon access.
   * Warning: This function is currently not documented; only its argument
   * list is available.
   *
   * @return     mixed   No value is returned.
   */
  public function current() {
    throw new BadMethodCallException(
      "Accessing the value of an EmptyIterator");
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/emptyiterator.key.php )
   *
   * This function must not be called. It throws an exception upon access.
   * Warning: This function is currently not documented; only its argument
   * list is available.
   *
   * @return     mixed   No value is returned.
   */
  public function key() {
    throw new BadMethodCallException(
      "Accessing the key of an EmptyIterator");
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/emptyiterator.next.php )
   *
   * No operation, nothing to do. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {}

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/emptyiterator.rewind.php )
   *
   * No operation, nothing to do. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {}

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/emptyiterator.valid.php )
   *
   * The EmptyIterator valid() method. Warning: This function is currently
   * not documented; only its argument list is available.
   *
   * @return     mixed   FALSE
   */
  public function valid() {
    return false;
  }

}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.infiniteiterator.php )
 *
 * The InfiniteIterator allows one to infinitely iterate over an iterator
 * without having to manually rewind the iterator upon reaching its end.
 *
 */
class InfiniteIterator extends IteratorIterator implements OuterIterator {

  private $valid;

  public function rewind() {
    $iter = $this->getInnerIterator();
    $this->_setPosition(0);
    $iter->rewind();
    $this->valid = $this->_fetch(true);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/infiniteiterator.next.php )
   *
   * Moves the inner Iterator forward to its next element if there is one,
   * otherwise rewinds the inner Iterator back to the beginning.
   *
   * Even an InfiniteIterator stops if its inner Iterator is empty.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    $iter = $this->getInnerIterator();
    $this->_setPosition($this->_getPosition() + 1);
    $iter->next();
    if ($iter->valid()) {
      $this->valid = $this->_fetch(false);
    } else {
      $this->_setPosition(0);
      $iter->rewind();
      if ($iter->valid()) {
        $this->valid = $this->_fetch(false);
      }
    }
  }

  public function valid() {
    return $this->valid;
  }

}

}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.limititerator.php )
 *
 * The LimitIterator class allows iteration over a limited subset of items
 * in an Iterator.
 *
 */
class LimitIterator extends IteratorIterator implements OuterIterator {

  private $offset;
  private $count;
  private $valid;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/limititerator.construct.php )
   *
   * Constructs a new LimitIterator from an iterator with a given starting
   * offset and maximum count.
   *
   * @iterator   mixed   The Iterator to limit.
   * @offset     mixed   Optional offset of the limit.
   * @count      mixed   Optional count of the limit.
   *
   * @return     mixed   The new LimitIterator.
   */
  public function __construct($iterator, $offset = 0, $count = -1) {
    if ($offset < 0) {
      throw new OutOfRangeException(
        "Parameter offset must be >= 0");
    } else if ($count < -1) {
      throw new OutOfRangeException(
        "Parameter count must either be -1 or ".
        "a value greater than or equal 0");
    }
    parent::__construct($iterator);
    $this->offset = $offset;
    $this->count = $count;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/limititerator.getposition.php )
   *
   * Gets the current zero-based position of the inner Iterator.
   *
   * @return     mixed   The current position.
   */
  public function getPosition() {
    return $this->_getPosition();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/limititerator.rewind.php )
   *
   * Rewinds the iterator to the starting offset specified in
   * LimitIterator::__construct().
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    $this->getInnerIterator()->rewind();
    $this->_setPosition(0);
    $this->seek($this->offset);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/limititerator.next.php )
   *
   * Moves the iterator forward.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    $this->getInnerIterator()->next();
    $this->_setPosition($this->_getPosition() + 1);
    if ($this->count == -1 ||
        $this->_getPosition() < $this->offset + $this->count) {
      $this->valid = $this->_fetch(true);
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/limititerator.seek.php )
   *
   * Moves the iterator to the offset specified by position.
   *
   * @position   mixed   The position to seek to.
   *
   * @return     mixed   Returns the offset position after seeking.
   */
  public function seek($position) {
    // Bounds checking
    if ($position < $this->offset) {
      throw new OutOfBoundsException(
        "Cannot seek to ".$position.
        " which is below the offset ".$this->offset);
    } else if ($this->count != -1 &&
               $position >= $this->offset + $this->count) {
      throw new OutOfBoundsException(
        "Cannot seek to ".$position.
        " which is behind offset ".$this->offset.
        " plus count ".$this->count);
    }

    $iter = $this->getInnerIterator();
    if ($this->_getPosition() != $position &&
        $iter instanceof SeekableIterator) {
      // We can use the underlying seek implementation.
      $iter->seek($position);
      $this->_setPosition($position);
      if (($this->count == -1 ||
           $this->_getPosition() < $this->offset + $this->count) &&
           $iter->valid()) {
        $this->valid = $this->_fetch(false);
      }
    } else {
      // We need to simulate the seek using rewind() and next().
      // Backwards seeking is done using rewind() first.
      if ($this->_getPosition() > $position) {
        $iter->rewind();
        $this->_setPosition(0);
      }
      // We can seek forwards using next().
      while ($this->_getPosition() < $position && $iter->valid()) {
        /*
         * Note that we're basically reimplementing next() here.
         * This is because the SPL implementation does not fetch
         * when it's walking the iterator - it only fetches when
         * it reaches the right position. This also accounts for
         * why we update _position manually (and similarly, why
         * we set it manually to 0 in the block above).
         */
        $iter->next();
        $this->_setPosition($this->_getPosition() + 1);
      }
      // Fetch.
      if ($iter->valid()) {
        $this->valid = $this->_fetch(true);
      }
    }
    return $this->_getPosition();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/limititerator.valid.php )
   *
   * Checks whether the current element is valid.
   *
   * @return     mixed   Returns TRUE on success or FALSE on failure.
   */
  public function valid() {
    return ($this->count == -1 ||
            $this->_getPosition() < $this->offset + $this->count) &&
            $this->valid;
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.norewinditerator.php )
 *
 * This iterator cannot be rewound.
 *
 */
class NoRewindIterator extends IteratorIterator {

  private $current;
  private $key;
  private $needsRefresh;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/norewinditerator.construct.php )
   *
   * Constructs a NoRewindIterator.
   *
   * @iterator   mixed   The iterator being used.
   *
   * @return     mixed   A NoRewindIterator() based on the passed in
   *                     iterator.
   */
  public function __construct($iterator) {
    parent::__construct($iterator);
    $this->needsRefresh = true;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/norewinditerator.current.php )
   *
   * Gets the current value. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   The current value.
   */
  public function current() {
    if ($this->needsRefresh) {
      $this->current = $this->getInnerIterator()->current();
    }
    $this->needsRefresh = false;
    return $this->current;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/norewinditerator.key.php )
   *
   * Gets the current key. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   The current key.
   */
  public function key() {
    return $this->getInnerIterator()->key();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/norewinditerator.rewind.php )
   *
   * Prevents the rewind operation on the inner iterator.
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/norewinditerator.next.php )
   *
   * Forwards to the next element. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    $this->getInnerIterator()->next();
    $this->needsRefresh = true;
  }

}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://docs.hhvm.com/manual/en/class.recursiveiteratoriterator.php )
 *
 * Can be used to iterate through recursive iterators.
 *
 */
class RecursiveIteratorIterator implements OuterIterator {

  const LEAVES_ONLY = 0;
  const SELF_FIRST = 1;
  const CHILD_FIRST = 2;
  const CATCH_GET_CHILD = 16;

  const STATE_NEXT = 10;
  const STATE_TEST = 11;
  const STATE_SELF = 12;
  const STATE_CHILD = 13;
  const STATE_START = 14;

  const NEXT_COMPLETE = 10;
  const NEXT_REPEAT = 11;

  private $iterators = array();
  private $originalIterator;
  private $mode;
  private $flags;
  private $maxDepth = -1;

  // Flag for checking whether to call
  // begin/endIteration() or not
  private $inIteration = false;

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveiteratoriterator.construct.php )
   *
   * Creates a RecursiveIteratorIterator from a RecursiveIterator.
   *
   * @iterator   mixed   The iterator being constructed from. Either a
   *                     RecursiveIterator or IteratorAggregate.
   * @mode       mixed   Optional mode. Possible values are
   *                     RecursiveIteratorIterator::LEAVES_ONLY - The
   *                     default. Lists only leaves in iteration.
   *                     RecursiveIteratorIterator::SELF_FIRST - Lists leaves
   *                     and parents in iteration with parents coming first.
   *                     RecursiveIteratorIterator::CHILD_FIRST - Lists
   *                     leaves and parents in iteration with leaves coming
   *                     first.
   * @flags      mixed   Optional flag. Possible values are
   *                     RecursiveIteratorIterator::CATCH_GET_CHILD which
   *                     will then ignore exceptions thrown in calls to
   *                     RecursiveIteratorIterator::getChildren().
   *
   * @return     mixed   No value is returned.
   */
  public function __construct(\Traversable $iterator,
                              $mode = RecursiveIteratorIterator::LEAVES_ONLY,
                              $flags = 0) {
    if ($iterator && ($iterator instanceof IteratorAggregate)) {
      $iterator = $iterator->getIterator();
    }
    if (!$iterator || !($iterator instanceof RecursiveIterator)) {
      throw new InvalidArgumentException(
        "An instance of RecursiveIterator or IteratorAggregate creating " .
        "it is required"
      );
    }
    $this->iterators[] = array($iterator, self::STATE_START);
    $this->originalIterator = $iterator;
    $this->mode = (int) $mode;
    $this->flags = $flags;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveiteratoriterator.getinneriterator.php
   * )
   *
   * Gets the current active sub iterator. Warning: This function is
   * currently not documented; only its argument list is available.
   *
   * @return     mixed   The current active sub iterator.
   */
  public function getInnerIterator() {
    $it = $this->iterators[count($this->iterators)-1][0];
    if (!$it instanceof RecursiveIterator) {
      throw new Exception(
        "inner iterator must implement RecursiveIterator"
      );
    }
    return $it;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveiteratoriterator.current.php )
   *
   *
   * @return     mixed   The current elements value.
   */
  public function current() {
    return $this->getInnerIterator()->current();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveiteratoriterator.key.php )
   *
   *
   * @return     mixed   The current key.
   */
  public function key() {
    return $this->getInnerIterator()->key();
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveiteratoriterator.next.php )
   *
   *
   * @return     mixed   No value is returned.
   */
  public function next() {
    $this->nextImpl();
  }

  private function nextImpl() {
    while ($this->nextInnerImpl() === self::NEXT_REPEAT) {
      /* loop */
    }
  }

  /* We maintain a stack of sub-iterators - each of which has a state.
   *
   * This walks the overall tree for one step, and updates the corresponding
   * iterator states as needed (current iterator, parent iterator, child
   * iterator).
   *
   * Returns self::NEXT_COMPLETE if that one step got us to the next position
   *   (this changes depending on LEAVES_ONLY, SELF_FIRST, and CHILD_FIRST), or
   *   SELF::NEXT_REPEAT if more steps are needed.
   */
  private function nextInnerImpl() {
    $it = $this->getInnerIterator();
    switch ($this->getInnerIteratorState()) {
      case self::STATE_NEXT:
        $it->next();
        // fallthrough
      case self::STATE_START:
        if (!$it->valid()) {
          if ($this->getDepth() > 0) {
            $this->endChildren();
            array_pop($this->iterators);
            return self::NEXT_REPEAT;
          }
          return self::NEXT_COMPLETE;
        }
        $this->setInnerIteratorState(self::STATE_TEST);
        return self::NEXT_REPEAT;
      case self::STATE_TEST:
        if ($this->callHasChildren()) {
          if ($this->maxDepth == -1 || $this->maxDepth > $this->getDepth()) {
            switch ($this->mode) {
              case self::LEAVES_ONLY:
              case self::CHILD_FIRST:
                // We never look at SELF in LEAVES_ONLY
                $this->setInnerIteratorState(self::STATE_CHILD);
                return self::NEXT_REPEAT;
              case self::SELF_FIRST:
                $this->setInnerIteratorState(self::STATE_SELF);
                return self::NEXT_REPEAT;
            }
          } else if ($this->mode == self::LEAVES_ONLY) {
            // We're already at the recursion limit, and the current node isn't
            // a leaf
            $this->setInnerIteratorState(self::STATE_NEXT);
            return self::NEXT_REPEAT;
          }
        }
        $this->nextElement();
        $this->setInnerIteratorState(self::STATE_NEXT);
        return self::NEXT_COMPLETE;
      case self::STATE_SELF:
        $this->nextElement();
        if ($this->mode == self::SELF_FIRST) {
          $this->setInnerIteratorState(self::STATE_CHILD);
        } else {
          $this->setInnerIteratorState(self::STATE_NEXT);
        }
        return self::NEXT_COMPLETE;
      case self::STATE_CHILD:
        $children = $this->callGetChildren();
        if (!$children instanceof RecursiveIterator) {
          throw new UnexpectedValueException(
            'Objects returned by RecursiveIterator::getChildren() must '.
            'implement RecursiveIterator'
          );
        }
        if ($this->mode == self::CHILD_FIRST) {
          $this->setInnerIteratorState(self::STATE_SELF);
        } else {
          $this->setInnerIteratorState(self::STATE_NEXT);
        }
        $children->rewind();
        $this->iterators[] = array($children, self::STATE_START);
        $this->beginChildren();
        return self::NEXT_REPEAT;
    }
    throw new Exception("unreachable");
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveiteratoriterator.rewind.php )
   *
   *
   * @return     mixed   No value is returned.
   */
  public function rewind() {
    while ($this->iterators) {
      array_pop($this->iterators);
    }

    $it = $this->originalIterator;
    $this->iterators = array(array($it, self::STATE_START));
    $it->rewind();
    if (!$this->inIteration) {
      $this->beginIteration();
    }

    $this->nextImpl();
    $this->inIteration = true;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from
   * http://docs.hhvm.com/manual/en/recursiveiteratoriterator.valid.php )
   *
   *
   * @return     mixed   TRUE if the current position is valid, otherwise
   *                     FALSE
   */
  public function valid() {
    $depth = $this->getDepth();
    while ($depth >= 0) {
      if ($this->getSubIterator($depth)->valid()) {
        return true;
      }
      $depth--;
    }
    if ($this->inIteration) {
      $this->endIteration();
    }
    $this->inIteration = false;
    return false;
  }

  /**
   * Called after calling getChildren(), and its associated rewind().
   */
  public function beginChildren()
  {
  }

  /**
   * Called when iteration begins (after the first rewind() call).
   */
  public function beginIteration()
  {
  }

  /**
   * Get children of the current element.
   *
   * @return     RecursiveIterator
   */
  public function callGetChildren()
  {
    return $this->getInnerIterator()->getChildren();
  }

  /**
   * Called for each element to test whether it has children.
   *
   * @return     bool
   */
  public function callHasChildren()
  {
    return $this->getInnerIterator()->hasChildren();
  }

  /**
   * Called when end recursing one level.
   */
  public function endChildren()
  {
  }

  /**
   * Called when the iteration ends (when valid() first returns FALSE).
   */
  public function endIteration()
  {
  }

  /**
   * Get the current depth of the recursive iteration.
   *
   * @return     int     The current depth of the recursive iteration.
   */
  public function getDepth()
  {
    return count($this->iterators)-1;
  }

  /**
   * Gets the maximum allowable depth.
   *
   * @return     int     The maximum accepted depth, or FALSE if any depth is
   *                     allowed.
   */
  public function getMaxDepth()
  {
    return ($this->maxDepth == -1) ? false : $this->maxDepth;
  }

  /**
   * Gets the current active sub iterator.
   *
   * @param      int     $level
   *
   * @return     RecursiveIterator   The current active sub iterator.
   */
  public function getSubIterator($level = null)
  {
    $currentLevel = count($this->iterators)-1;
    if (is_null($level)) {
      $level = $currentLevel;
    }
    if ($level < 0 || $level > $currentLevel) {
      return null;
    }
    return $this->iterators[$level][0];
  }

  /**
   * Called when the next element is available.
   */
  public function nextElement()
  {
  }

  /**
   * Set the maximum allowed depth.
   *
   * @param      int     $max_depth   The maximum allowed depth. -1 is used for
   *                                  any depth.
   *
   * @throws     Exception            Emits an Exception if max_depth is less
   *                                  than -1.
   */
  public function setMaxDepth($max_depth = -1)
  {
    if ($max_depth < -1) {
      throw new OutOfRangeException("Parameter max_depth must be >= -1");
    }

    $this->maxDepth = $max_depth;
  }

  private function isEmpty() {
    return count($this->iterators) == 0;
  }

  private function getInnerIteratorState() {
    return $this->iterators[count($this->iterators)-1][1];
  }

  private function setInnerIteratorState($state) {
    $this->iterators[count($this->iterators)-1][1] = $state;
  }

  /**
   * Undocumented behavior but Zend does it and frameworks rely on it, so..
   */
  public function __call($func, $params) {
    return call_user_func_array(
      array($this->getInnerIterator(), $func),
      $params
    );
  }
}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.recursivetreeiterator.php
 * )
 *
 * Allows iterating over a RecursiveIterator to generate an ASCII graphic
 * tree.
 *
 */
class RecursiveTreeIterator extends RecursiveIteratorIterator
  implements OuterIterator {

  const int BYPASS_CURRENT = 4;
  const int BYPASS_KEY = 8;
  const int PREFIX_LEFT = 0;
  const int PREFIX_MID_HAS_NEXT = 1;
  const int PREFIX_MID_LAST = 2;
  const int PREFIX_END_HAS_NEXT = 3;
  const int PREFIX_END_LAST = 4;
  const int PREFIX_RIGHT = 5;

  private $flags;

  private $prefix = array(
    "",    // PREFIX_LEFT
    "| ",  // PREFIX_MID_HAS_NEXT
    "  ",  // PREFIX_MID_LAST
    "|-",  // PREFIX_END_HAS_NEXT
    "\\-", // PREFIX_END_LAST
    "",    // PREFIX_RIGHT
  );

  private $postfix = "";

  public function __construct(\Traversable $it, $flags = null, $cit_flags = null,
                              $mode = null) {
    if ($flags === null) $flags = self::BYPASS_KEY;
    if ($mode === null) $mode = RecursiveIteratorIterator::SELF_FIRST;
    if ($cit_flags === null) $cit_flags = CachingIterator::CATCH_GET_CHILD;

    if ($it instanceof \IteratorAggregate) {
      $it = $it->getIterator();
    }

    $this->flags = $flags;

    $cachingIterator = new RecursiveCachingIterator($it, $cit_flags);
    parent::__construct($cachingIterator, $mode);
  }

  public function setPrefixPart($part, $prefix) {
    if ($part < 0 || $part > 5) {
      throw new OutOfRangeException(
        "Use RecursiveTreeIterator::PREFIX_* constant"
      );
    }
    $this->prefix[$part] = (string)$prefix;
  }

  public function getPrefix() {
    $return = $this->prefix[self::PREFIX_LEFT];
    $depth = $this->getDepth();
    for ($i = 0; $i < $depth; ++$i) {
      $hasNext = $this->getSubIterator($i)->hasNext();
      if ($hasNext) {
        $return .= $this->prefix[self::PREFIX_MID_HAS_NEXT];
      } else {
        $return .= $this->prefix[self::PREFIX_MID_LAST];
      }
    }

    $hasNext = $this->getSubIterator($i)->hasNext();
    if ($hasNext) {
      $return .= $this->prefix[self::PREFIX_END_HAS_NEXT];
    } else {
      $return .= $this->prefix[self::PREFIX_END_LAST];
    }

    $return .= $this->prefix[self::PREFIX_RIGHT];
    return $return;
  }

  public function setPostfix($postfix) {
    $this->postfix = (string)$postfix;
  }

  public function getEntry() {
    $current = $this->getInnerIterator()->current();
    if (is_array($current)) {
      return "Array";
    } else {
      return (string)$current;
    }
  }

  public function getPostfix() {
    return $this->postfix;
  }

  public function current() {
    if ($this->flags & self::BYPASS_CURRENT) {
      $depth = $this->getDepth();
      return $this->getSubIterator($depth)->current();
    }

    $prefix = $this->getPrefix();
    $entry = $this->getEntry();
    return $prefix . $entry . $this->postfix;
  }

  public function key() {
    $depth = $this->getDepth();
    $it = $this->getSubIterator($depth);
    $key = $it->key();
    if ($this->flags & self::BYPASS_KEY) {
      return $key;
    }

    $prefix = $this->getPrefix();
    return $prefix . $key . $this->postfix;
  }

}
}

namespace {

// This doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://docs.hhvm.com/manual/en/class.arrayobject.php )
 *
 * This class allows objects to work as arrays.
 *
 */
class ArrayObject implements IteratorAggregate, ArrayAccess,
                             Serializable, Countable {
  use StrictKeyedIterable;

  const integer STD_PROP_LIST = 1;
  const integer ARRAY_AS_PROPS = 2;

  /*
   * Note: don't add type annotations to these properties---this class
   * contains code that does unset($this->$foo) in its magic unsetter,
   * which could unset any of these properties.  The types are not
   * statically knowable.
   */
  private $storage = array();
  private $flags = 0;
  private $iteratorClass = 'ArrayIterator';

  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.construct.php )
   *
   * This constructs a new array object.
   *
   * @input      mixed   The input parameter accepts an array or an Object.
   * @flags      ?int   Flags to control the behaviour of the ArrayObject
   *                     object. See ArrayObject::setFlags().
   * @iterator_class
   *             string   Specify the class that will be used for iteration of
   *                     the ArrayObject object.
   *
   * @return     mixed   Returns an ArrayObject object on success.
   */
  public function __construct($input = null,
                               ?int $flags = null,
                               string $iterator_class = "ArrayIterator") {
    if($input instanceof ArrayObject) {
      $flags = ($flags === null) ? $input->getFlags() : $flags;
    }
    if (!$input) {
      $input = array();
    }
    $this->check_array_object_or_iterator($input);
    $this->flags = ($flags === null) ? 0 : $flags;
    $this->iteratorClass = $iterator_class;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.append.php )
   *
   * Appends a new value as the last element.
   *
   * This method cannot be called when the ArrayObject was constructed from
   * an object. Use ArrayObject::offsetSet() instead.
   *
   * @value      mixed   The value being appended.
   *
   * @return     mixed   No value is returned.
   */
  public function append($value) {
    if (!$this->isArray()) {
      throw new Exception(
        'Cannot append properties to objects, '.
        'use ArrayObject::offsetSet() instead'
      );
    }
    $this->offsetSet(null, $value);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.asort.php )
   *
   * Sorts the entries such that the keys maintain their correlation with
   * the entries they are associated with. This is used mainly when sorting
   * associative arrays where the actual element order is significant.
   *
   * @return     mixed   No value is returned.
   */
  public function asort($sort_flags = 0) {
    return asort($this->storage, $sort_flags);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.count.php )
   *
   * Get the number of public properties in the ArrayObject.
   *
   * @return     mixed   The number of public properties in the ArrayObject.
   *
   *                     When the ArrayObject is constructed from an array
   *                     all properties are public.
   */
  public function count() {
    return count($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.exchangearray.php )
   *
   * Exchange the current array with another array or object.
   *
   * @input      mixed   The new array or object to exchange with the current
   *                     array.
   *
   * @return     mixed   Returns the old array.
   */
  public function exchangeArray($input) {
    $old = $this->getArrayCopy();
    $this->check_array_object_or_iterator($input);
    return $old;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.getarraycopy.php )
   *
   * Exports the ArrayObject to an array.
   *
   * @return     mixed   Returns a copy of the array. When the ArrayObject
   *                     refers to an object an array of the public
   *                     properties of that object will be returned.
   */
  public function getArrayCopy() {
    return (array) $this->storage;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.getflags.php )
   *
   * Gets the behavior flags of the ArrayObject. See the
   * ArrayObject::setFlags method for a list of the available flags.
   *
   * @return     mixed   Returns the behavior flags of the ArrayObject.
   */
  public function getFlags() {
    return $this->flags;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.getiterator.php )
   *
   * Create a new iterator from an ArrayObject instance.
   *
   * @return     mixed   An iterator from an ArrayObject.
   */
  public function getIterator() {
    $class = $this->iteratorClass;
    return new $class($this->storage, $this->flags);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.getiteratorclass.php
   * )
   *
   * Gets the class name of the array iterator that is used by
   * ArrayObject::getIterator().
   *
   * @return     mixed   Returns the iterator class name that is used to
   *                     iterate over this object.
   */
  public function getIteratorClass() {
    return $this->iteratorClass;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.ksort.php )
   *
   * Sorts the entries by key, maintaining key to entry correlations. This
   * is useful mainly for associative arrays.
   *
   * @return     mixed   No value is returned.
   */
  public function ksort($sort_flags = 0) {
    return ksort($this->storage, $sort_flags);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.natcasesort.php )
   *
   * This method is a case insensitive version of ArrayObject::natsort.
   *
   * This method implements a sort algorithm that orders alphanumeric
   * strings in the way a human being would while maintaining key/value
   * associations. This is described as a "natural ordering".
   *
   * @return     mixed   No value is returned.
   */
  public function natcasesort() {
    return natcasesort($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.natsort.php )
   *
   * This method implements a sort algorithm that orders alphanumeric
   * strings in the way a human being would while maintaining key/value
   * associations. This is described as a "natural ordering". An example of
   * the difference between this algorithm and the regular computer string
   * sorting algorithms (used in ArrayObject::asort) method can be seen in
   * the example below.
   *
   * @return     mixed   No value is returned.
   */
  public function natsort() {
    return natsort($this->storage);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.offsetexists.php )
   *
   *
   * @index      mixed   The index being checked.
   *
   * @return     mixed   TRUE if the requested index exists, otherwise FALSE
   */
  public function offsetExists($index) {
    if ($this->isArray()) {
      return array_key_exists($index, $this->storage);
    } else {
      return property_exists($this->storage, $index);
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.offsetget.php )
   *
   *
   * @index      mixed   The index with the value.
   *
   * @return     mixed   The value at the specified index or NULL.
   */
  public function offsetGet($index) {
    if ($this->isArray()) {
      return $this->storage[$index];
    } else {
      $obj = $this->storage;
      return $obj->$index;
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.offsetset.php )
   *
   * Sets the value at the specified index to newval.
   *
   * @index      mixed   The index being set.
   * @newval     mixed   The new value for the index.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetSet($index, $newval) {
    if ($this->isArray()) {
      if ($index === null) {
        $this->storage[] = $newval;
      } else {
        $this->storage[$index] = $newval;
      }
    } else {
      $obj = $this->storage;
      $obj->$index = $newval;
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.offsetunset.php )
   *
   * Unsets the value at the specified index.
   *
   * @index      mixed   The index being unset.
   *
   * @return     mixed   No value is returned.
   */
  public function offsetUnset($index) {
    if (!$this->offsetExists($index)) {
      [][$index]; // Try to access wrong key so a Notice is raised
      return;
    }
    if ($this->isArray()) {
      unset($this->storage[$index]);
    } else {
      $obj = $this->storage;
      unset($obj->$index);
    }
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.serialize.php )
   *
   * Serializes an ArrayObject. Warning: This function is currently not
   * documented; only its argument list is available.
   *
   * @return     mixed   The serialized representation of the ArrayObject.
   */
  public function serialize() {
    /**
     * This implementation is not compatible with PHP's. We cannot implement it
     * because we lack a way to unserialize inline.

      Correct implementation:

      $props =
        array_diff_key(get_object_vars($this), get_class_vars('ArrayObject'));

      return
        'x:' . serialize($this->flags) .
        serialize($this->storage) . ';' .
        'm:' . serialize($props);
     */

    return serialize(get_object_vars($this));

  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.setflags.php )
   *
   * Set the flags that change the behavior of the ArrayObject.
   *
   * @flags      mixed   The new ArrayObject behavior. It takes on either a
   *                     bitmask, or named constants. Using named constants
   *                     is strongly encouraged to ensure compatibility for
   *                     future versions.
   *
   *                     The available behavior flags are listed below. The
   *                     actual meanings of these flags are described in the
   *                     predefined constants. ArrayObject behavior flags
   *                     value constant 1 ArrayObject::STD_PROP_LIST 2
   *                     ArrayObject::ARRAY_AS_PROPS
   *
   * @return     mixed   No value is returned.
   */
  public function setFlags(int $flags) {
    $this->flags = $flags;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.setiteratorclass.php
   * )
   *
   * Sets the classname of the array iterator that is used by
   * ArrayObject::getIterator().
   *
   * @iterator_class
   *             mixed   The classname of the array iterator to use when
   *                     iterating over this object.
   *
   * @return     mixed   No value is returned.
   */
  public function setIteratorClass(string $iterator_class) {
    $this->iteratorClass = $iterator_class;
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.uasort.php )
   *
   * This function sorts the entries such that keys maintain their
   * correlation with the entry that they are associated with, using a
   * user-defined comparison function.
   *
   * This is used mainly when sorting associative arrays where the actual
   * element order is significant.
   *
   * @cmp_function
   *             mixed   Function cmp_function should accept two parameters
   *                     which will be filled by pairs of entries. The
   *                     comparison function must return an integer less
   *                     than, equal to, or greater than zero if the first
   *                     argument is considered to be respectively less than,
   *                     equal to, or greater than the second.
   *
   * @return     mixed   No value is returned.
   */
  public function uasort($cmp_function) {
    uasort($this->storage, $cmp_function);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.uksort.php )
   *
   * This function sorts the keys of the entries using a user-supplied
   * comparison function. The key to entry correlations will be maintained.
   *
   * @cmp_function
   *             mixed   The callback comparison function.
   *
   *                     Function cmp_function should accept two parameters
   *                     which will be filled by pairs of entry keys. The
   *                     comparison function must return an integer less
   *                     than, equal to, or greater than zero if the first
   *                     argument is considered to be respectively less than,
   *                     equal to, or greater than the second.
   *
   * @return     mixed   No value is returned.
   */
  public function uksort($cmp_function) {
    uksort($this->storage, $cmp_function);
  }

  // This doc comment block generated by idl/sysdoc.php
  /**
   * ( excerpt from http://docs.hhvm.com/manual/en/arrayobject.unserialize.php )
   *
   * Unserializes a serialized ArrayObject. Warning: This function is
   * currently not documented; only its argument list is available.
   *
   * @serialized mixed   The serialized ArrayObject.
   *
   * @return     mixed   The unserialized ArrayObject.
   */
  public function unserialize($serialized) {
    if (empty($serialized)) {
      throw new UnexpectedValueException(
        'Empty serialized string cannot be empty'
      );
    }

    $data = unserialize($serialized);
    foreach ($data as $prop => $value) {
      $this->$prop = $value;
    }

  }

  public function __set ($name, $value) {
    if (!$this->hasProps()) {
      $this->$name = $value;
    } else {
      return $this->offsetSet($name, $value);
    }
  }

  public function __get (string $name) {
    if (!$this->hasProps()) {
      return $this->$name;
    } else {
      return $this->offsetGet($name);
    }
  }

  public function __isset (string $name) {
    if (!$this->hasProps()) {
      return isset($this->$name);
    } else {
      return $this->offsetExists($name);
    }
  }

  public function __unset (string $name) {
    if (!$this->hasProps()) {
      unset($this->$name);
    } else {
      return $this->offsetUnset($name);
    }
  }

  private function isArray() {
    return is_array($this->storage);
  }

  private function hasProps() {
    return $this->flags & self::ARRAY_AS_PROPS;
  }

  private function check_array_object_or_iterator($input) {
    if (!is_array($input) && gettype($input) !== 'object') {
      $this->storage = array();
      throw new InvalidArgumentException(
        "Passed variable is not an array or object, using empty array instead"
      );
    } else if (($input instanceof ArrayObject) ||
               ($input instanceof ArrayIterator)) {
      $this->storage = $input->getArrayCopy();
    } else {
      $this->storage = $input;
    }
  }

  public function __debugInfo() {
    return array_merge(
      array_diff_key(get_object_vars($this), get_class_vars('ArrayObject')),
      array(
        "\0ArrayObject\0storage" => $this->storage,
      ),
    );
  }

  /*
   * Magic function called when invoking reset($arrayObject)
   */
  private function __reset() {
    if($this->flags & self::STD_PROP_LIST) {
      return false;
    }
    reset($this->storage);
  }

  /*
   * Magic function called when invoking current($arrayObject)
   */
  private function __current() {
    if($this->flags & self::STD_PROP_LIST) {
      return false;
    }
    return current($this->storage);
  }

  /*
   * Magic function called when invoking key($arrayObject)
   */
  private function __key() {
    if($this->flags & self::STD_PROP_LIST) {
      return null;
    }
    return key($this->storage);
  }

  /*
   * Magic function called when invoking next($arrayObject)
   */
  private function __next() {
    if($this->flags & self::STD_PROP_LIST) {
      return false;
    }
    return next($this->storage);
  }

  /*
   * Magic function called when invoking prev($arrayObject)
   */
  private function __prev() {
    if($this->flags & self::STD_PROP_LIST) {
      return false;
    }
    return prev($this->storage);
  }

  /*
   * Magic function called when invoking each($arrayObject)
   */
  private function __each() {
    if($this->flags & self::STD_PROP_LIST) {
      return false;
    }
    return each($this->storage);
  }

  /*
   * Magic function called when invoking end($arrayObject)
   */
  private function __end() {
    if($this->flags & self::STD_PROP_LIST) {
      return false;
    }
    return end($this->storage);
  }
}
}

namespace {

/**
 * This function is intended to be used as a default implementation for
 * __autoload(). If nothing else is specified and spl_autoload_register()
 * is called without any parameters then this functions will be used for
 * any later call to __autoload().
 */
function spl_autoload(string $class, ?string $extensions = null) {
  if ($extensions === null) {
    $extensions = spl_autoload_extensions();
  }
  $extensions = explode(',', $extensions);
  // Lowercase, convert namespace separators to path separators
  $normalized = str_replace(
    '\\',
    '/',
    strtolower($class),
  );
  foreach ($extensions as $ext) {
    $filename = $normalized.$ext;
    @include($filename);
    if (class_exists($class)) {
      return;
    }
  }
}
}

namespace {

/**
 *
 * This is a wrapper function as lz4compress is now lz4_compress
 *
 * https://github.com/facebook/hhvm/pull/3169 - 11/07/2014
 *
 */
<<__HipHopSpecific>>
function lz4compress(string $uncompressed) {
  return lz4_compress($uncompressed);
}

/**
 *
 * This is a wrapper function as lz4hccompress is now lz4_hccompress
 *
 * https://github.com/facebook/hhvm/pull/3169 - 11/07/2014
 *
 */
<<__HipHopSpecific>>
function lz4hccompress(string $uncompressed) {
  return lz4_hccompress($uncompressed);
}

/**
 *
 * This is a wrapper function as lz4uncompress is now lz4_uncompress
 *
 * https://github.com/facebook/hhvm/pull/3169 - 11/07/2014
 *
 */
<<__HipHopSpecific>>
function lz4uncompress(string $compressed) {
  return lz4_uncompress($compressed);
}
}

<?hhas

.function array_filter($arr = no_args, $func = start("""null"""), $flag = start("""null"""), $res = start) {
          .numiters 2;

# if we get here, a value was supplied for $res
          String "array_filter() expects at most 3 parameters"
          Jmp warning
no_args:  String "array_filter() expects at least 1 parameter, 0 given"
          Jmp warning
not_array:
          CGetL $arr
          InstanceOfD "HH\\KeyedTraversable"
          JmpNZ start_kt
          String "array_filter() expects parameter 1 to be an array or collection"
          Jmp warning
bad_param2:
          String "array_filter() expects parameter 2 to be a valid callback"
warning:  Cns "E_WARNING"
          FCallBuiltin 2 2 "trigger_error"
          PopR
          Null
          RetC

start:          IsTypeL $arr Arr
                JmpZ not_array

                IssetL $func
                JmpZ no_func

                CGetL $func
                DecodeCufIter 0 bad_param2
.try_fault kill_iter_0 {
                NewLikeArrayL $arr 0
                SetL $res
                PopC

                CGetL $arr
                WIterInitK 1 endloop_a $v $k
  .try_fault kill_iter_1 1 {
                IssetL $flag
                JmpZ loop_val
                Int 1           # ARRAY_FILTER_USE_BOTH
                CGetL $flag
                Same
                JmpNZ loop_both
                Int 2           # ARRAY_FILTER_USE_KEY
                CGetL $flag
                Same
                JmpNZ loop_key

    loop_val:   FPushCufIter 1 0
                FPassL 0 $v
                FCall 1
                UnboxR
                JmpZ next_val
                SetWithRefLM <L:$res EL:$k> $v
    next_val:   WIterNextK 1 loop_val $v $k
                Jmp endloop_a

    loop_both:  FPushCufIter 2 0
                FPassL 0 $v
                FPassL 1 $k
                FCall 2
                UnboxR
                JmpZ next_both
                SetWithRefLM <L:$res EL:$k> $v
    next_both:  WIterNextK 1 loop_both $v $k
                Jmp endloop_a

    loop_key:   FPushCufIter 1 0
                FPassL 0 $k
                FCall 1
                UnboxR
                JmpZ next_key
                SetWithRefLM <L:$res EL:$k> $v
    next_key:   WIterNextK 1 loop_key $v $k
  }
}
endloop_a:CIterFree 0
endloop_n:CGetL $res
          RetC

no_func:  NewLikeArrayL $arr 0
          SetL $res
          PopC
          CGetL $arr
          WIterInitK 1 endloop_n $v $k
.try_fault kill_iter_1_only 1 {
loop_n:   CGetL $v
          JmpZ skip_n
          SetWithRefLM <L:$res EL:$k> $v
skip_n:   WIterNextK 1 loop_n $v $k
}
          Jmp endloop_n

start_kt:         IssetL $func
                  JmpZ no_func_kt

                  CGetL $func
                  DecodeCufIter 0 bad_param2
.try_fault kill_iter_0_kt {
                  NewLikeArrayL $arr 0
                  SetL $res
                  PopC

                  CGetL $arr
                  IterInitK 1 endloop_a_kt $v $k
  .try_fault kill_iter_1_kt 1 {
                  IssetL $flag
                  JmpZ loop_val_kt
                  Int 1           # ARRAY_FILTER_USE_BOTH
                  CGetL $flag
                  Same
                  JmpNZ loop_both_kt
                  Int 2           # ARRAY_FILTER_USE_KEY
                  CGetL $flag
                  Same
                  JmpNZ loop_key_kt

    loop_val_kt:  FPushCufIter 1 0
                  FPassL 0 $v
                  FCall 1
                  UnboxR
                  JmpZ next_val_kt
                  CGetL $v
                  SetM <L:$res EL:$k>
                  PopC
    next_val_kt:  IterNextK 1 loop_val_kt $v $k
                  Jmp endloop_a_kt

    loop_both_kt: FPushCufIter 2 0
                  FPassL 0 $v
                  FPassL 1 $k
                  FCall 2
                  UnboxR
                  JmpZ next_both_kt
                  CGetL $v
                  SetM <L:$res EL:$k>
                  PopC
    next_both_kt: IterNextK 1 loop_both_kt $v $k
                  Jmp endloop_a_kt

    loop_key_kt:  FPushCufIter 1 0
                  FPassL 0 $k
                  FCall 1
                  UnboxR
                  JmpZ next_key_kt
                  CGetL $v
                  SetM <L:$res EL:$k>
                  PopC
    next_key_kt:  IterNextK 1 loop_key_kt $v $k
  }
}
endloop_a_kt:CIterFree 0
endloop_n_kt:CGetL $res
             RetC

no_func_kt:  NewLikeArrayL $arr 0
             SetL $res
             PopC
             CGetL $arr
             IterInitK 1 endloop_n_kt $v $k
.try_fault kill_iter_1_only_kt 1 {
loop_n_kt:   CGetL $v
             JmpZ skip_n_kt
             CGetL $v
             SetM <L:$res EL:$k>
             PopC
skip_n_kt:   IterNextK 1 loop_n_kt $v $k
}
          Jmp endloop_n_kt

kill_iter_0:
          CIterFree 0
          Unwind
kill_iter_1:
          IterFree 1
          Unwind
# Needed for the verifier. Otherwise it complains
# because from in one fault region iter 0 is live
# and in the other its not.
kill_iter_1_only:
          IterFree 1
          Unwind

kill_iter_0_kt:
          CIterFree 0
          Unwind
kill_iter_1_kt:
          IterFree 1
          Unwind
kill_iter_1_only_kt:
          IterFree 1
          Unwind

}

.function array_map($func = no_args, $arr = one_arg, $res = one_array, ...) {
          .numiters 2;

# If we get here, a value was supplied for $res (or we did not get an
# an array as $arr), so we bail out to the c++ implementation

call_cpp_impl:
          FPushFuncD   1   "__SystemLib\\array_map"
          FCallBuiltin 0 0 "__SystemLib\\func_get_args_sl"
          UnboxR
          FPassC       0
          FCallArray
          UnboxR
          RetC

no_args:  String "array_map() expects at least 2 parameters, 0 given"
          Jmp warning

one_arg:  String "array_map() expects at least 2 parameters, 1 given"
          Jmp warning

bad_func: String "array_map() expects parameter 1 to be a valid callback"
          Jmp warning
warning:  Cns "E_USER_WARNING"
          FCallBuiltin 2 2 "trigger_error"
          PopR
          Null
          RetC

convert_to_array:
# with a null func, we have to convert the input to an array
          CGetL $arr
          FPushObjMethodD 0 "toArray" NullThrows
          FCall 0
          UnboxR
          RetC

not_array:
          CGetL $arr
          InstanceOfD "HH\\KeyedTraversable"
          JmpZ call_cpp_impl
          IssetL $func
          JmpZ convert_to_array
# make an apparently pointless copy of the loop
# we could share the one for arrays, but then we
# would max out the translation chain much quicker,
# hurting performance.

          CGetL $func
          DecodeCufIter 0 bad_func
.try_fault kill_iter_0_kt {
            NewLikeArrayL $arr 0
            SetL $res
            PopC

            CGetL $arr
            WIterInitK 1 endloop_kt $v $k
  .try_fault kill_iter_1_kt 1 {
    loop_x_kt:FPushCufIter 1 0
              FPassL 0 $v
              FCall 1
              SetWithRefRM <L:$res EL:$k>
              WIterNextK 1 loop_x_kt $v $k
   }
}
endloop_kt:
          CIterFree 0
          CGetL $res
          RetC

# if we get here, there was only one array,
# so we use the fast, php version
one_array:
          IsTypeL $arr Arr
          JmpZ not_array
          IssetL $func
          JmpZ ident
          CGetL $func
          DecodeCufIter 0 bad_func
.try_fault kill_iter_0 {
            NewLikeArrayL $arr 0
            SetL $res
            PopC

            CGetL $arr
            WIterInitK 1 endloop $v $k

  .try_fault kill_iter_1 1 {
    loop_x:   FPushCufIter 1 0
              FPassL 0 $v
              FCall 1
              SetWithRefRM <L:$res EL:$k>
              WIterNextK 1 loop_x $v $k
  }
}
endloop:  CIterFree 0
          CGetL $res
          RetC

ident:    CGetL $arr
          RetC

kill_iter_0:
          CIterFree 0
          Unwind
kill_iter_1:
          IterFree 1
          Unwind
kill_iter_0_kt:
           CIterFree 0
           Unwind
kill_iter_1_kt:
           IterFree 1
           Unwind
}

.function array_reduce($input = no_args, $func = one_arg, $res = two_args, $extra = got_args) {
          .numiters 2;

# If we get here, a value was supplied for $extra
          String "array_reduce() expects at most 3 parameters, "
          Jmp warn_num

no_args:
one_arg:  String "array_reduce() expects at least 2 parameters, "
          Jmp warn_num

bad_func: String "array_reduce() expects parameter 2 to be a valid callback"
          Jmp warning
warn_num: FCallBuiltin 0 0 "__SystemLib\\func_num_arg_"
          UnboxR
          String " given."
          ConcatN 3
warning:  Cns "E_USER_WARNING"
          FCallBuiltin 2 2 "trigger_error"
          PopR
          Null
          RetC

check_collection:
          CGetL $input
          InstanceOfD "HH\\KeyedTraversable"
          JmpNZ check_func
          String "array_reduce() expects parameter 1 to be an array or collection"
          Jmp warning

two_args: Null
          SetL $res
          PopC
got_args: IsTypeL $input Arr
          JmpZ check_collection
check_func:
          IssetL $func
          JmpZ bad_func
          CGetL $func
          DecodeCufIter 0 bad_func
.try_fault kill_iter_0 {
            CGetL $input
            IterInit 1 endloop $v

  .try_fault kill_iter_1 1 {
    loop_x:   FPushCufIter 2 0
              FPassL 0 $res
              FPassL 1 $v
              FCall 2
              UnboxR
              SetL $res
              PopC
              IterNext 1 loop_x $v
  }
}
endloop:  CIterFree 0
          CGetL $res
          RetC

kill_iter_0:
          CIterFree 0
          Unwind
kill_iter_1:
          IterFree 1
          Unwind
}
